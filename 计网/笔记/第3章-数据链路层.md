## 0
1.数据链路层：负责在单个链路上传递信息帧；处理传输错误并调节数据流[[ch03.pdf#page=2|ch03, p.2]]
2.节点和链路
拓扑图→抽象[[ch03.pdf#page=3|ch03, p.3]]
来自Internet上一点的数据单元需要经过许多网络（LANs局域网和WANs广域网）才能到达另一点。这些局域网和广域网通过路由器连接。
节点：两台终端主机和路由器
链路：两者之间的网络
3.两类链路：点到点&广播
①点到点（P2P）：使用了媒体的全部容量；专用于两个设备
②广播：只占用链路的一部分容量；在几对设备之间共享
4.数据链路层的两个子层
①DLC/LLC数据链路控制子层：处理点对点和广播链路共同的所有问题
②MAC介质访问控制子层：只处理特定于广播链路的问题
③广播式链路有DLC和MAC；P2P只有DLC
## 3.1 数据链路层的设计问题
### 0 数据链路层的封装与解封
1.链路层的作用：接收来自网络层的数据包/数据分组，并将其封装成帧，通过物理层发送
①分组：网络层的数据单元
②帧：链路层的数据单元
2.封装&解封过程
封装：加头加尾
解封：去头去尾
![[Pasted image 20251021101817.png]]
3.封装和解封的原因
①链路层地址通常不同于网络层地址，需要添加链路层地址信息
②不同链路可能使用不同协议和帧格式，需要适配不同链路格式
### 3.1.1 提供给网络层的服务
将数据从源主机的网络层传输到目标主机的网络层
1.数据路径：虚拟/实际[[ch03.pdf#page=9&selection=8,0,8,38|ch03, p.9]]
①虚拟通信：主机之间通过虚拟数据路径连接
②实际通信：主机之间通过实际数据路径连接
2.数据链路层的服务类型
（1）无确认的无连接服务：在没有连接/错误恢复的情况下发送帧
不建立连接、不确认、不重传、不做错误恢复
e.g.以太网
（2）有确认的无连接服务：如果需要，发送帧并重传
不建立连接，但每帧发送后会等待确认，如果没有收到确认，就会重传
e.g.802.11
（3）有确认的面向连接服务：连接建立；罕见的
先建立连接，然后按顺序可靠发送帧，每一帧都确认
### 3.1.2 成帧
将比特流分解成帧
#### 一、成帧方法
如何在接收方知道哪些字节属于同一个帧
1.字节计数法[[ch03.pdf#page=12|ch03, p.12]]
①定界方法：每个帧的开头用一个字节表示当前帧的总长度（包含这个长度字段自己）
②缺点：如果字节值出错，难以恢复同步

2.字节填充的标志字节法[[ch03.pdf#page=13|ch03, p.13]]
①定界方法：使用特殊的Flag字节作为帧的起始和结束标志
②字节填充：当数据中出现
- `FLAG`→替换为 `ESC + FLAG`
- 转义字节`ESC`→ 替换为 `ESC + ESC`
③帧结构
FLAG | Header | 有效载荷领域 | Trailer | FLAG

3.比特填充的标志比特法[[ch03.pdf#page=14|ch03, p.14]]
①定界方法：使用特殊的flag标志位来标记帧的开始与结束
②flag标志字节：01111110/0x7E
③比特填充：如果数据有6个连续的1，在传输时，在数据中的5个1之后加一个0；接收时，删除5个1后的0

4.物理层编码违例法：使用非数据符号表示帧
①定界方法：故意制造一些违反编码规则的信号，让接收方意识到是边界信号
②以曼彻斯特编码为例：
数据比特‘1’编码成“高-低”电平对，数据比特‘0’编码成 “低-高”电平对
“高-高”电平对和“低-低”电平对是违例编码。可以利用这些违规编码来定界帧的起始和终止。当链路检测到高-高或低-低这样的信号，就知道这是一个帧的边界
### 3.1.3 错误控制
1.目的：确保所有帧最终交付到目的地的网络层&&依次，确保可靠的、面向连接的服务
2.实现：确认帧+定时器
### 3.1.4 流量控制
链路层和传输层都要关注的问题
1.目的：控制传输帧的发送速度，确保发送方不会超过接收方的接收能力
2.方法
①基于反馈的流量控制：接收方向发送方发回信息，允许其发送更多数据，或者接收者告诉发送者接收者在做什么
②基于速率的流量控制：协议有一个内置机制，限制发送方传输数据速率的机制；不需要接收方的反馈
## 3.2 错误检查和纠正
### 0
1.数据传输中的两种错误类型[[ch03.pdf#page=19&selection=26,0,26,14|ch03, p.19]]
①单比特错误：给定数据单元（如字节、字符或数据包）中只有1位从1变为0或从0变为1
②突发错误：数据单元中有2位或2位以上从1变为0或从0变为1
2.错误检测与纠正：当数据在传输过程中可能受到干扰而被破坏时，发送方可以通过在数据中加入冗余信息，使接收方能够可以检测或纠正错误
①错误检测：只查看是否发生了任何错误，不关心损坏比特的数量不感兴趣
②错误纠正（更困难）：需要知道损坏的比特的确切数量和它们在消息中的位置
③错误纠正码/FEC：在数据中添加足够的冗余信息，使接收方能够根据接收到的错误数据，推断出原始发送的数据
④错误检测码：只包含足够的冗余，以允许接收方推断出发生了错误（但不知道是哪种错误），并请求重传
3.误差界限——海明距离
①码字：一条编码信息
m位原始数据位+r位冗余校验位=n位
（1）码将m位的数据转换成n位的码字，n=m+r， m个数据位和r个冗余校验位
（2）m位原始数据
  合法码字：$2^m$种不同的信息，真正用于编码的合法码
  所有码字：$2^{m+r}$种可能的n位码字组合
  无效码字：$2^{m+r}-2^m$种，不代表任何原始信息，用于检测/纠正错误
e.g.4位数据+3位校验位=7位码字
②海明距离：将一个有效码字转换为任何其他有效码字的最小位翻转
两个二进制字符串之间的海明距离=在相同长度下，不同的位置个数
e.g.
1001101
1100101
海明距离=2
③一个码的最小海明距离
$d_{min}$：所有合法码字中，两两之间的最小海明距离
e.g.4个10bit码，异或运算
0000000000
0000011111
1111100000
1111111111
任意两组码字之间的距离≥5，所以该码的最小海明距离=5
④具有最小汉明距离的码的边界$d_{min}$
$d$：可检测/纠正的错误数
$d_{min}$：码的最小海明距离
（1）纠正d个错误只需$d_{min} \geq 2*d+1$
解释：通过将接收到的无效码字映射到最近的有效码字来纠正错误，即可以用最少的位翻转到达的码字。
从一个正确的码字出发任意走d步都还是离这个码最近，离另外一个正确的码字至少有d+1步距离，因此纠错时只要知道错误不超过d位就能够将其对应纠正到最近的正确码字。
也就是从纠错的目标是从一个出错的码字推断出它原来是哪个合法码字，如果两个合法码字之间的最小距离是2d+1，那么即使某个码字在传输中出错了≤d位，也一定 更靠近原来的合法码字，而不会跑到另一个合法码字更近的位置
纠正=所有合法码字之间，半径为`d`的圆必须互不相交，否则会纠错成另一个
（2）检测d个错误只需$d_{min}\geq d+1$
解释：从一个正确的码字出发任意走d步（也就是最多有d位出错）都不会到达另外一个正确的码字，但是走d+1步就有可能到达另外一个正确码字，也就是说错了d+1个位以后被当成无错的码字接受，出错就无法被发现。
也就是如果想要能检测出最多d位错误，那么就要避免两个合法码字之间的距离太近
- 如果从某个合法码字跳错了d位以内，仍然落在无效码字，就可以检测出错误。
- 如果两个合法码字之间的距离只有d，那么出错d位时可能就会落到另一个合法码字身上，错误就无法被检测。
所以只要最小海明距离$d_{min}\geq d+1$，就能检测d位以内的错误
检测=所有合法码字之间，半径为`d`的圆不能重叠

**练习**
00000，01011，10101，11110
$d_{min}=3$
最多能检测2个错误，最多能纠正1个错误

5.线性分组码：如果任意两个合法码字按位异或后，得到的结果仍然是一个合法码字，则称该码是线性的。
即合法码字的集合在“模2加法”下封闭，也就是具有线性结构，满足向量空间的封闭性。
判断码字合法：$H·c^T=0$
$H$：(n−k)×n维的校验矩阵
$c^T$：n位码字的转置
### 3.2.1 纠错码FEC
<font color="#d99694">【注意】海明码、里德-所罗门码、LDPC低密度奇偶校验码是块编码，二进制卷积码不是块编码</font>
#### <span style="background:rgba(240, 200, 0, 0.2)">一、海明码</span>
1.海明码：一种典型的线性分组码，用于检测和纠正1位错误
①允许修正单比特错误
②使用块奇偶校验提供FEC
（1）块奇偶校验：海明码使用多个奇偶位，每个奇偶位校验一组特定的比特位。如果出错了，通过这些奇偶位的组合来定位具体哪一位出错
（2）冗余位的位置：在第$2^n$个位置放冗余位
e.g.海明（11，7）码
- `r1`控制所有位置编号中最低位是1的：即所有二进制编号末尾是 1 的位置→1、3、5、7、9、11
- `r2`控制所有编号中第2位是1的：即二进制倒数第2位是1→2、3、6、7、10、11
- `r4`控制所有编号中第3位是1的：即二进制倒数第3位是1→4、5、6、7
- `r8`控制所有编号中第4位是1的：即编号≥8→8、9、10、11
也就是每个冗余位$r_i$控制的是所有位置中，二进制编号第i位是1的那些位
（3）冗余位数量
要设计一个包含m个消息位和r个校验位的n位代码，使所有单个错误都能被纠正，我们必须有$(m+r+1)≤2^r$
- `(m + r)`：总共有这么多位，每一位都可能发生错误
- `+1`：还有一种情况是没有错误
- `2^r`：`r` 位可以组合出的不同校验结果（二进制串），每个结果对应一个错误位置或无错误
或者可以写成$(n+1)2^{m}\leq 2^n$
- 有$2^m$个合法消息（合法码字）
- 每个合法码字距离为1的错误码字有n个，再加上自身（无错）就是n+1个可能
- 所以一共需要$(n+1)2^m$个唯一的 n 位码字组合来承载这些信息
- 但n位总共只有$2^n$个组合，因此必须满足这个不等式
3.海明码的数据和冗余位[[ch03.pdf#page=30&selection=8,0,8,41|ch03, p.30]]
4.冗余位计算
第$2^n$个位置的冗余位检测该位置包含该编码的码[[ch03.pdf#page=31|ch03, p.31]]
偶校验:校验范围内1的个数加起来必须是偶数
**练习：1001101**[[ch03.pdf#page=32|ch03, p.32]]
把1001101摆在不是$2^n$(n≥0)的位置上
$(7+r+1)\leq 2^{r}$
$r_{min}=4$
4个冗余位
数据从高位填到地位，空出冗余位的位置

| 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   |     | 1   | 1   | 0   |     | 1   |     |     |
每个$r_i$检查若干位数据，使得包含自己的所有位置的二进制表示中，第i位为1
3-0011
5-0101
6-0110
7-0111
9-1001
10-1010
11-1011
①$r_1$：3 5 7 9 11
3:1
5:0
7:1
9:0
11:1
3个1→$r_1=1$
②$r_2$：3 6 7 10 11
3:1
6:1
7:1
10:0
11:1
4个1→$r_2=0$
③$r_3$：5 6 7
5:0
6:1
7:1
2个1→$r_3=0$
④$r_4$：9 10 11
9:0
10:0
11:1
1个1→$r_4=1$

| 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   | 1   | 1   | 1   | 0   | 0   | 1   | 0   | 1   |
数据1001101→码10011100101
5.使用海明码进行错误校正[[ch03.pdf#page=33|ch03, p.33]]
正确码1001101
错误码1000101（第7位出错）

| 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   |     | 0   | 1   | 0   |     | 1   |     |     |
3-0011
5-0101
6-0110
7-0111
9-1001
10-1010
11-1011
①$r_1$：3 5 7 9 11
3:1
5:0
7:0
9:0
11:1
2个1→$r_1=0$
②$r_2$：3 6 7 10 11
3:1
6:1
7:0
10:0
11:1
3个1→$r_2=1$
③$r_3$：5 6 7
5:0
6:1
7:0
1个1→$r_3=1$
④$r_4$：9 10 11
9:0
10:0
11:1
1个1→$r_4=1$
→$r_{1}r_{2}r_{3}r_{4}=0111$ 第7位出错
6.使用海明码进行突发纠错[[ch03.pdf#page=34|ch03, p.34]]
code4：0001101
code3：0110100
code2：1000110
code1：1111111
按列排序→
正确码：0011 0101 0101 1001 1111 0011 1001
错误码：0011 0101 0101 10<font color="#ff0000">10 00</font>11 0011 1001
转回原始code：
code4：0001<font color="#ff0000">0</font>01
code3：0110<font color="#ff0000">0</font>00
code2：100<font color="#ff0000">1</font>110
code1：111<font color="#ff0000">0</font>111
再使用海明码

**练习**
数据：1000001
$(7+r+1)\leq 2^{7+r}$
$r_{min}=4$

| 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   |     | 0   | 0   | 0   |     | 1   |     |     |
$r_1$：3 5 7 9 11
3:1
5:0
7:0
9:0
11:1
2个1→$r_{1}=0$
$r_2$：3 6 7 10 11
3:1
6:0
7:0
10:0
11:1
2个1→$r_2=0$
$r_3$：5 6 7
5:0
6:0
7:0
0个1→$r_3=0$
$r_4$：9 10 11
9:0
10:0
11:1
1个1→$r_4=1$

| 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   | 1   | 0   | 0   | 0   | 0   | 1   | 0   | 0   |
发送码：10010000100
出错码：100100<font color="#ff0000">1</font>0100（第5位出错）

| 11  | 10  | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   |     | 0   | 0   | 1   |     | 1   |     |     |

$r_1$：3 5 7 9 11
3:1
5:1
7:0
9:0
11:1
3个1→$r_{1}=1 \neq0$→综合症=1
$r_2$：3 6 7 10 11
3:1
6:0
7:0
10:0
11:1
2个1→$r_2=0=0$→综合症=0
$r_3$：5 6 7
5:1
6:0
7:0
1个1→$r_{3=1}\neq0$→综合症=1
$r_4$：9 10 11
9:0
10:0
11:1
1个1→$r_4=1=1$→综合症=0
$r_{4}r_{3}r_{2}r_{1}=0101$→第5位出错→第5位反转=0→正确数据=1000001
<span style="background:rgba(240, 200, 0, 0.2)">【总结】</span>
<span style="background:rgba(240, 200, 0, 0.2)">①给两个信息：计算接收到的信息的冗余码，接受信息的第</span>$r_{1}r_{2}r_{3}r_{4}$<span style="background:rgba(240, 200, 0, 0.2)">位是错误的位→翻转</span>
<span style="background:rgba(240, 200, 0, 0.2)">②给两个海明码：计算发送端的冗余码，再计算接收端的冗余码，一致=0，不一致=1，接收端海明码的第</span>$r_{4}r_{3}r_{2}r_{1}$<span style="background:rgba(240, 200, 0, 0.2)">位是错误的位→翻转</span>
#### 二、二进制卷积码（不属于块编码）
1.卷积码：连续地处理比特流，并保持内部状态
2.流程：
①输入流：输入为一个连续的比特流（例如：...111），每次输入一个比特。
②内部状态结构：
- 6个状态寄存器（S1到S6），组成一个长度为6的移位寄存器
- 每输入一个新比特，就将其放入 S1，然后其他状态向后移动一位（S1→S2，S2→S3，...）
③输出计算（由Σ表示）：
每次输入一个比特后，会输出两个比特Output bit1和Output bit2，分别是如下寄存器的奇偶校验结果：
- 输出比特1 = S1 ⊕ S2 ⊕ S3 ⊕ S5 ⊕ S6
- 输出比特2 = S1 ⊕ S2 ⊕ S4 ⊕ S5 ⊕ S6
这两个输出比特是由不同的寄存器线连接而来（参见图中箭头），是当前输入比特与之前几个状态寄存器的组合函数。
3.编码效率/原始信息占输出的比例=$\frac{1}{2}$
一个输入位产生两个输出位
4.约束长度k：一个输入比特在多长时间内会影响输出
这移位寄存器是6位，再加上当前输入位（即S1），总共是7位，所以约束长度=7，即一个输入比特会对后续7次输出产生影响，所以需要7次移位来完全刷新输入，这样它就不会影响输出
#### 三、里德-所罗门码
1.里德-所罗门码是线性分组码，是一种对一整块数据进行编码的方式，而不是对每个比特单独编码。
2.里德-所罗门码常是系统码：原始数据位保留在编码后的位置中，便于解码和检查。
3.原理：每一个n次多项式可以被n+1个点唯一确定。
4.应用：DSL、电缆数据、卫星通信、cd、dvd和蓝光光盘
#### 四、LDPC低密度奇偶校验码
1.低密度奇偶校验码也是一种线性分组码
2.原理：每个输出位只依赖于部分输入位
3.特点：适合大块数据的编码，有非常优秀的纠错能力，在某些场景下优于传统编码方式
4.应用：数字视频广播，10Gbps以太网，电力线网络，最新版本的IEEE 802.11
### 3.2.2 检错码
线性的、系统的分组码
#### 一、奇偶校验位
1.奇偶校验位：加在数据后面/前面的一位，用来检测传输过程中是否发生了单个或奇数个比特错误
①偶校验：使整个码字中的1的个数是偶数，即异或所有数据位，将结果作为奇偶位
e.g.111000有3个1→1110001
②奇校验：使整个码字中的1的个数是偶数，即异或所有数据位后，将结果与1异或，作为奇偶位
③偶校验检测过程：接收方收到数据后再次异或，如果结果≠0，即有奇数个1，则数据出错
2.只能检测奇数个错误
3.交错检测：N个奇偶校验位的交错检测最多N个突发错误，每列有奇数个错误才能被检测到
①突发错误：在传输过程中，相邻的若干位连续发生错误
②交错：把数据按列发送，每一列做一个奇偶校验
③流程
数据1：1001110
数据2：1100101
数据3：1110100
数据4：1110111
数据5：1101111
数据6：1110011
数据7：1101011
按列→
1111111→奇偶校验位=1
0111111→奇偶校验位=0
0011010→奇偶校验位=1
1000101→奇偶校验位=1
1111100→奇偶校验位=1
1001111→奇偶校验位=1
0101101→奇偶校验位=0

传出后出错→
数据1：1001110
数据2：1100<font color="#ff0000">01</font>1
数据3：11<font color="#ff0000">01</font>100
数据4：1110111
数据5：1101111
数据6：1110011
数据7：1101011
按列→
1111111→奇偶校验位=1
0111111→奇偶校验位=0
00<font color="#ff0000">0</font>1010→奇偶校验位=<font color="#ff0000">0</font>
10<font color="#ff0000">1</font>0101→奇偶校验位=<font color="#ff0000">0</font>
1<font color="#ff0000">0</font>11100→奇偶校验位=<font color="#ff0000">0</font>
1<font color="#ff0000">1</font>01111→奇偶校验位=<font color="#ff0000">0</font>
0101101→奇偶校验位=0
#### 二、校验和[[ch03.pdf#page=42|ch03, p.42]]
1.可以应用于任何长度的消息
2.流程：把数据按 N 位为一组→字，将所有字做加法，然后对结果取模（mod $2^N$）得到一个校验值（也为N位），加在数据末尾
e.g.16位一补码：所有数据 16 位一组相加（不进位），最后再取一补码作为校验和。接收端验证时，将所有字+校验和加起来，结果应该为全1，即补码加法结果为 0
Word 1：1010 1010 1010 1010   
Word 2：0101 0101 0101 0101   
Word 3：1111 0000 0000 1111`
step1-相加
Word 1 + Word 2 
= 1010 1010 1010 1010 + 
   0101 0101 0101 0101
= 1111 1111 1111 1111`
1111 1111 1111 1111+
1111 0000 0000 1111= 
1 1110 1111 1110 1110`
step2-处理溢出位
如果加法的结果大于 16 位，要把多出来的高位（第17位）加回最低位（每次处理/最后处理）
0001 1110 1111 1110 1110 
→去掉第17位的1 
→1110 1111 1110 1110
再 + 0000 0000 0000 0001 
=1110 1111 1110 1111`
step3-对结果取补码
checksum=0001 0000 0001 0000

发送端将这段checksum添加在原数据末尾一起发出，接收端把收到的所有字（包括checksum）一起加起来，结果应该是 全 1（即 1111 1111 1111 1111），否则就说明数据有错
3.特性
①改进了奇偶校验位的错误检测
②检测最多N个错误
③易受系统错误的影响，例如加零
**练习**[[ch03.pdf#page=46|ch03, p.46]]
假设消息是我们想要发送到目的地的5个4位数字的列表。除了发送这些数字外，我们还发送这些数字的总和。
例如，如果一组数字是（7,11,12,0,6），
我们发送（7,11,12,0,6,36），其中36是原始数字的和。
十进制数36在二进制中是$(100100)_2$，超出了15$(1111)_2$。要将其更改为4位数字，我们将最左边的额外位添加到右边的四位
==超出：把进位移到下面→相加→取反==
未超出：直接取反
$(10)_2+(0100)_2=(0110)_2$
checksum=取反$=(1001)_{2}=(9)_{10}$
发送（7,11,12,0,6,9）
接收方进行加法：7+11+12+0+6+9=$(45)_{10}=(101101)_2$
$(1101)_{2}+(10)_{2}=(1111)_2=(15)_{10}$
没有传输错误

4.计算传统校验和的步骤[[ch03.pdf#page=46|ch03, p.46]]

| 步骤    | 操作                               | 说明                                            |
| ----- | -------------------------------- | --------------------------------------------- |
| **1** | 将消息划分为若干个 16 位的字（word）           | 例如 128 字节的消息就分成 64 个 16 位字。每个 word 是 16 bits。 |
| **2** | 初始校验和字段设为 0                      | 因为我们还没生成 checksum，要先设 0，等计算完再填。               |
| **3** | 使用 **一补码加法**将所有 word（包括校验和字段）加起来 | 一补码加法：超出 16 位的进位会“回卷”加到最低位。                   |
| **4** | 把上述求得的和 **取反（bitwise NOT）**      | 得到最终 checksum（因为发送的是“和的反码”）                   |
| **5** | 将 checksum 添加到原始消息中一起发送          | 比如 TCP 报文会在头部有 checksum 字段                    |

| 步骤    | 操作                            | 说明                                           |
| ----- | ----------------------------- | -------------------------------------------- |
| **1** | 接收数据包及其携带的 checksum           |                                              |
| **2** | 同样将数据划分为 16 位 word            |                                              |
| **3** | 把所有 word（包括 checksum）用一补码加法相加 |                                              |
| **4** | 把和 **取反**，得到“校验后的 checksum”   |                                              |
| **5** | 如果这个结果是 `0`，说明传输正确；否则说明有误     | 因为和原本是反码关系，所以加起来应为全 1，取反应为 0。若非 0，说明传输过程有位错误 |
5.计算传统校验和的算法[[ch03.pdf#page=47|ch03, p.47]]
6.传统校验和计算的问题：如果在传输过程中，两个 16 位的字段位置互换了，传统校验和检测不出错误
①原因：传统的校验和没有加权，它平等地对待每个数据项，即数据项的顺序对计算无关紧要
②解决方法：Fletcher校验和、Adler校验和
（1）计算8位Fletcher和的算法[[ch03.pdf#page=49|ch03, p.49]]
根据每个数据项的位置对其进行加权
流程：
step1-初始化：
L=0
R=0
step2-对每个字节Di（8-bit数据项）重复执行：
R = (R + Di) mod 256 
L = (L + R) mod 256`
e.g.$D_1=5,D_2=7$
R = (0 + 5) % 256 = 5；L = (0 + 5) = 5
R = (5 + 7) = 12；L = (5 + 12) = 17
step3-输出校验和：
Checksum = L × 256 + R`
即相当于把两个 8 位值 L 和 R 拼接成一个 16 位的数：高8位是L，低8位是R
即 `Checksum = (L << 8) | R`
（2）计算Adler校验和的算法[[ch03.pdf#page=50|ch03, p.50]]
对每个单字节（8位）独立处理，使用模65521，初始化L=0, R=1
流程：
step1-初始状态：
L = 0 R = 1`
step2-对每个字节 Di（8位）执行：
R = (R + Di) mod 65521 
L = (L + R) mod 65521`
step3-组合成一个32-bit的校验和：
Checksum = L × 65536 + R = (L << 16) | R`
#### 三、循环冗余校验码CRC
1.循环码：一种特殊的线性分组码，如果一个码字被循环移动（旋转），结果是另一个码字
e.g.1011000是一个码字→循环左移→0110001也是一个码字
2.循环冗余校验（CRC）：用于局域网和广域网等网络。它增加了比特，这样传输帧作为一个多项式可以被一个生成器多项式均匀整除。
3.表示二进制字的多项式[[ch03.pdf#page=52|ch03, p.52]]
n位：$a_{0}-a_{n-1}$
4.CRC计算
①直接除：补充校验位；每次异或后舍弃最高位[[ch03.pdf#page=53|ch03, p.53]]

| 符号         | 含义                                                                    |
| ---------- | --------------------------------------------------------------------- |
| **G(x)**   | 生成多项式（已知，事先规定的标准），比如 `x⁵ + x² + 1`，对应二进制为 `101001`。其位数是 CRC 校验长度 + 1。 |
| **C(x)**   | 要发送的原始数据的多项式（例如 101111 → `x⁵ + x³ + x² + x + 1`）                      |
| **R(x)**   | 最终要附加在数据后的 CRC 校验码（计算方式：`(C(x) << R 位) % G(x)`）                       |
| **T(x)**   | 实际发送的数据（C(x) 左移 R 位补 0，再加上 CRC 校验码 R(x)）                              |
| **K**      | 原始数据的最高次幂 + 1，即原始数据长度                                                 |
| **R**      | CRC 码的长度，等于 G(x) 的位数 - 1                                              |
| **CRC 位数** | 就是 G(x) 的位数减一。例如 G(x) 是 6 位（二进制 110101），CRC 就是 5 位                    |
e.g.原始数据=1010001101
给定G(x)=110101
长度=6位→左移5位补0
101000110100000
对齐最高位异或，去除最高位后的当前最高位是1时-和G(x)异或；去除最高位后的当前最高位是0时，和0异或
→余数=01110
发送原始数据（不补0）|余数（当余数不足R位时，高位补0）
②多项式除法[[ch03.pdf#page=54|ch03, p.54]]
**练习**
①直接除=1100001110
②多项式除法=$x^9+x^8+x^3+x^2+x$
5.CRC编码&解码
①CRC编码[[ch03.pdf#page=56|ch03, p.56]]
- 去除最高位后的当前最高位是1时-实际除法
- 去除最高位后的当前最高位是0时，异或0
②CRC解码[[ch03.pdf#page=56|ch03, p.56]]
- 被除式：收到的位+冗余位
- 能整除-√；不能整除-×
6.CRC检错能力[[ch03.pdf#page=58&selection=63,0,65,18|ch03, p.58]]
①当传输错误发生时，某一位出现翻转错误=在该位加了个1
发送T(x)→接收T(x)+E(x)
错误多项式E(x)：1表示翻转位
e.g.单个突发错误：1开头+混合01＋1结尾
②不能检测出的错误：
`[(T(x) + E(x)) / G(x)] = E(x)/G(x)`  
原始T(x)是发出前就保证被 G(x) 整除的：`T(x)/G(x) = 0`，所以除以G(x)之后只剩 `E(x)/G(x)`
- 如果`E(x)`不能整除G(x)，就会有余数→错误被发现
- 如果`E(x)`刚好被G(x)整除→除法没余数→错误漏检

③生成多项式的设计
（1）单个比特翻转：如果生成多项式G(x)至少有两个项，且最低次项$x^{0}$的系数是 1，那么所有的单个比特错误都能被检测出来【至少2项&&有1】
错误多项式`E(x) = xⁱ`表示第i位发生了错误（只有那一位是1，其他是0），如果 G(x) 至少有两项，比如`G(x) = x³ + x + 1`，它不可能整除 `xⁱ`
（2）奇数个比特翻转：如果G(x)含有`(x + 1)`因子，则可以检测出任意奇数个比特翻转的错误
E(x)有奇数/偶数个项→有奇数/偶数个错误
在GF(2)（模2）里,一个多项式f(x)被x+1整除 ⇔ f(1)=0
- 如果E(x)中项数是奇数⇒(1)=1⇒不能被x+1整除
- 如果E(x)中项数是偶数⇒E(1)=0⇒可能被x+1整除
【总结】
如果G(x)至少有两项且常数项是1⇒能检测所有单比特错误
如果G(x)含`(x + 1)`因子⇒能检测所有奇数个比特错误

④2个独立单比特错误检测
$E(x)=x^{i}+x^{j}=x^{i}(x^{i-j}+1),i>j$
假设$x^j$不能被G(x)整除，那么对k≤i-j，$x^{k}+1 \nmid G(x)$→能检测所有两位独立错误

⑤突发性错误检测
起始于第i位（从右往左第i位），总长度（影响范围跨度）为k，
$E(x)=x^{i}·P(x)=x^{i}·(x^{k-1}+...+1)$
P(x)阶数≤k-1，首尾错误
e.g.k=4，从i=5位开始，错在第5、6、8位
$P(x)=x^{3}+x^{2}+1$
$E(x)=x^{5}·P(x)=x^{5}·(x^{3}+x^{2}+1)$
（1）r位校验位可以检测所有突发长度不超过r的突发性错误
G(x)-r阶
若E(x)的阶数＜G(x)的阶数→$E(x) \nmid G(x)$→检测出错误
突发错误E(x)的阶数最多是k-1→k≤r可检测出错误
（2）漏检突发长度=r+1的错误的概率为$\frac{1}{2^{r-1}}$
G(x)-r阶-r+1位
首尾=1→共$2^{r-1}$种可能
当且仅当Q(x)=E(x)时可被整除→1种可能
k位长，首尾错误，中间k-2位任意→共$N=2^{k-2}$种错误模式
（3）漏检突发长度＞r+1的错误的概率为$\frac{1}{2^r}$
G(x)-r阶-r+1位
尾=1→共$2^{r}$种可能
当且仅当Q(x)=E(x)时可被整除→1种可能
**练习**
以下哪个g(x)值保证捕获一个单比特错误？对于每种情况，不能捕获的错误是什么？
a.x+1✔️
b.$x^3$
√：第0-2位出错
×：≥3
c.1
×：所有
7.良好的G(x)的性质[[ch03.pdf#page=63&selection=27,0,27,31|ch03, p.63]]
①至少有2项
②$x^0$的系数=1
③包含因子(x+1)
e.g.以太网CRC[[ch03.pdf#page=64&selection=34,0,36,35|ch03, p.64]]
$E(x)=x^{32}+x^{31}+...+x$
√：在检测单比特错误、双错误、奇数错误和突发错误方面具有很好的性能，不容易被系统性错误绕过
## 3.3 基本数据链路层协议
### 3.3.1 初始的简化假设
1.独立进程
①物理层、数据链路层和网络层是相互独立的
物理层、数据链路层和网络层的通用实现[[ch03.pdf#page=68&selection=8,0,8,40|ch03, p.68]]
- 物理层进程+一部分数据链路层进程运行在网络接口卡NIC
- 网络层进程+另一部分数据链路层进程运行在主CPU
- 进程通过传递消息进行通信
2.单向通信：只考虑单向数据传输的情况，通信信道是可靠的、面向连接的
3.可靠的机器和进程：通信双方的硬件和软件不会崩溃或死机

### 3.3.2 基本的传输和接收
**实现链路层协议时用到的关键数据类型定义：protocol.h**

```c

#define MAX_PKT 4  /*每个数据包最大只有4个字节*/

typedef enum {false, true} boolean;  /*模拟布尔变量*/
typedef unsigned int seq_nr;  /*表示数据帧的序列号orACK帧的确认号*/
typedef struct {unsigned char data[MAX_PKT];} packet;  /*表示数据链路层中传输的数据包，每个包最大只有4个字节*/
typedef enum {data, ack, nak} frame_kind;  /*表示帧的类型：数据帧/确认帧/否定确认帧*/

/*帧结构体*/
typedef struct {
    frame_kind kind;   // 帧类型
    seq_nr seq;        // 帧的序号
    seq_nr ack;        // 确认号
    packet info;       // 承载的数据包
} frame;

void wait_for_event(event_type *event); //等待某个事件发生，并将事件类型写入event中
void from_network_layer(packet *p); //从网络层中取出一个待发送的数据包，存放到p中
void to_network_layer(packet *p); //将接收到的数据包交给网络层
void from_physical_layer(frame *r); //从物理层接收一个帧，并将其内容复制到r所指向的frame结构体中
void to_physical_layer(frame *s); //将s所指的帧发送给物理层，让其通过传输信道发送出去
void start_timer(seq_nr k); //为序列号为k的帧启动一个计时器
void stop_timer(seq_nr k); //停止序列号为k的数据帧的计时器，同时取消其超时事件
void start_ack_timer(void); //启动一个辅助ACK计时器，用于捎带确认的情况
void stop_ack_timer(void); //停止 ACK 辅助定时器
void enable_network_layer(void); //允许网络层触发network_layer_ready事件
void disable_network_layer(void); //禁止网络层触发network_layer_ready事件

#define inc(k) if (k < MAX_SEQ) k = k + 1; else k = 0
/*
实现循环递增序列号（modulo 𝑛加法）
发送和接收协议通常使用有限范围的序列号
当序列号到达最大值MAX_SEQ后，需要回到0，形成循环序列
*/
```
### 3.3.3 简单的数据链路层协议
网络层→数据链路层→物理层
#### 一、Utopia：没有流量控制或错误纠正
1.假设
①没有错误/丢包/损坏
②发送方速度=接收方速度
③只考虑从发送方到接收方的一条路
④没有流量控制或错误控制
e.g.以太网在高可靠环境下的表现

2.协议实现
``` c
/*运行环境和假设前提：
1.只支持单向数据传输：从发送方→接收方
2.假设通信信道是无差错的
3.假设接收方处理输入的速度无限快
4.所以，发送方就无限循环地快速发送数据帧到信道中
*/
typedef enum {frame_arrival} event_type; //定义了事件类型event_type，目前只支持一个事件：frame_arrival（帧到达）
#include "protocol.h"

void sender1(void) //协议1的发送端
{
    frame s;           /*用来封装即将发出的帧*/
    packet buffer;     /*用来暂存从网络层取到的数据包*/

    while(true) //无限循环，表示协议会不停地发送数据
    {
        from_network_layer(&buffer);  /*从网络层获取一个待发送的数据包，存入buffer*/
        s.info = buffer;              /*将buffer中的数据复制到帧s的info字段中*/
        to_physical_layer(&s);        /*把帧s发送到物理层*/
    }
}

void receiver1(void) //协议1的接收端
{
    frame r; //用于存储接收到的帧
    event_type event;  /*事件类型变量，由wait_for_event()填充*/

    while (true) //接收方一直运行、持续监听是否有帧到达
    {
        wait_for_event(&event);       /*等待事件发生（frame_arrival） */
        from_physical_layer(&r);      /*从物理层接收一个帧，并将其存入r*/
        to_network_layer(&r.info);    /*把帧r中携带的info字段（packet）送给网络层*/
    }
}


```
3.示意图[[ch03.pdf#page=79&selection=8,0,8,24|ch03, p.79]]
①跨两台主机的协议对等交互结构模型
发送节点→接收节点（节点包括网络层&数据链路层）
- 发送方网络层→数据链路层：网络层产生一个packet，用from_network_layer()交给数据链路层
- 数据链路层封装成帧，沿逻辑链路（通过物理媒介连接的链路层点对点连接）发出
- 接收方数据链路层→网络层：数据链路层用from_physical_layer()从物理层接收到帧，解封装出packet，用to_network_layer()交给接收方网络层
②时间轴
- 发送节点
	- 网络层→数据链路层：网络层不断产生packet
	- 数据链路层→信道：每收到一个packet，立即封装成frame并发送出去
- 信道上的帧流动：帧在时间线上传递过去
- 接收节点
	- 数据链路层→网络层：每当接收到一个帧，立即提取packet并上传网络层
#### 二、增加流量控制：停-等式协议（无差错信道）
1.假设
①接收方每次收到一个帧后，发送一个ack确认帧
②一次只允许一个未确认的帧在信道上（发送→停→等待确认）
③加入流量控制
2.协议实现：保证发送方不会比接收方速度太快
``` c
/*运行环境和假设前提：
1.只支持单向数据传输：从发送方→接收方
2.假设通信信道是无差错的
3.假设接收方的缓存空间有限，处理速度也有限
4.所以协议必须显式地防止发送方以接收方无法承受的速度发送数据
*/
typedef enum {frame_arrival} event_type;
#include "protocol.h"
void sender2(void)
{
    frame s;              // 即将发送的帧
    packet buffer;        // 用于存储从网络层接收到的数据包
    event_type event;     // 当前等待的事件，这里只可能是 frame_arrival（即收到ACK）

    while (true) //持续工作
    {
        from_network_layer(&buffer);  /*从网络层获取一个待发送的数据包，存入buffer*/
        s.info = buffer;              /*将buffer中的数据复制到帧s的info字段中*/
        to_physical_layer(&s);        /*把帧s发送到物理层*/
        
        wait_for_event(&event);        // 等待接收方发送确认帧（ACK）
    }
}
void receiver2(void)
{
    frame r, s;              // r 用于接收数据帧，s 用于发送确认帧ack
    event_type event;        // 表示当前接收的事件类型，这里只可能是 frame_arrival（即收到ACK）

    while (true) 
    {
        wait_for_event(&event);       // 等待接收事件，唯一可能是 frame_arrival
        from_physical_layer(&r);      // 从物理层获取接收到的帧
        to_network_layer(&r.info);    // 把帧中提取出的数据交给网络层
        to_physical_layer(&s);        // 发送确认帧（dummy frame）通知发送方
    }
}


```
#### 三、增加错误纠正：序号和自动重传请求ARQ（噪声信道）
1.ARQ：自动重传请求
①ARQ：如果接收方检测到帧有误或未收到帧，发送方就会在等待确认超时后自动重传
②特例：PAR-要求接收方必须显式确认（ack）成功接收到的帧
③接收端只对正确接收的帧发送ACK；发送方设置定时器：如果定时器到期仍未收到ACK，就认为丢包或错误⇒重发帧
2.序号：为了区分是新帧还是前一帧的重传
停-等协议一次只发送一个帧，因此只需要两个编号：0和1（1 bit）即可
3.协议实现
e.g.802.11
``` c
/*运行环境和假设前提：
1.只支持单向数据传输：从发送方→接收方
2.假设通信信道是无差错的
3.假设接收方的缓存空间有限，处理速度也有限
4.所以协议必须显式地防止发送方以接收方无法承受的速度发送数据
5.加入了错误控制机制
*/
#define MAX_SEQ 1 // 必须为1（表示最多1位编号:0/1）
typedef enum {frame_arrival, cksum_err, timeout} event_type; //表示可能发生的事件：到达帧/校验出错/超时
#include "protocol.h"

void sender3(void)
{
    seq_nr next_frame_to_send;  // 下一个待发送帧的序列号
    frame s;                    // 帧缓冲区
    packet buffer;              // 数据包缓冲区
    event_type event;           // 事件类型（例如 frame_arrival）

    next_frame_to_send = 0;     // 初始化下一个帧的序列号
    from_network_layer(&buffer); // 获取第一个数据包

    while (true) 
    {
        s.info = buffer;         // 构建待发送的帧
        s.seq = next_frame_to_send;  // 设置帧的序列号
        to_physical_layer(&s);    // 发送帧到物理层
        start_timer(s.seq);       // 启动计时器（如果超时则重传）

        wait_for_event(&event);  // 等待事件（帧到达、校验错误、超时）
        
        if (event == frame_arrival) 
        {
            from_physical_layer(&s); // 获取接收到的帧
            if (s.ack == next_frame_to_send) 
            {
                from_network_layer(&buffer);  // 获取下一个数据包
                inc(next_frame_to_send);      // 切换序列号
            }
        }
    }
}

void receiver3(void)
{
    seq_nr frame_expected;  // 接收方期望的下一个帧的序列号
    frame r, s;             // r 用于接收的帧，s 用于发送的确认帧（ACK）
    event_type event;       // 当前事件类型（例如 frame_arrival）

    frame_expected = 0;      // 初始化接收方期望的帧序列号为 0

    while (true) 
    {
        wait_for_event(&event);  // 等待事件发生，可能是 frame_arrival（帧到达）、cksum_err（校验错误）

        if (event == frame_arrival) 
        {  // 如果事件是帧到达
            from_physical_layer(&r);   // 从物理层获取接收到的帧

            if (r.seq == frame_expected) 
            {  // 如果帧的序列号与期望的匹配
                to_network_layer(&r.info);  // 将数据部分传递给网络层
                inc(frame_expected);       // 更新期望的下一个帧的序列号
            }

            // 发送确认帧（ACK），告诉发送方已接收帧
            s.ack = 1 - frame_expected;    // 如果接收的是序列号 0，则发送 ACK 1，反之 ACK 0
            to_physical_layer(&s);         // 发送确认帧到物理层
        }
    }
}

```
4.示意图[[ch03.pdf#page=86&selection=8,0,8,29|ch03, p.86]]
发送方将数据和CRC一起发送，并设置定时器等待ACK。
接收方收到帧后进行CRC验证，验证无误则发送ACK。
如果发送方收到ACK，就可以发送下一个新帧；若ACK超时未到，则重发原来的帧。
①无序号[[ch03.pdf#page=87&selection=8,0,8,29|ch03, p.87]]
②有序号[[ch03.pdf#page=88&selection=8,0,8,29|ch03, p.88]]
## 3.4 提高效率
### 3.4.1 目标：双向传输，多帧在途
#### 一、双向传输：捎带确认
1.捎带确认
①原理
在双向通信中，发送方和接收方都使用同一链路，可以同时进行数据发送和接收，在相同链路上交错发送数据帧与控制帧。为了提高效率，接收方暂缓发送ACK，等下一次需要发送数据帧时，将ACK附加上去一起发送。
②优点
（1）减少了单独发送ACK的开销，更高效地利用带宽。
（2）不再频繁处理单独的ACK数据包，降低了接收端的处理负担。
③缺点：需要等待什么时候有要发的数据

#### 二、多帧在途：滑动窗口
1.原理
①发送方维护一个发送窗口，窗口中的序列号是它可以发送但尚未被确认的数据帧。
②接收方维护一个接收窗口，窗口中的帧是它可以接受的合法序列号。如果帧超出了窗口范围，会被拒收。
2.三种双向滑动窗口协议：1位滑动窗口；回退n协议；选择重传
在效率、复杂性和缓冲需求方面有所不同
3.分类
①发送窗口
（1）发送方维护一个窗口，窗口中是可以发送但尚未被确认的帧。e.g.窗口大小为4，那么发送方可以连续发送编号为0~3的帧，直到收到ACK后窗口向前滑动。
（2）由于网络不可靠，有些帧可能丢失或损坏，因此这些帧需要在本地缓冲区中保留副本，以便在超时或出错时重发。
（3）当发送方收到接收方的ACK时，就会滑动窗口，即把旧的确认帧推出窗口，并引入新的可发送帧。
e.g.
窗口大小=4
已发送但未确认的帧序号为 0, 1, 2, 3
收到ACK for 0后，窗口滑动为 1, 2, 3, 4

②接收窗口
（1）接收方维护一个接受窗口，表示它当前接受哪些序列号的帧。如果收到的帧超出窗口范围，则被丢弃或忽略
（2）接收方可能接收到乱序帧，因此需要有足够的缓冲区来临时保存这些数据，等待缺失帧到达后再按顺序交付
（3）滑动方式：只有当当前窗口最左侧的帧到达且被接收时，窗口才向前滑动
e.g.如果窗口中期望的是帧4~7，但先收到帧5、6，仍无法向上传递，直到帧4到达后，4~6才可以一起交付，同时窗口前移至7~10
4.表达形式
①圆形[[ch03.pdf#page=94&selection=8,0,8,33|ch03, p.94]]
②线形[[ch03.pdf#page=95&selection=8,0,8,32|ch03, p.95]]
e.g.[[ch03.pdf#page=96&selection=16,0,16,22|ch03, p.96]]
5.流水线技术
①原因：停等协议（w=1）对于长链路效率太低，更大的窗口使流水线能够有效地使用链接
②窗口大小公式
（1）$w=2*B*D+1$
- `B`：带宽（帧/s）
- `D`：往返时延
- `BD`：带宽-时延积（单位：帧数）
（2）$w=\frac{2*BDP}{L}+1$
- `B`：带宽（bit/s）
- `BDP`：带宽-时延积（单位：bit）
- `L`：帧的长度
e.g.
B=10Mbps=10,000,000bit/s
延迟D=50ms=0.05s
每帧长度L=10,000bits
$w=\frac{2*BDP}{L}+1=\frac{2*10^{7}*0.05}{10^{4}}+1=101(帧)$
或者：
$B=\frac{B}{L}=\frac{10^{7}}{10^{4}}=10^3$
$w=2*B*D+1=2*10^{3}*0.05+1=101(帧)$
**练习**
在一条带宽为B=50kbps，单程传输延迟为D=250ms=0.25s的链路上，带宽-时延积BDP=$50*0.25$=12500比特or12.5个每帧1000比特的帧
BD=12500/1000=12.5（帧）
w=2BD+1=2×12.5+1=26帧
发送每帧t=$\frac{1000}{50000}=0.02s=20ms$
在t=0ms时，发送方开始发送第0帧，并且每隔20ms发送一个新帧
第0帧发出后250ms到达接收端，再250ms后ACK返回→ACK总共需500ms
在t=520ms时，发送方刚好完成第26帧的发送，而此时第0帧的确认ACK也刚好到达
此后，确认帧将每隔20ms到达，因此发送方将总是在它需要的时候获得继续发送的许可
从那一刻起，将始终会有 25 或 26 个尚未被确认的帧处于在途状态。换句话说，发送方的最大窗口大小就是26

③帧发送&ack返回
④链路利用率公式：$Link Utilization=\frac{\frac{n*L}{B}}{2*D+\frac{L}{B}}\leq1$
- `n`：连续发送的帧数
- `L`：每帧大小（单位：bit）
- `B`：带宽（单位：bit/s）
- `D`：时延
- $\frac{n*L}{B}$：发送`n`帧所需时间（链路上真正传送数据的时间）
- $2*D+\frac{L}{B}$：发送+ACK往返的时间（整个发送+等待周期的时间）
⑤最大可用帧数限制：$n\leq\frac{2*BDP}{L}+1$
⑥无流水线机制下的链路利用率
（1）停等协议
发送方发送一个数据帧 F1，数据帧到达接收方需要时间D
接收方处理并返回ACK，需要时间D
发送方必须等ACK返回后，才能发送下一个数据帧F2
$Link Utilization=\frac{\frac{L}{B}}{2*D+\frac{L}{B}}$
（2）有ACK捎带确认的停等协议
发送F1后，接收方不用单独发 ACK,而是等到自己有数据再把ACK捎带在返回的数据帧中
发送数据需要时间：L/B
等待数据返回：要传两个数据帧（F+F with ACK），各花L/B
总传播时间仍是2D
$Link Utilization=\frac{\frac{L}{B}}{2*D+\frac{2*L}{B}}$ 
⑦有流水线机制下的链路利用率
（1）逐帧发送短确认
发送方连续发送多个数据帧F1、F2、…、Fn，不再等待前一帧的ACK，形成流水线
接收方每收到一帧，就立刻回一个ACK。所有ACK是分开发送的，不和数据帧一起返回
假设流水线中发送了n个帧，每帧大小为L，发送时间L/B
所有帧的发送时间：$n*\frac{L}{B}$
整个过程的持续时间：$2*D+\frac{L}{B}$
- 2D：第一个数据帧的往返传播延迟
- L/B：发最后一帧所需时间
- $Link Utilization=\frac{n*\frac{L}{B}}{2*D+\frac{L}{B}}$ 
（2）ACK捎带返回
发送方连续发送F1、F2、…、Fn
接收方不会立即单独发ACK，而是等到自己也有数据要发时，把ACK搭载在反向数据帧中
发送方仍然发送了n个帧，共用时nL/B
除了传播延迟2D，还要发送两个数据帧（前向+反向），时间是2L/B
 $Link Utilization=\frac{n*\frac{L}{B}}{2*D+\frac{2*L}{B}}$ 

| 是否流水线 | ACK 方式    | 链路利用率公式                                   |
| ----- | --------- | ----------------------------------------- |
| 无     | 独立 ACK    | $\frac{\frac{L}{B}}{2*D+\frac{L}{B}}$     |
| 无     | piggyback | $\frac{\frac{L}{B}}{2*D+\frac{2*L}{B}}$   |
| 有     | 独立 ACK    | $\frac{n*\frac{L}{B}}{2*D+\frac{L}{B}}$   |
| 有     | piggyback | $\frac{n*\frac{L}{B}}{2*D+\frac{2*L}{B}}$ |

### 3.4.2 全双工、滑动窗口协议示例
#### 一、1位滑动窗口
1.序号基于模2运算，只有0/1，识别当前发送的数据帧与其确认帧ack是否匹配
2.双向通信协议&停-等协议
3.把ACK信息捎带在返回的数据帧中，而不是单独发一个ACK
4.具有传输错误处理机制+流量控制+早期定时器
5.w=1
6.实现
``` c
#define MAX_SEQ 1      // 设置最大序号为1（表示序号范围为 0 和 1）
typedef enum {frame_arrival, cksum_err, timeout} event_type;
// 事件类型：帧到达/校验和出错/超时
#include "protocol.h"

void protocol4 (void)
{
	seq_nr next_frame_to_send;   // 发送方当前要发送的帧编号（0或1）
	seq_nr frame_expected;       // 接收方期望接收的帧编号（0或1）
	frame r, s;                  // r: 接收到的帧，s: 要发送的帧
	packet buffer;               // 当前从网络层收到的数据包
	event_type event;            // 事件类型：帧到达/校验和出错/超时
	
	next_frame_to_send = 0;      // 准备发送编号为0的帧
	frame_expected = 0;          // 初始期望接收编号为0的帧
	from_network_layer(&buffer); // 从网络层提取一个数据包
	s.info = buffer;             // 把这个包装入要发送的帧中
	s.seq = next_frame_to_send;  // 设置帧的序号字段
	s.ack = 1 - frame_expected;  // 设置 piggyback 的确认号字段（对方期待的帧号相反），即已经收到了序号为 ack 的帧
	to_physical_layer(&s);       // 把帧发到物理层
	start_timer(s.seq);          // 启动计时器等待 ACK（避免丢帧死等）
	
	while (true) 
	{
	    wait_for_event(&event);  /*阻塞等待事情发生：帧到达/校验和出错/超时*/
	    
	    if (event == frame_arrival)/*收到一个帧且没有出错时*/ 
	    {  
	        from_physical_layer(&r);  /*从物理层读取这帧，保存在r中*/
	
	        if (r.seq == frame_expected) //如果接收到的帧是期望的序号
	        {
	            to_network_layer(&r.info);  /*把数据包交给网络层*/
	            inc(frame_expected);        /*翻转序号*/
	        }
	
	        if (r.ack == next_frame_to_send)//如果收到了期望的 ACK 
	        {
	            from_network_layer(&buffer);   /*从网络层获取下一包数据*/
	            inc(next_frame_to_send);       /*反转序号，准备发送下一帧*/
	        }
	    }
	    
	    //构造下一个要发送的帧
	    s.info = buffer;                /*数据内容*/
	    s.seq = next_frame_to_send;    /*帧的序号*/
	    s.ack = 1 - frame_expected;    /*对对方数据帧的确认（刚刚接收到的帧的序号）*/
	    to_physical_layer(&s);         /*发送帧到物理层*/
	    start_timer(s.seq);            /*启动定时器，避免ACK丢失*/
	}


}
```
7.时序图[[ch03.pdf#page=104&selection=8,0,8,22|ch03, p.104]]
消息格式：`(seq, ack, packet_number)`
- `seq`: 当前帧的序号（0或1）  
- `ack`: piggyback的ACK，表示已经收到编号为ack的帧  
- `packet_number`: 网络层的数据编号（A0、B0、A1 等）
- 带星号`*`的帧表示网络层成功接收到了这个包，即已经调用`to_network_layer()`
①正常情况
- A发送(0, 1, A0)：
    - `seq=0`: A发出的第一个帧
    - `ack=1`: 初始 piggyback ack（无实际意义）
    - `A0`: 来自A网络层的第一个包
- B接收到该帧，接受A0→发送(0, 0, B0)：
    - ack=0表示B确认收到了A0
- A接收(0, 0, B0)，接受B0→发送(1, 0, A1)：
    - ack=0表示A收到了B0，继续发 A1
- 接下来依次交替，每次都更新序号并携带确认
②异常情况
- A和B同时发送(0, 1, A0)与(0, 1, B0)：
    - 双方同时启动通信，互相都没收到对方的帧或未及时收到
- B没收到A0，就重发B0；A也没收到B0，就重发A0
- 结果是：彼此都收到重复帧，但protocol 4会：
    - 拒绝重复交付（通过 `r.seq == frame_expected` 判断）
    - 继续发送 ACK，直至对方收到为止
- 慢慢同步后，恢复到正常交替状态
#### 二、回退n协议
1.接收方只接受按顺序到达的帧or给按顺序到达的帧发送确认帧ACK[[ch03.pdf#page=112&selection=8,0,10,10|ch03, p.112]]
①接收方只能维护一个`frame_expected`，一旦某一帧丢失或出错，接收方就会丢弃之后所有帧
②发送方没收到ACK就会超时，然后发送方会从出错帧开始把当前发送窗口中的所有帧重新发送
2.折中
①好：接收方只需要维护一个变量`frame_expected`，不需要缓存乱序帧或排序，实现简单、资源占用小
②不好：当发送窗口很大时，一个帧出错会导致整个窗口后续帧全部重发，浪费带宽
3.滑动窗口
①接收方
（1）窗口大小：$w=1$
（2）作用：控制是否按序接受数据，只能接受一个特定编号的帧
（3）变量：$R_n$-接收方期望接收的下一个帧编号，即`frame_expected`
②发送方
（1）窗口大小：$w\lt 2^m,w_{max}=2^m-1$，m是帧序号字段的位数
区分是否是重复帧[[ch03.pdf#page=109&selection=8,0,8,30|ch03, p.109]]
（2）作用：发送窗口是一个抽象的滑动窗口结构，用于控制发送方已发但未确认&可以发送的数据帧范围
（3）变量
- $s_f$：最早未被确认的帧（窗口起点）
- $s_n$：下一个准备发送的帧编号（窗口终点）
- $s_{size}$：发送窗口大小
e.g.帧号是3位二进制（m=3），编号范围是0~7，那么窗口最大为7
4.累计确认机制：Ack for frame n表示n以及之前所有帧都被正确接收[[ch03.pdf#page=111&selection=8,0,8,25|ch03, p.111]]
ACK N=已经正确接收了编号为`N-1`的帧，并期望下一个帧是 `N`
5.示意图：每当收到一个累计ACK，表示一些帧已被成功接收，窗口就可以滑动，从而释放新的编号用来发送新帧[[ch03.pdf#page=107&selection=31,0,31,25|ch03, p.107]]
6.有限状态机：发送方和接收方在不同情况下如何处理帧、ACK、超时等事件
①发送方
（1）Ready状态：可以发包
- 状态转换事件
	- 事件：来自上层进程的数据请求
    - 动作：
        - 创建帧，序号为`Sₙ`
        - 保存副本并发送
        - 如果尚未启动计时器，就启动计时器
        - 更新`Sₙ = Sₙ + 1`   
    - 然后检查窗口是否已满：`Sₙ − S_f = S_size`
	    - 是：进入Blocking 状态  
	    - 否：继续保持Ready状态，等待下一个请求
- 接收 ACK：
	- 合法ACK，ackNo∈[S_f, Sₙ)：
	    - 向前滑动窗口 `S_f = ackNo`
	    - 如果窗口为空：停止计时器
	    - 否则：重启计时器 
	- 非法/损坏的ACK：
	    - `ackNo`不在窗口范围内（<S_f或≥Sₙ）或损坏→丢弃
- 超时：
	- 重传所有窗口中的未确认帧
	- 重启定时器
（2）Blocking 状态：窗口已满，不能再发新包
- 接收 ACK：
	- 若是合法ACK：与Ready状态一样
	    - 窗口滑动，若空→进入Ready状态    
	- 若非法/损坏ACK：丢弃，继续保持Blocking状态
- 超时：重发所有帧，重启计时器，仍保持Blocking状态，直到收到合法ACK
②接收方
接收方只有一个状态：Ready
接收事件：
（1）正确的帧（seqNo == Rₙ）：
- 接收数据
- 向上交付
- 滑动接收窗口 `Rₙ = Rₙ + 1`
- 回复 ACK：`ackNo = Rₙ`
（2）重复帧或错序帧（seqNo ≠ Rₙ）：
- 丢弃帧 
- 回复当前窗口起点 `ackNo = Rₙ`（表示还在等这个帧）
（3）损坏帧：
- 丢弃
- 不发送 ACK（默认行为，有些实现会回复 ACK）
③所有的序号计算都是模$2^m$的循环计数
e.g.0→1→2→3→0...
7.在软件中模拟多个定时器[[ch03.pdf#page=113&selection=8,0,8,41|ch03, p.113]]
8.实现
``` c
/*
1.协议5（Go-Back-N）允许存在多个未确认的帧。  
2.发送方可以在无需等待确认（ack）的情况下最多连续发送MAX_SEQ个帧。  
3.本协议并不假设网络层始终有新分组可供发送，只有当网络层确实有数据要发送时，才会触发一个network_layer_ready的事件。
*/

#define MAX_SEQ 7   /*窗口最大=2^n-1=2^3-1=7*/
typedef enum {frame_arrival, cksum_err, timeout, network_layer_ready} event_type;//事件类型：帧到达/校验和错误/发送方定时器超时/网络层准备好一个新分组供发送
#include "protocol.h"

//判断某个帧序号是否仍在窗口允许发送/接收的范围之内
static boolean between(seq_nr a, seq_nr b, seq_nr c)
{
    /*如果b在a到c之间（循环意义上），返回 true，否则返回false*/
    if (((a <= b) && (b < c)) || ((c < a) && (a <= b)) || ((b < c) && (c < a)))
    /*
    1.(a <= b) && (b < c)：正常情况
    2.(c < a) && (a <= b)：左闭右开区间跨越了最大编号边界，c < a，表示编号从a到最大编号MAX_SEQ，然后从0到c。如果b落在[a, MAX_SEQ]中，就满足条件。
    e.g.a=6,c=2，合法区间是6→7，如果b=6或b=7就满足条件
    3.(b < c) && (c < a)：如果b落在[0, c)之间，而c<a，说明合法区间是跨越边界从a到c。
    e.g.a=6,c=2，合法区间是0→1，如果b=0或b=1就满足条件
    */
        return(true);
    else
        return(false);
}

//构造并发送一个数据帧
static void send_data(seq_nr frame_nr, seq_nr frame_expected, packet buffer[])
/*
1.frame_nr：当前要发送的帧的编号。
2.frame_expected：接收方期待的下一个帧编号，用于 piggyback ACK。
3.buffer[]：缓存的待发送数据包数组，每个元素是一个 packet。
*/
{
	frame s;  // 构造即将发送的数据帧
	s.info = buffer[frame_nr];  // 把 packet 数据放入 frame 的 info 字段中
	s.seq = frame_nr;  // 把当前帧编号放入seq字段，用于接收方判断是否为期待的帧
	s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1); 
	/*
	捎带发送ack
	防止负数：先加一个模数再取模
	即ack = (frame_expected - 1 + (MAX_SEQ + 1)) % (MAX_SEQ + 1)
	*/
	to_physical_layer(&s);  // 把数据帧发送到物理层
	start_timer(frame_nr);  // 为这个帧启动一个定时器
}

//协议的主函数
void protocol5(void)
{
    seq_nr next_frame_to_send;   /*发送方将要发送的下一个帧的序号，从0开始递增，循环使用*/
    seq_nr ack_expected;         /*最早还没有被确认（ACK）的帧编号，即发送窗口的最左边界*/
    seq_nr frame_expected;       /*接收方希望收到的下一帧的编号*/
    frame r;                     /*临时变量，存储当前接收或构造的帧*/
    packet buffer[MAX_SEQ+1];   /*发送方使用的缓冲区数组，存放最多MAX_SEQ+1个待发送的帧内容*/
    seq_nr nbuffered;            /*当前缓冲区中尚未收到确认的帧数*/
    seq_nr i;                    /*用于循环索引buffer数组的变量*/
    event_type event; //事件类型

    enable_network_layer();     /*启用网络层，使得当网络层准备好数据时，可以触发事件*/
    ack_expected = 0;           /*初始化ack_expected，从编号0开始等待 ACK*/
    next_frame_to_send = 0;     /*初始化下一帧编号，从0开始发送*/
    frame_expected = 0;         /*初始化接收方，期待收到编号为 0 的帧*/
    nbuffered = 0;              /*初始时缓冲区为空，没有待确认的帧*/

	while (true) 
	{
	    wait_for_event(&event);  /*阻塞等待事情发生*/
	
	    switch(event) 
	    {
	        case network_layer_ready:  /*1.网络层有数据包可发送*/
	            /*接收、保存、传输一个新帧*/
	            from_network_layer(&buffer[next_frame_to_send]);  /*从网络层接收一个新的 packet，保存到发送窗口中*/
	            nbuffered = nbuffered + 1;  /*当前已缓冲的数据包数+1，也就是滑动窗口变大一格*/
	            send_data(next_frame_to_send, frame_expected, buffer);  
	            /*
	            发送帧，带有：
				1.next_frame_to_send：发送帧的编号
				2.frame_expected：接收方希望接收到的帧序号（用于 piggyback ACK）
				3.buffer[]：缓存的 packet 内容
				*/
	            inc(next_frame_to_send);  /*把next_frame_to_send加一。如果达到最大序号MAX_SEQ，就从0重新开始*/
	            break;
	
	        case frame_arrival:  /*2.收到来自物理层的帧*/
	            from_physical_layer(&r);  /*从物理层接收到一个帧，放入r中*/
	
	            if (r.seq == frame_expected) //如果收到的帧序号是想要的帧
	            {
	                to_network_layer(&r.info);  /*把r.info交给网络层*/
	                inc(frame_expected);  /*接收窗口前沿frame_expected++*/
	            }
	            /*累计确认：ACK n意味着n-1、n-2等帧都已被成功接收*/
				while (between(ack_expected, r.ack, next_frame_to_send)) 
				{
				    /*捎带处理*/
				    nbuffered = nbuffered - 1;          /* 有一个帧被确认，发送窗口收缩 */
				    stop_timer(ack_expected);          /* 该帧成功到达，停止定时器 */
				    inc(ack_expected);                 /* 向前滑动窗口，准备确认下一个 */
				}
				break;
			case cksum_err: ;      /*3.校验和出错*/
			    break;//直接忽略
			case timeout:  /*4.超时*/
			    next_frame_to_send = ack_expected;  /*从第一个未被确认的帧开始重新发送*/
			    for (i = 1; i <= nbuffered; i++) //循环重传未确认的帧
			    {
			        send_data(next_frame_to_send, frame_expected, buffer);  /*重新发送1个帧*/
			        inc(next_frame_to_send);  /*帧号加一*/
			    }
			    break;
			
			if (nbuffered < MAX_SEQ)//如果当前发送窗口未满
			    enable_network_layer();//允许网络层继续送新数据
			else//如果发送窗口已满
			    disable_network_layer();//禁止网络层传数据
	}
}
```
#### 三、选择重传
1.接收方接受落在接收窗口范围内的任何帧
①累计确认：表示所有编号≤N的帧都已按序收到
②nak否定确认：当某个帧出现可能的错误时，立即发送nak，通知发送方尽快重发该缺失帧，不必等到超时重传。[[ch03.pdf#page=126&selection=8,0,10,17|ch03, p.126]]
每帧有独立的计时器
2.滑动窗口
①窗口大小[[ch03.pdf#page=123&selection=8,0,8,33|ch03, p.123]]
发送窗口：$w_{max}\leq2^{m-1}$
接收窗口：$w_{max}\leq2^{m-1}$
发送窗口+接收窗口$\leq2^m$→防止新旧窗口重叠
②滑动机制[[ch03.pdf#page=122&selection=8,0,8,45|ch03, p.122]]
（1）发送窗口
- `Sf`：发送窗口最左边,已发送但未被确认的第一个帧 
- `Sn`：发送窗口右边，下一个可以发送的帧号
- `S_size = 2^(m-1)`，窗口最大为8（编号0~7）
- 收到ACK才滑动
（2）接收窗口
- `Rn`：接收方希望收到的下一帧编号
- `R_size = 2^(m-1)`： 窗口最大为8（编号0~7）
- 只有当当前期待的帧（`R_n`）真正收到后，才会滑动
3.折中
①好：只需重发丢失的帧，而不是整批重传，带宽利用更高
②不好：由于接收方必须缓存乱序到达的帧，且发送方需要为每个帧维护一个独立定时器，选择重传比Go-Back-N更复杂
4.有限状态机
①发送方
（1）初始状态：Ready
- 来自进程的请求：
    - 创建一个新包（其序号为 `S_n`），存储副本并发送。
    - 启动计时器并将`S_n`加一。
    - 转移条件：若窗口未满，则保持在`Ready`；否则（`S_n=S_f+S_size`）进入 `Blocking`。
（2）阻塞状态：Blocking
- 窗口已满：即 `S_n = S_f + size`，不能发送新包，只能等待ACK。
- 超时：
    - 重传窗口中所有未确认的包。 
    - 重新启动计时器。
（3）ACK处理逻辑：
- 接收到出错或无效ACK：丢弃，不做处理。
- 接收到无误ACK，且为某个未确认包的确认：
    - 标记该包为已确认。
    - 若 ackNo = S_f，滑动窗口。
    - 若还有未确认的包，重启计时器；否则停止计时器。
    - 若窗口滑动后仍未满，则从`Blocking`返回`Ready`。
②接收方
唯一状态：Ready
接收方始终处于 Ready 状态，处理包的方式取决于包的序号和状态：
（1）正确的数据包到达，且序号在接收窗口内：
- 若为重复包：丢弃。
- 否则：
    - 存储该包。
    - 发送 ACK。
    - 若此包是下一个期望的包（`seqNo = R_n`）：
        - 交付该包和之前已存储但未交付的连续包到应用层。
        - 滑动窗口。
（2）序号在窗口之外的包：
- 丢弃。
- 发送带有当前`ackNo = R_n`的ACK，提醒发送方当前最期待的序号。
（3）包出错：丢弃，不做其他处理。
③所有序号运算均为模$2^m$，即循环序号处理
5.实现
``` c
/*
1.协议6（非顺序接收）：接收方可以接受乱序的帧，也就是说即使缺失中间的帧，也先把后续帧接收下来，但最终仍然会将帧按顺序传给网络层。
2.每一个未确认的帧都关联一个单独的定时器。
3.只重传超时的帧，不像 Go-Back-N（协议5）中一旦超时就从该帧起全部重传。
*/
#define MAX_SEQ 7        /*最大帧编号=2^n-1=2^3-1=7 */
#define NR_BUFS ((MAX_SEQ + 1)/2) /*发送方或接收方的窗口大小设定为一半*/
typedef enum {frame_arrival, cksum_err, timeout, network_layer_ready, ack_timeout} event_type; /*事件类型：帧到达/校验和错误/数据帧超时/网络层准备好可以发送新的数据帧/ACK 确认帧超时*/
#include "protocol.h"
boolean no_nak = true;   /*标记当前是否已经发送了一个NAK（否定确认）*/
seq_nr oldest_frame = MAX_SEQ+1;  /*表示最早还未确认的帧的编号，这里初始化为MAX_SEQ+1=8，超出了合法帧号的范围，表示目前没有未确认帧*/

//判断序号是否在窗口内（左闭右开）
static boolean between(seq_nr a, seq_nr b, seq_nr c)
{
  return ((a <= b) && (b < c)) || ((c < a) && (a <= b)) || ((b < c) && (c < a));
}


//发送帧
static void send_frame(frame_kind fk, seq_nr frame_nr, seq_nr frame_expected, packet buffer[])
/*
1.fk: 帧类型，可能为data/ack/nak
2.frame_nr: 发送帧的编号（序号）
3.frame_expected: 接收方期望收到的帧号（用于ack）
4.buffer[]: 用于发送的数据缓存区，里面是待发送的数据包
*/
{
  frame s;  // 临时变量，用于构建将要发送的帧内容
  s.kind = fk;  // 帧的种类：data, ack 或 nak
  if (fk == data)
    s.info = buffer[frame_nr % NR_BUFS];  // 数据帧内容，取模保证在窗口范围内
  s.seq = frame_nr;  // 帧的序号（仅对数据帧有意义）
  s.ack = (frame_expected + MAX_SEQ) % (MAX_SEQ + 1);
  // 帧的ACK字段，表示最后一个正确收到的帧是frame_expected-1，还没收到编号为frame_expected的帧。取模保证非负
  if (fk == nak)
    no_nak = false;  // 只发送一个NAK，避免重复
  to_physical_layer(&s);  // 发送帧到物理层
  if (fk == data)
    start_timer(frame_nr % NR_BUFS);  // 启动该数据帧的定时器（用于超时重传）
  stop_ack_timer();  // 发送完数据帧后，立即 piggyback（捎带）一个ack，所以就不再需要单独发送ack帧，因此关闭专门的ack计时器。
}

/*
发送窗口：[ack_expected, next_frame_to_send)
ack_received：窗口左侧
ack_expected：窗口第一帧
next_frame_to_send：窗口右侧第一帧
接收窗口：[frame_expected, too_far)
frame_expected：窗口第一帧
to_far：窗口右侧第一帧
*/
void protocol6(void)
{
	seq_nr ack_expected;        // 发送方窗口的下边界（即期望接收确认的编号）
	seq_nr next_frame_to_send;  // 发送方窗口的上边界 + 1（即下一个要发送的帧编号）
	seq_nr frame_expected;      // 接收方窗口的下边界（期望接收的帧编号）
	seq_nr too_far;             // 接收方窗口的上边界 + 1

    int i;                     /*缓冲区索引*/
    frame r;                   /*临时变量，构造即将发送的帧*/
	packet out_buf[NR_BUFS];    // 输出缓冲区，保存要发送的数据包
	packet in_buf[NR_BUFS];     // 输入缓冲区，保存已接收的帧内容
	boolean arrived[NR_BUFS];   // 接收方接收标志数组，标记每个 buffer 是否到达
	seq_nr nbuffered;           // 当前发送窗口中等待确认的帧数
    event_type event;           //事件类型

    enable_network_layer();   /*启用网络层，表示可以开始从上层获取数据*/
    ack_expected = 0;         /* next ack expected on the inbound stream */
    next_frame_to_send = 0;   /* number of next outgoing frame */
    frame_expected = 0;       /* frame number expected */
    too_far = NR_BUFS;        /*接收窗口上边界是 buffer 数量*/
    nbuffered = 0;            /*发送窗口最初没有帧*/
    
    /*初始化接收端的arrived[]数组，表示每个接收缓冲区是否收到对应帧。刚开始全设为false，表示都还未到达*/
    for (i = 0; i < NR_BUFS; i++) 
    {
	    arrived[i] = false;
	}
	while (true) //不断监听事件
	{
	    wait_for_event(&event);   /*等待并获取一个事件：网络层有新数据可发送/物理层接收到新帧/校验和错误/发送的帧超时/ack超时*/
	    switch(event) 
	    {
	        case network_layer_ready:  /*接收、保存、传输一个新帧*/
	            nbuffered = nbuffered + 1;  /*窗口中缓存的帧数 +1*/
	            from_network_layer(&out_buf[next_frame_to_send % NR_BUFS]);  /*从网络层读取一个新数据包放入out_buf缓冲区中（取模：循环序号）*/
	            send_frame(data, next_frame_to_send, frame_expected, out_buf);  /*将该帧发送出去，发送的帧类型是data，帧编号是next_frame_to_send，frame_expected表示发送方希望收到的确认号*/
	            inc(next_frame_to_send);  /*滑动窗口右边界 */
	            break;
	        case frame_arrival:   /*一个数据帧/控制帧到达*/
			    from_physical_layer(&r);   /*从物理层获取一帧数据并存储到r中*/
			    /*处理数据帧*/
			    if (r.kind == data) 
			    {
			        /*如果收到的帧不是接收窗口下边缘期望的帧frame_expected，并且还没有发过NAK（收到了乱序帧，说明前面某个帧没到）*/
			        if ((r.seq != frame_expected) && no_nak)
			            send_frame(nak, 0, frame_expected, out_buf);//发送nak
			        else//收到了期望的帧
			            start_ack_timer();//启动ack定时器
			            
			        //如果在接受窗口范围内 & 未接收过
			        if (between(frame_expected, r.seq, too_far) &&
			            (arrived[r.seq % NR_BUFS] == false)) 
			        {
			            /* Frames may be accepted in any order. */
			            arrived[r.seq % NR_BUFS] = true;   /*标记该帧位置的缓冲区为已到达*/
			            in_buf[r.seq % NR_BUFS] = r.info;  /*把数据存到接收缓冲区in_buf[]中*/
			            
			            /*只要下一个期望的帧已经到达，就持续将帧交付给网络层，并滑动接收窗口*/
			            while (arrived[frame_expected % NR_BUFS]) 
			            {
			                /* Pass frames and advance window. */
			                to_network_layer(&in_buf[frame_expected % NR_BUFS]);//将接收到的这一帧数据送交给上层网络层进行处理
			                no_nak = true;//表示已经收到了某个期望的帧，因此不再需要发送 NAK（否定确认）提醒发送方重传了
			                arrived[frame_expected % NR_BUFS] = false;//这一帧已经交付网络层，不再需要保留在缓存中，标记它为“未占用”，释放空间
			                inc(frame_expected);   /*将接收窗口左边界frame_expected前移一位，表示下一个期待的帧号*/
			                inc(too_far);          /*将接收窗口右边界too_far也一起前移，保持接收窗口大小不变*/
			                start_ack_timer();     /*启动一个ACK定时器，用于决定是否要单独发送ACK*/
			            }
			        }
			    }
			    
			    /*处理nak：如果收到的是nak，并且r.ack+1所指的帧编号确实在发送窗口中，那就说明这一帧被确认丢失或损坏了，需要重发
			    r.ack最后成功接收到的帧编号，而不是缺的那一帧*/
			    if ((r.kind == nak) && between(ack_expected, (r.ack + 1) % (MAX_SEQ + 1), next_frame_to_send))
			    {
				    send_frame(data, (r.ack + 1) % (MAX_SEQ + 1), frame_expected, out_buf);
			    }
    
				/*处理 piggybacked ACK
				r.ack：对方告知我们已经收到编号为ack的前一帧*/
				while (between(ack_expected, r.ack, next_frame_to_send)) {
				    nbuffered = nbuffered - 1;                     /*有一帧已确认，缓存数减1*/
				    stop_timer(ack_expected % NR_BUFS);            /*停止该帧的定时器*/
				    inc(ack_expected);                             /*滑动发送窗口下边界*/
				}
				break;

			case cksum_err://校验和出错
				/*如果还没有发过NAK，就发送一个NAK，请求对方重发该帧*/
			    if (no_nak) 
			    {
				    send_frame(nak, 0, frame_expected, out_buf);
				}
			    break;
			
			case timeout://发送的帧超时
			    send_frame(data, oldest_frame, frame_expected, out_buf);//重发
			    break;
			
			case ack_timeout://ack超时
			    send_frame(ack, 0, frame_expected, out_buf);
			    break; /*主动单独发一个 ACK*/
		}

		if (nbuffered < NR_BUFS)//如果当前缓冲区还没满
		    enable_network_layer();//允许上层应用继续往下传数据
		else//如果当前缓冲区已满
		    disable_network_layer();//禁止上层应用往下传数据
	}
}
```
## 3.5 数据链路层协议示例
### HDLC高级数据链路控制
#### 一、HDLC
1.HDLC：一种比特定向的协议，即帧中的数据是以比特为基本单位进行解释的，适用于点对点和多点链路通信。
2.HDLC更多地是一个理论标准，本身在实际应用中不常直接使用，但它的定义为很多现实中使用的协议提供了基础，如 PPP点对点协议、以太网、WLAN无线局域网协议。
3.传输模式
①NRM正常响应模式
（1）主机与从机的地位不对等
- 1个主站+多个从站
- 主站：控制通信过程，负责发起命令。
- 从站：只能在主站授权后进行通信，只能响应，不能主动发起通信
（2）适用于点对点通信和多点通信
（3）示意图[[ch03.pdf#page=136&selection=24,0,24,27|ch03, p.136]]
②ABM异步平衡模式
（1）没有主从之分，链路两端的两个设备互为对等体，任意一方都可以发送命令或响应
（2）只适用于点对点通信
（3）示意图[[ch03.pdf#page=137&selection=18,0,18,27|ch03, p.137]]
#### 二、HDLC帧
HDLC协议定义了3种帧
1.信息帧I-frames
①作用：传送数据链路用户数据，传送附加在用户数据上的控制信息（捎带确认）
②结构：Flag|Address|Control|User information|FCS|Flag
③control字段格式：| 0 | N(S) | P/F | N(R) |
- 首位0表示这是一个 I-Frame
- `N(S)`：发送方帧序号
- `P/F`：Poll/Final位
- `N(R)`：期望接收对方下一帧的编号，表示确认

| 字段名称                            | 作用                                         |
| ------------------------------- | ------------------------------------------ |
| **Flag**                        | 起始和结束标志，固定为 `01111110`（即十六进制 `0x7E`），用于帧界定 |
| **Address**                     | 标识目标或源站地址（通常只有一个字节）                        |
| **Control**                     | 最关键字段，决定帧类型（I/S/U）和包含的控制信息                 |
| **User/Management information** | 仅 I/U 帧中出现：用户数据或管理数据                       |
| **FCS (Frame Check Sequence)**  | 帧检验序列，用于错误检测（如 CRC）                        |
2.监督帧S-frames
①作用：传送控制信息
②结构：Flag|Address|Control|FCS|Flag
③control字段格式：| 1 | 0 | Code | P/F | N(R) |
- 前两位10表示 S-Frame
- Code：标识是哪种监督帧（ACK、NAK、RR、RNR 等）
- 其余字段同上

3.无编号帧U-frames
①作用：用于系统管理
②结构：Flag|Address|Control|Management information|FCS|Flag
③control字段格式：| 1 | 1 | Code | P/F | Code |
- 前两位11表示 U-Frame
- 后面包含多个用于表示命令/响应种类的 Code 位（比如 SABM、DISC、UA 等）
#### 三、HDLC 协议中连接建立与释放的完整过程[[ch03.pdf#page=139&selection=8,0,8,39|ch03, p.139]]
1.阶段一：连接建立
①步骤 1：A → B 发送 SABM 帧
- SABM：请求建立ABM的通信连接
- U-frame 控制字段为：`11 11 100`
    - `11` → 表示 U-frame
    - `100` → 表示 SABM 命令
②步骤 2：B → A 回复 `UA` 帧
- UA：无编号确认，意思是B 同意建立连接，确认收到 SABM 命令
- 控制字段：`11 00 110`
    - `110` → 表示 UA 响应
此时连接建立完成，可以开始正常的数据传输。
2.阶段二：数据传输
3.阶段三：连接释放
①步骤 3：B → A 发送 DISC 帧
- DISC：请求断开连接
- 控制字段：`11 00 010`
    - `010` → 表示 DISC 命令
④步骤 4：A → B 回复 UA 帧
- 再次使用 UA 表示：确认断开连接
- 控制字段同：`11 00 110`
此时连接正式释放，通信结束。
#### 四、有错误和无错误情境下的捎带确认示例[[ch03.pdf#page=140&selection=8,0,10,5|ch03, p.140]]
I-frame 的 Control 字段格式为`0 | N(S) | P/F | N(R)`
- `0`：标识这是 I-frame
- `N(S)`：当前帧的发送编号
- `N(R)`：对对方已收到帧的确认编号，即piggybacking
1.无错误
假设：
- 节点 A 向 B 发送编号为 0,1,2 的数据帧；
- 节点 B 也在向 A 发数据帧（反方向）；
- B 的回复中会顺便携带piggybacking。
①A → B 发送：
- `data frame 0`: `N(S)=0`, `N(R)=0`
- `data frame 1`: `N(S)=1`, `N(R)=0`（说明 B 还没收到 0 以后的帧）
②B → A 发送：
- `data frame 0`: `N(S)=0`, `N(R)=2`（捎带确认前两个帧已收到）
- `data frame 1`: `N(S)=1`, `N(R)=2`
- `data frame 2`: `N(S)=2`, `N(R)=2`
- 然后再发一个S-frame：RR 3，表示前0-2帧都收到，已经准备好接收第3帧
2.有错误
- B → A 发送：
    - `data frame 0`（N(S)=0, N(R)=0）-正确接收
    - `data frame 1`-丢失
    - `data frame 2`（N(S)=2, N(R)=2）-被 B 丢弃 —— 因为HDLC默认按序接收，中间的帧 1 没收到，不能接受后续帧
- A → B 回复：
    - S-frame: REJ 1,表示拒绝，要求重发编号为 1 的帧
        - REJ是监督帧的一种，代表 NAK（否认确认）
        - Control 字段为：`10`（S-frame）+ `01`（REJ）+ `1`（请求从帧 1 开始重发）
- B → A 重新发送：
    - `data frame 1`（N(S)=1, N(R)=0）✔
    - `data frame 2`（N(S)=2, N(R)=0）✔
- A 最终回复：
    - `S-frame: RR 3`，表示所有帧都已收到，准备接收帧编号为 3
### 3.5.1 SONET上的数据包（POS）
1.SONET上的数据包是一种通信方式，用于将IP数据包封装并传输在SONET同步光网络之上
①SONET：一种光纤传输标准
②POS使用PPP协议封装
（1）封装关系：一个IP包先封装进PPP帧，PPP帧再作为有效载荷嵌入SONET帧中，或被拆成多个SONET帧传输
PPP帧结构：[[ch03.pdf#page=142&selection=8,0,8,23|ch03, p.142]]

|字段名|长度（字节）|说明|
|---|---|---|
|**Flag**|1|起止标志，固定为 `01111110`（即 `0x7E`）|
|**Address**|1|默认固定为 `11111111`（广播地址），未实际使用|
|**Control**|1|固定为 `00000011`，表示无编号模式|
|**Protocol**|1 或 2|表示上层协议，如 `0x0021` 表示 IPv4|
|**Payload**|可变|具体承载的网络层数据（如 IP 包）|
|**Checksum**|2 或 4|CRC 校验，用于检测帧传输错误|
|**Flag**|1|结束标志，仍为 `01111110`|
（2）PPP协议是一种通用的链路层协议，可用于在两个节点之间传送数据包
特性：
- 帧定界：使用 `0x7E`（01111110）作为起始和结束标志
    - 为了避免数据中出现这个标志，使用字节填充技术 
- 使用无编号模式携带IP包：
    - 无连接、无确认服务
- 使用校验和检测错误
- 结构清晰、功能划分明确：
    - LCP：建立、协商、配置 PPP 链路
    - NCP：为不同网络层协议提供配置支持
③协议栈结构：数据在每个路由器内依次通过IP→PPP→SONET层级，光纤上实际传输的是封装后的SONET帧，而非裸IP数据[[ch03.pdf#page=141&selection=8,0,8,17|ch03, p.141]]
（3）PPP和HDLC的不同

|     | PPP                                                                              | HDLC                                                 |
| --- | -------------------------------------------------------------------------------- | ---------------------------------------------------- |
| 帧结构 | 字节定界：<br>1.每一帧以字节为单位组织，8位一组，每一帧的长度是整数个字节<br>2.使用字节填充                             | 比特定界：<br>1.每一帧以位为单位组织，可以不是整数个字节（但是是整数个位）<br>2.使用比特填充 |
| 服务  | 1.PPP总是使用无编号模式来提供互联网中使用的==无连接的未确认服务==。<br>2.PPP还可以在嘈杂的环境中提供可靠的传输，例如无线网络（在实践中很少）。 | HDLC以我们研究过的方式通过滑动窗口、确认和超时提供==可靠的==传输。                |


（4）PPP协议的链路控制状态机：描述PPP链路从建立到释放的完整过程，这些状态是由LCP和NCP协议控制的。
状态节点：
`DEAD → ESTABLISH → AUTHENTICATE → NETWORK → OPEN → TERMINATE → DEAD`
- DEAD死亡状态：初始状态，表示链路未建立。如果检测到载波，则进入ESTABLISH
- ESTABLISH链路建立：双方通过LCP协议交换参数，如果成功协商则进入 AUTHENTICATE，如果协商失败则回到DEAD
- AUTHENTICATE认证：可选步骤，依据协商结果是否启用认证，如果认证成功则进入NETWORK，如果认证失败则进入TERMINATE
- NETWORK网络层配置：开始由NCP配置网络层，成功配置后进入 OPEN
- OPEN链路开放：表示 PPP 链路已完全建立，可以正常传输IP等数据。如果通信结束则进入TERMINATE
- TERMINATE终止：正在进行链路关闭过程，一旦完成则回到DEAD。如果载波被丢弃也会直接终止进入DEAD
e.g.[[ch03.pdf#page=150&selection=8,0,8,18|ch03, p.150]]
（5）PPP内部的多路复用机制
虽然PPP 主要运行在数据链路层，但它不仅仅负责封装数据帧，还包括建立链路、认证用户、传输网络层数据
3个主要协议集：
- LCP：链路控制
- APs：认证用户身份，包括PAP和CHAP
	- PAP：认证方式为用户名 + 明文密码
	- CHAP：认证方式为挑战-应答机制
- NCPs：配置网络层参数
协议值：
- LCP：0xC021
- AP：0xC023，0xC223
- NCP：0x8021
- Data：0x0021
在数据链路层中多路复用不同类型的数据[[ch03.pdf#page=145&selection=24,0,24,19|ch03, p.145]]
- 上层-网络层：有不同的网络层协议，它们的数据被封装到 PPP 帧中传输
- 中层-数据链路层：协议的帧都通过PPP封装发送，通过Protocol字段区分是哪一种类型的子协议
    - LCP：负责链路建立与终止  
    - AP（PAP/CHAP）：负责认证  
    - NCP（如 IPCP）：负责配置 IP 层通信参数
- 底层-PPP帧：PPP 帧结构中有一个Protocol字段，用来标识当前帧属于哪类协议：
    - `0xC021` → LCP 帧   
    - `0xC023/0xC223` → PAP/CHAP 认证帧  
    - `0x8021` → NCP（IPCP）帧  
    - `0x0021` → 实际的数据帧（IP 数据
（6）PPP协议中LCP报文的帧封装方式
LCP报文被封装为PPP帧的Payload部分
LCP报文格式：

|字段|长度|含义|
|---|---|---|
|**Code**|1 字节|指明是哪种 LCP 报文（如 Configure-request 等）|
|**ID**|1 字节|用于匹配请求与应答|
|**Length**|2 字节|指明整个 LCP 报文的总长度（含头部）|
|**Information**|可变|包含协商的选项、参数等|
LCP报文类型：

| Code   | Packet Type           | 功能说明                          |
| ------ | --------------------- | ----------------------------- |
| `0x01` | **Configure-request** | 发起链路配置请求，附带参数列表（MTU、压缩、认证类型等） |
| `0x02` | **Configure-ack**     | 确认全部配置项可接受                    |
| `0x03` | **Configure-nak**     | 表示某些配置项不可接受，建议修改              |
| `0x04` | **Configure-reject**  | 明确拒绝某些配置项                     |
| `0x05` | **Terminate-request** | 请求关闭链路                        |
| `0x06` | **Terminate-ack**     | 确认链路关闭请求                      |
| `0x07` | **Code-reject**       | 收到无法识别的 LCP Code 时使用          |
| `0x08` | **Protocol-reject**   | 收到无法识别的上层协议（如 NCP）            |
| `0x09` | **Echo-request**      | 用于测试对端是否在线（类似 ping）           |
| `0x0A` | **Echo-reply**        | 回应 echo-request               |
| `0x0B` | **Discard-request**   | 测试性报文，接收后应被丢弃（用于带宽测试等）        |
（7）PPP协议中PAP报文的帧封装方式
PAP报文被封装为PPP帧的Payload部分
PAP报文交互过程：用户发出认证请求，系统验证信息，回复认证成功/失败
PAP报文格式：

|字段|长度|说明|
|---|---|---|
|**Code**|1 字节|报文类型（1=request，2=ack，3=nak）|
|**ID**|1 字节|用于标识和匹配请求与响应|
|**Length**|2 字节|总长度（包括头部与数据）|

code=1：认证请求

|字段|说明|
|---|---|
|User name length + User name|用户名部分|
|Password length + Password|密码部分（明文 ❌）|

code=2：认证成功

| 字段             | 说明      |
| -------------- | ------- |
| Message length | 回复信息    |
| User name      | 原请求中用户名 |
code=3：认证失败


| 字段             | 说明      |
| -------------- | ------- |
| Message length | 回复信息    |
| User name      | 原请求中用户名 |

（8）PPP协议中CHAP报文的帧封装方式
CHAP报文被封装为PPP帧的Payload部分
CHAP认证的3次握手流程：
- System→User：Challenge-服务端发起认证，发送一个随机的挑战值，用户端根据这个挑战值和自己的密码，计算一个哈希值并发送回去
- User→System：Response-用户端发送响应值，也包含用户名
- System→User：Success/Failure-服务端用相同方法计算哈希值并比较， 匹配成功→Success，不匹配→Failure
CHAP报文格式：

|字段|长度|说明|
|---|---|---|
|Code|1 字节|表示报文类型：1=Challenge, 2=Response, 3=Success, 4=Failure|
|ID|1 字节|匹配请求和响应|
|Length|2 字节|整个 CHAP 报文的字节长度|
code=1：Challenge

|字段|说明|
|---|---|
|Challenge Length|随机数长度|
|Challenge Value|随机 Challenge 内容|
|Name|服务器名称（可选）|
code=2：Response

| 字段              | 说明                     |
| --------------- | ---------------------- |
| Response Length | 哈希值长度                  |
| Response Value  | 用 challenge 和密码计算出的哈希值 |
| Name            | 用户名                    |
|                 |                        |
code=3：Success

|字段|说明|
|---|---|
|Message|可选的人类可读信息，如 "Login OK" 或 "Authentication failed"|
code=4：Failure

| 字段      | 说明                                               |
| ------- | ------------------------------------------------ |
| Message | 可选的人类可读信息，如 "Login OK" 或 "Authentication failed" |
（9）PPP协议中IPCP报文的帧封装方式
IPCP报文被封装为PPP帧的Payload部分
IPCP数据包结构：

| 字段               | 长度  | 说明                               |
| ---------------- | --- | -------------------------------- |
| Code             | 1   | 表示该IPCP包的类型                      |
| IP               | 1   | 用来匹配请求与响应的标识符                    |
| Length           | 2   | 整个IPCP包的长度，包括Code、ID、Length和数据部分 |
| IPCP information | 可变  | 实际的协商参数                          |
IPCP包类型：

| Code值  | 含义                         |
| ------ | -------------------------- |
| `0x01` | Configure-request（配置请求）    |
| `0x02` | Configure-ack（配置确认）        |
| `0x03` | Configure-nak（配置否定，建议替代参数） |
| `0x04` | Configure-reject（配置拒绝）     |
| `0x05` | Terminate-request（请求终止）    |
| `0x06` | Terminate-ack（确认终止）        |
| `0x07` | Code-reject（代码无法识别）        |
### 3.5.2 ADSL
1.ADSL广泛用于本地环路上的宽带互联网
2.ADSL通信范围：从用户侧的DSL modem数字用户线调制解调器到ISP的DSLAM设备（这段连接称为Local loop，通常是电话线）
3.IP数据包的封装方式：IP包会先被封装在PPP，再通过AAL5送入ATM中进行传输
①PPP数据在AAL5帧中通过ATM单元传输
（1）ATM是使用短的固定大小的单元（53字节）的链路层；每个单元都有一个虚拟电路标识符
（2）AAL5是一种通过ATM发送数据包的格式
（3）PPP帧被转换为AAL5帧（PPPoA）
②AAL5帧的结构[[ch03.pdf#page=152&selection=26,0,26,13|ch03, p.152]]
- AAL5 Payload有效载荷部分：
	- `PPP protocol`（1或2字节）：表示 PPP 的封装协议类型。
	- `PPP payload`（变长）：实际承载的 PPP 数据。
- `Pad`（0–47字节）：用于对齐总长度到48的倍数，以便切片进 ATM cell。
- AAL5 Trailer尾部：
	- `Unused`（2字节）：未使用，保留字段。
	- `Length`（2字节）：表示 Payload 的总长度（不含 Pad）。
	- `CRC`（4字节）：循环冗余检验，校验整个 AAL5 帧（包括 Pad 和 Trailer 之前的所有字段）。
AAL5帧是可变长度的，构造完成后被切割成多个固定长度的48字节片段，每个片段被送入ATM cell的负载部分，所以整个AAL5帧要占用多个ATM cells才能完整传送
4.ADSL协议栈[[ch03.pdf#page=151&selection=8,0,8,13|ch03, p.151]]
①客户家庭侧
用户PC通过以太网连接DSL Modem
协议栈自上而下为：
- IP：应用层、传输层的数据封装成IP包
- PPP：对IP进行点对点封装（如认证、压缩、多路复用）
- AAL5：将PPP帧转为ATM适应格式
- ATM：将数据切割成固定大小的53字节信元进行传输
- ADSL：物理层，将ATM信元调制成电信号，通过电话线传输
②中间部分（DSL Modem – Local loop）
从DSL调制解调器发出的ADSL信号通过铜缆（电话线）送往DSLAM，这段物理传输路径称为本地回路，是ADSL通信的关键部分
③ISP机房侧
在ISP侧，由DSLAM（带路由功能）接收ADSL信号并还原出ATM信元
然后逆向解封装：
- ATM还原信元
- AAL5拼接出PPP帧
- PPP提取出IP包
- IP层处理后送入ISP网络→Internet
### 3.5.3 DOCSIS
1.DOCSIS是一种让有线电视网络支持IP数据传输的国际标准，广泛用于宽带上网服务。它定义了数据如何封装、调制、纠错并在电缆上传输。
2.DOCSIS帧中PDU定位信息的结构[[ch03.pdf#page=153&selection=8,0,10,22|ch03, p.153]]

|字段|含义|
|---|---|
|V|通常是一个 **Valid bit**，表示该 PDU 是否有效|
|Resv|保留字段（Reserved），未使用|
|PDU Ptr|**PDU 指针**，指向下一个 PDU 的起始位置|
|End of previous PDU|上一个 PDU 的末尾|
|0xFF|分隔符，用于标记边界或无效数据|
|Start of Next PDU|下一条 PDU 开始|
3.DOCSIS码字结构[[ch03.pdf#page=153&selection=8,0,10,22|ch03, p.153]]

| 字段              | 大小（字节） | 含义                                                   |
| --------------- | ------ | ---------------------------------------------------- |
| **CW Header**   | 2      | 码字头，含控制信息（例如 PDU 个数、类型等）                             |
| **Payload**     | 1–1777 | 实际的用户数据（可能含一个或多个PDU）                                 |
| **BCH parity**  | 21     | BCH纠错码，用于**检测和纠正多个比特错误**（Bose–Chaudhuri–Hocquenghem） |
| **LDPC parity** | 21     | 低密度奇偶校验码（Low Density Parity Check），进一步加强纠错           |
| **S**           | 0–2    | 填充字段，用于对齐数据，使总长度合适                                   |