网络层负责通过多个链路在端点之间传送数据包
## 5.1 网络层的设计问题
### 5.1.1 存储-转发数据包交换
#### 1.网络层协议运行的环境[[ch05.pdf#page=5&selection=8,0,8,34|ch05, p.5]]
主机H1&应用进程P1：数据从应用层→传输层→网络层封装成数据包
⬇
ISP网络内部的路由器节点，每经过一个节点就发生一次接收→存储→查表→转发
⬇
最后一跳进入目标LAN
⬇
主机2&进程2：网络层解封装，把 payload 交给上传输层，最终到达应用进程P2
#### 2.网络层采用存储-转发数据包交换的分组交换方式
Step1-有数据包要发送的主机将其发送到最近的路由器
Step2-存储转发：对每一个路由器来说，处理一个分组的流程是-数据包被接收→校验→存储→转发到下一个路由器→...→到达目标主机
### 5.1.2 提供给传输层的服务
网络层通过网络层/数据层接口向传输层提供服务
1.服务目标
①服务独立于路由器技术
②向传输层屏蔽路由器的数量、类型和拓扑结构
③可供传输层使用的网络地址应该使用统一的编址方案，甚至可以跨越LAN和WAN
#### 一、面向无连接的服务
每个数据包都是独立个体，网络层只保证尽力传输，同一条消息拆成的多个数据包可能走不同路径
#### 二、面向连接的服务
在发送数据前，网络层先在路由器中建立一条虚电路，建好虚连接后所有数据报都沿同一条路径，分组里包含源地址、目的地址、流标签和虚电路ID（定义数据包应遵循的虚电路）
### 5.1.3 无连接服务的实现
1.路由表
每个数据包包含目的地址，路由器转发时只看目的地址查本地转发表、决定下一跳；不同包可能走不同路径
`P1 → Host H1 → 路由器 A/B/C/D/E → LAN → Host H2 → P2`

| 目的地址 | 线路  |
| ---- | --- |
如果目的地址是X，就从哪一条线路转发

2.转发表
输入分组：`[ SA源地址 | DA目的地址 | Data上层数据 ]`
⬇
路由器收到分组后从首部中读取DA
⬇
转发表：如果目的地址是X，就从接口Y发出去[[ch05.pdf#page=9&selection=8,0,10,27|ch05, p.9]]
⬇
从接口Y转发分组
### 5.1.4 面向连接服务的实现
每个分组包含tag，路由器根据tag转发分组，不同链路上tag可以不同
路由器为每一条连接保存状态
在真正发送数据前，网络层先建立虚电路，可以为某条虚电路预留资源
虚电路转发表：`(入接口, VC ID) → (出接口, 新 VC ID)`
输入分组：`[ L1入标签 | SA | DA | Data ]`
⬇
路由器收到分组后从首部中读取L1
⬇
转发表：如果从接口1带着标签L1进来，那么从接口2换成标签L2发出去[[ch05.pdf#page=11&selection=8,0,10,28|ch05, p.11]]
⬇
标签替换：`[ L2 | SA | DA | Data ]`
⬇
分组从接口 2 发出
#### 虚电路建立连接的过程
##### 1.虚电路发送请求包的过程[[ch05.pdf#page=12&selection=8,0,10,7|ch05, p.12]]
`A → R1 → (R3 / R5 / R2) → R4 → B`
Step1-A→R1 发起VC建立请求:主机A想和B通信,在真正发数据前先发送申请（A to B）
Step2-R1→R3 请求继续向前：R1 收到请求后选择下一跳R3→为这条连接分配一个本地标签`Label = 14`→在自己的VC表中暂存一条表项
Step3-R3→R4：同上
Step4-R4→B 请求到达目的主机B，每个路由器都知道这条 VC 从哪来、要往哪去
##### 2.虚电路发送接收包的过程[[ch05.pdf#page=13&selection=8,0,10,16|ch05, p.13]]
Step1-B→R4 目的主机发确认：主机B收到请求，同意建立虚电路，发送ack分组回网络，B→R4这条链路分配了一个本地标签`Label = 77`，R4建立表项的一部分
Step2-R4→R3 回传确认：R4 收到确认后已经知道这条VC的下一跳是R3，在R4的VC 表中补全表项（入标签右移变出标签）
Step3-R3→R1：同上
Step4-R1→A 确认到达源主机A
最终虚电路：`A --14--> R1 --66--> R3 --22--> R4 --77--> B`
#### 在虚电路中传送数据包[[ch05.pdf#page=14&selection=8,0,10,7|ch05, p.14]]
路径：`A → R1 → R3 → R4 → B`
标签：`14 → 66 → 22 → 77`
【用出标签替换入标签】
Step1-A→R1：A发出数据包`[ 入标签14 | 源地址A | 目的地址B | Data ]`
Step2-R1的处理（第一次标签交换）：R1用`(入端口, 入标签)`查自己的VC转发表
`Incoming:  (Port 1, Label 14) Outgoing:  (Port 3, Label 66)`
把标签14→66，发出去的包变成`[ 66 | A | B | Data ]`
Step3-R3的处理（第二次标签交换）：R3的VC表
`Incoming:  (Port 1, Label 66) Outgoing:  (Port 3, Label 22)`
把标签66→22，发出的包是：`[ 22 | A | B | Data ]`
Step4-R4的处理（第三次标签交换）：R4的VC表
`Incoming:  (Port 1, Label 22) Outgoing:  (Port 4, Label 77)`
把标签22→77，发向B：`[ 77 | A | B | Data ]`
Step5-B收到带标签77的数据,识别为属于A→B这条VC,交给上层
### 5.1.5 数据包网络与虚电路网络的比较
数据包网络和虚电路网络都是分组交换

|                | 数据包网络     | 虚电路网络            |
| -------------- | --------- | ---------------- |
| 电路建立           | 不需要       | 需要               |
| 地址             | 完整资源和目的地址 | 短VCnumber        |
| 是否需要维护网络中心状态信息 | 不需要       | 需要               |
| 寻路             | 每个分组独立寻路  | 一致；在电路建立过程寻路     |
| 路由器失效的影响范围     | 不受影响      | 中断               |
| 服务质量           | 困难        | 简单（每个路由器有中间状态信息） |
| 拥塞控制           | 困难        | 简单（每个路由器有中间状态信息） |

## 5.2 <span style="background:rgba(240, 200, 0, 0.2)">单个网络中的路由算法</span>
1.路由器的2个过程
①寻路：发现网络路径
- 决定到某个目的网络的下一跳
- 填充并更新路由表
- 通过分布式算法实现
②转发：沿着一条路径发送报文
- 处理每个到达的数据包，在路由表中查找要使用的传出线路
- 在节点本地完成
2.评价指标
①效率：吞吐量、延迟、丢包率
②公平性
③收敛性
3.路由算法：将网络建模为节点和链接的图，管理路由表，做出寻路决定，决定要优化什么，更新拓扑变化的路由
4.期望性能
### 5.2.1 优化原则
最优路径的每一部分也是最优路径；它们的联合构成了一个称为汇聚树的树
最优：跳数最少
### 5.2.2 最短路径算法
Dijkstra’s algorithm
给定一个网络，选定一个目的路由器，算出所有节点到该目的的最短路径，把这些最短路径联合成汇聚树
在图上计算一个汇聚树，每个环节都有一个非负的权重/距离，最短路径是总权重最小的路径，权值为1则计算出跳数最少的路径
#### 1.算法
选定一个目的路由器，将其他节点的距离设置为无穷大
⬇
松弛到其他节点的距离
⬇
选择最小距离节点，将其添加到汇聚树`dist[u] + weight(u, v) < dist[v]`
⬇
重复此操作，直到所有节点都在汇聚树中
<font color="#c00000">【在所有还没确定的节点中选一个距离起点最小的，更新这个节点的所有邻接点的距离】</font>
e.g.[[ch05.pdf#page=26&selection=8,0,8,32|ch05, p.26]]
A→D
`X (d, p)`
- `X`：结点名 
- `d`：当前已知从A到X的最短距离
- `p`：X的前驱结点（最短路上，X 是从谁来的）
(a) 原始图：给定所有边权（非负）
(b) 初始化+第1步
起点：A
初始化：A(0, -)；邻居（直接连接）B(2,A)和G(6,A)，其他未直接连接的是∞
选择当前距离最小的未确定结点B。箭头指向B
(c) 第2步处理B：固定B，松弛B的邻居：
经B到E：2+2=4→E(4,B)
经B到C：2+7=9→C(9,B)
当前未确定中最小的是E(4,B)
(d) 第3步处理E：固定E，松弛E的邻居：
经E到G：4+1=5，比原来6小→G(5, E)
经E到F：4+2=6→F(6,E)
未确定中最小的是G(5, E)
(e) 第4步处理G：固定G，松弛G的邻居：
经G到H：5+4=9→H(9,G)
未确定中最小的是F(6,E)
(f) 第5步处理F：固定F，松弛 F 的邻居：
经F到H：6+2=8，比原来9小→H(8,F)
经F到C：6+3=9，和原来一样→C(9,B)
则D(10,H) `A → B → E → F → H → D`
#### 2.实现code[[ch05.pdf#page=27&selection=8,0,8,32|ch05, p.27]]
### 5.2.3 泛洪算法
把一个分组扩散到整个网络中所有节点：一个节点收到一个新的分组后，除了来时的那条链路，会把这个分组复制并发送到所有其他链路
优点：
- 确保数据包被发送到每个节点
- 有效的广播信息
- 非常健壮和局域化
- 只要存在一条路径，就一定能找到
- 路由器只需要知道它们的邻居
缺点：
- 发送最多的数据包
- 太浪费了
- 必须跟踪已泛洪的分组
### 5.2.4 <span style="background:rgba(240, 200, 0, 0.2)">距离向量路由算法</span>
距离向量是一种分布式路由算法，最短路径计算是跨节点的
1.算法：告诉邻居我能去哪里，能走多远
- 每个节点都知道到它邻居的链路距离
- 每个节点向所有邻居发布已知距离最小的向量
- 每个节点使用接收到的向量来更新自己的向量
- 定期重复
2.距离向量：[[ch05.pdf#page=30&selection=8,0,8,26|ch05, p.30]]
A发给每个邻居的内容是`<A:0, B:1, C:1, D:2, E:1, F:1, G:2>`
2.Bellman-Ford路由算法
①等式[[ch05.pdf#page=31&selection=8,0,8,22|ch05, p.31]]
$d_x(y) = \min\limits_{v} \{ c(x, v) + d_v(y) \}$
$d_x(y):从节点x出发,到达节点y的当前最小代价$ 
$v:邻居节点$
$c(x,v):到邻居v的代价$
$d_v(y):邻居 v 到目的 y 的距离$
e.g.[[ch05.pdf#page=32&selection=8,0,8,7|ch05, p.32]]
哪个邻居算出来的值最小,就是u去z的下一跳
②图形思想[[ch05.pdf#page=33&selection=8,0,10,8|ch05, p.33]]
③初始距离向量
- 到自己的距离是0
- 到直接相邻节点的距离是链路代价  
- 到其他所有节点的距离都是∞
④距离向量的更新过程：[[ch05.pdf#page=35&selection=8,0,8,26|ch05, p.35]]
列出new B、old B、邻居的距离向量
（1）B收到A的距离向量
`cost(B, A) = 2`
B逐项比较自己到目标的距离和先到A，再由A到目标的距离
`B[y] = min( B[y], 2 + A[y] )`
（2）B收到E的距离向量
同上
⑤距离向量&最短路径树[[ch05.pdf#page=36&selection=8,0,8,44|ch05, p.36]]
e.g.[[ch05.pdf#page=37&selection=8,0,8,23|ch05, p.37]]取各delay+各邻居距离向量对应项的最小值
每一行＋从J的四个邻居收到的距离向量的最小值填到J的新寻路表
e.g.[[ch05.pdf#page=38&selection=8,0,8,9|ch05, p.38]]

|     | A                                | B                                    | C                                                                 | D                                        | E                                        | F                                    | G                                        |
| --- | -------------------------------- | ------------------------------------ | ----------------------------------------------------------------- | ---------------------------------------- | ---------------------------------------- | ------------------------------------ | ---------------------------------------- |
| A   | 0                                | <font color="#76923c">1/A</font>     | <font color="#76923c">1/A</font>                                  | <font color="#c3d69b">1/C+1/A</font>     | <font color="#76923c">1/A</font>         | <font color="#76923c">1/A</font>     | <font color="#c3d69b">1/F+1/A</font>     |
| B   | <font color="#76923c">1/B        | 0                                    | <font color="#76923c">1/B</font>                                  | <font color="#c3d69b">1/C+1/B</font>     | <font color="#c3d69b">1/A+1/B</font>     | <font color="#c3d69b">1/A+1/B</font> | <font color="#c3d69b">1/D+1/C+1/B</font> |
| C   | <font color="#76923c">1/C</font> | <font color="#76923c">1/C</font>     | 0                                                                 | <font color="#76923c">1/C</font>         | <font color="#c3d69b">1/A+1/C</font>     | <font color="#c3d69b">1/A+1/C</font> | <font color="#c3d69b">1/D+1/C</font>     |
| D   | <font color="#c3d69b">1/C+1/D    | <font color="#c3d69b">1/C+1/D</font> | <font color="#76923c">1/D</font>                                  | 0                                        | <font color="#c3d69b">1/A+1/C+1/D</font> | <font color="#c3d69b">1/G+1/D</font> | <font color="#76923c">1/D</font>         |
| E   | <font color="#76923c">1/E</font> | <font color="#c3d69b">1/A+1/E</font> | <font color="#c3d69b">1/A+1/E</font>                              | <font color="#c3d69b">1/C+1/A+1/E</font> | 0                                        | <font color="#c3d69b">1/A+1/E</font> | <font color="#c3d69b">1/F+1/A+1/E</font> |
| F   | <font color="#76923c">1/F</font> | <font color="#c3d69b">1/A+1/F</font> | <font color="#c3d69b">1/A+1/F</font>                              | <font color="#c3d69b">1/G+1/F</font>     | <font color="#c3d69b">1/A+1/F</font>     | 0                                    | <font color="#76923c">1/F</font>         |
| G   | <font color="#c3d69b">1/F+1/G    | <font color="#fac08f">1/A+1/F+1/G    | <font color="#c3d69b">1/D+1/G                             </font> | <font color="#76923c">1/G </font>        | <font color="#c3d69b">1/A+1/F+1/G</font> | <font color="#76923c">1/G</font>     | 0                                        |

#### 无穷计数问题
好消息传播快，坏消息（链路断了）传播慢
**练习1**[[ch05.pdf#page=42&selection=100,0,100,9|ch05, p.42]]
初始：

|     | A   | B   | C   | D   |
| --- | --- | --- | --- | --- |
| A   | 0   | 11  | 2   | 7   |
| B   | 11  | 0   |     | 3   |
| C   | 2   |     | 0   | 1   |
| D   | 7   | 3   | 1   | 0   |
第1次：

|     | A           | B           | C          | D          |
| --- | ----------- | ----------- | ---------- | ---------- |
| A   | 0           | 【改：A-D-B】10 | 2          | 【改：D-C-A】3 |
| B   | 【改：A-D-B】10 | 0           | 【改：C-D-B】4 | 3          |
| C   | 2           | 【改：B-D-C】4  | 0          | 1          |
| D   | 【改：A-C-D】3  | 3           | 1          | 0          |
第2次：

|     | A            | B            | C    | D    |
| --- | ------------ | ------------ | ---- | ---- |
| A   | 0            | 【改：A-D更新为3】6 | 2    | 【改】3 |
| B   | 【改：A-D更新为3】6 | 0            | 【改】4 | 3    |
| C   | 2            | 【改】4         | 0    | 1    |
| D   | 【改】3         | 3            | 1    | 0    |

BD断开：

|     | A     | B           | C            | D           |
| --- | ----- | ----------- | ------------ | ----------- |
| A   | 0     | 【改】11       | 2            | 【改】3        |
| B   | 【改】11 | 0           | 【改：C-A-B】：13 | 【改：D-C-B】14 |
| C   | 2     | 【改】4        | 0            | 1           |
| D   | 【改】3  | 【改：B-A-D】14 | 1            | 0           |
AB断开：
B孤立，无穷计算问题

|     | A    | B    | C     | D           |
| --- | ---- | ---- | ----- | ----------- |
| A   | 0    |      | 2     | 【改】3        |
| B   |      | 0    | 【改：】： | 【改：D-C-B】14 |
| C   | 2    | 【改】4 | 0     | 1           |
| D   | 【改】3 | 【改：】 | 1     | 0           |
孤立节点+没有邻居误导（只有一个节点知道这条路）→不会无穷计数
e.g.[[ch05.pdf#page=43&selection=8,0,8,9|ch05, p.43]]

|     | A   | B   | C   | D   | E   | F   |
| --- | --- | --- | --- | --- | --- | --- |
| A   | 0   | 5   | 11  | 16  | 7   |     |
| B   |     | 0   | 6   | 12  | 6   |     |
| C   |     | 8   | 0   | 6   | 3   |     |
| D   |     | 12  | 3   | 0   | 9   |     |
| E   |     | 6   | 5   | 9   | 00  |     |
| F   |     | 2   | 2   | 10  | 4   | 0   |

### 5.2.5 <span style="background:rgba(240, 200, 0, 0.2)">链路状态路由算法</span>
链路状态是距离矢量的替代方案
【告诉所有人我有哪些邻居、每条链路的代价是多少】
#### 发现邻居
建模：[[ch05.pdf#page=45&selection=8,0,8,28|ch05, p.45]]
发现它的邻居节点，并了解其网络地址
#### 设置链路成本
链路状态分组LSP
设置到每个邻居节点的距离或者成本度量值
#### 构建链路状态数据包[[ch05.pdf#page=46&selection=8,0,8,27|ch05, p.46]]
构造一个包含所有刚刚获知的信息的数据包
结构：
- 发送方标识符
- 序号seq：区分新旧LSP
- 年龄age：每秒值-1，过期自动丢弃
- 邻居列表+到每个邻居的成本
受控泛洪：从哪条链路收到LSP，就在那条链路上发ACK，然后把LSP转发到除来路之外的所有链路
#### 分发链路状态数据包[[ch05.pdf#page=47&selection=8,0,8,35|ch05, p.47]]
将这个数据包发送给所有其他路由器，并接收来自所有其他路由器的数据包
- 平面路由：每个路由器都要认识所有路由器
- 分层路由：只需要认识自己区域的节点+其它区域的入口
#### 计算新路径
计算出到每个其他路由器的最短路径
**练习**
![[Pasted image 20251209102507.png]]
`[距离,前驱节点]`
<font color="#c00000">【每次从未确定节点中选距离最小的，加入集合并更新该节点的所有（除已确定）邻居】</font>

| step | N′      | B   | C   | D    | E   | F   | G   |
| ---- | ------- | --- | --- | ---- | --- | --- | --- |
| 0    | A       | 1,A | 4,C |      |     |     |     |
| 1    | BA      |     | 3,B | 10,B |     |     | 5,B |
| 2    | CBA     |     |     | 4,C  | 6,C |     | 5,B |
| 3    | DCBA    |     |     |      | 5,D | 7,D | 5,B |
| 4    | EDCBA   |     |     |      |     | 6,E | 5,B |
| 5    | GEDCBA  |     |     |      |     | 6,E |     |
| 6    | FGEDCBA |     |     |      |     |     |     |
距离相等：任选一个
### 5.2.6 网络内部的层次路由算法[[ch05.pdf#page=48&selection=0,0,8,37|ch05, p.48]]
分层路由减少了路由计算的工作量，但可能导致比平面路由略长的路径
### 5.2.7 广播路由算法
跳过
### 5.2.8 多播路由算法
跳过
### 5.2.9 任播路由算法
跳过
## 5.3 网络层的流量管理
### 5.3.1 流量管理的必要性：拥塞
拥塞的发生[[ch05.pdf#page=55&selection=8,0,8,10|ch05, p.55]]
当提供太多的交通流量时，就会产生拥塞；由于丢失/重传，导致性能下降
### 5.3.2 流量管理的方法
拥塞管理方法的时间尺度[[ch05.pdf#page=56&selection=8,0,8,32|ch05, p.56]]
慢&事先预防→快&事后响应：网络规划-流量感知路由-准入控制-限速-丢包
#### 流量感知路由
根据拓扑结构+流量选择路由，需要避免震荡（路由来回切换）
- 路由算法不再仅仅基于拓扑结构（如跳数），而是根据链路的实际负载来动态选择路径（例如，如果“西-东”链路拥堵，就绕道走其他路径）
- 如果不小心，这可能导致路由振荡，即流量在两条路径间来回波动
#### 准入控制
- 只有当网络有足够的容量时，准入控制才允许新的流量负载
- 如果网络没有足够的容量（带宽、缓冲区），则直接拒绝建立新的连接，防止网络过载
e.g.虚电路
#### 负载脱落
当所有其他方法都失败时，路由器只能选择丢弃数据包以腾出缓冲区
#### 流量整形
【这是在数据进入网络之前】对进入网络的数据的进入网络的发送速率和突发程度进行调节
- R（Rate）：长期平均速率  
- B（Burst）：最大允许的短期突发量
算法：
- 漏桶算法：限速
	- 强制数据以恒定的速率流出，无论输入流量多么突发。它平滑了流量，但可能增加延迟
- 令牌桶算法：每发一个包，需要消耗一个令牌，没有令牌则需要等待
	- e.g.原始流量→令牌桶整形→恒速整形
	- $最大突发数据=B+R*S$
		- $B:桶里原有的令牌$
		- $R*S:突发期间新产生的令牌$
	- $当以速率M送时,MS=B+RS→突发时间S=\frac{B}{M-R}$
#### 主动队列管理
#### 随机早期检测
#### 抑制数据包
#### 显式拥塞通知ECN
>路由器不直接丢包，而是在数据包头部打上拥塞标记。接收方收到后，会通知发送方降低发送速率

拥塞的路由器向主机发出信号，以减缓流量
显式拥塞通知标记数据包，接收方返回信号给发送方
流程：
发送端主机发送数据包
→中间某个路由器开始拥塞
→拥塞路由器在IP头里打一个ECN标记
→接收端主机收到被标记的包，通过ACK/反馈信号把拥塞信息带回给发送端
→发送端减速
#### 逐跳后压
>拥塞的路由器向上一跳路由器发送抑制分组，要求其减速。这种方式能迅速缓解链路压力

某条链路出现重载时，拥塞节点对上游链路发出反压信号，上游节点减速，再把反压继续往更上游传
## 5.4 服务质量和应用QoE
>服务质量QoS是网络层在处理了基本的路由（寻找路径）和拥塞控制（防止崩溃）之后，为了满足不同应用对网络性能的特定需求而采取的高级机制
### 5.4.1 应用需求
1.常见应用对网络服务质量的要求

| 应用类型                      | 带宽需求 | 时延敏感性 | 抖动敏感性 | 丢包敏感性 |
| ------------------------- | ---- | ----- | ----- | ----- |
| 电子邮件（Email）               | 低    | 低     | 低     | 中     |
| 文件共享 / 文件传输（File sharing） | 高    | 低     | 低     | 中     |
| Web 访问（Web access）        | 中    | 中     | 低     | 中     |
| 远程登录（Remote login，如 SSH）  | 低    | 中     | 中     | 中     |
| 音频点播（Audio on demand）     | 低    | 低     | 高     | 低     |
| 视频点播（Video on demand）     | 高    | 低     | 高     | 低     |
| 电话语音（Telephony）           | 低    | 高     | 高     | 低     |
| 视频会议（Videoconferencing）   | 高    | 高     | 高     | 低     |
2.不同QoS的应用流量
①恒定比特率：发送速率基本恒定（电话语音）
②实时可变比特率：实时&码率不固定（压缩视频会议）
③非实时可变比特率：码率可变&不是实时交互（视频点播）
④可用比特率：不要求固定速率（文件传输）
### 5.4.2 过度配置
过度配置：给网络配的带宽、设备能力远大于实际可能出现的流量峰值,确保任何时候都不会发生拥塞
优点：有助于提供高质量的服务
- 确保网络有能力处理所有流量
缺点：昂贵的解决方案
#### 服务质量需要解决的网络问题：
- 满足不同应用的不同需求
- 控制进入网络的流量
- 在路由器上预留资源
- 在保证QoS的前提下尽量多接业务
### 5.4.3 数据包调度
1.路由器为不同流预留的资源：带宽；缓冲区空间；CPU周期
2.算法：
#### 先进先出调度
先到的流量先发
#### 公平队列
RR：为使用大数据包的主机提供比使用小数据包的主机更多的带宽
#### 加权公平队列
通过虚拟时间的方式，近似实现按比特公平，并且可以通过权重改变每个流的目标带宽
- 给每个包算一个虚拟完成时间，谁的完成时间早，谁先发
- 完成时间计算公式：$F_i=max(A_i,F_{i-1})+\frac{L_i}{W}$
	- $A_i:第i个包的到达时间$
	- $F_{i-1}:同一流上一个包的完成时间$
	- $L_i:第i个包的长度(字节数)$
	- $W:该流的权重$
	- $F_{i-1}:第i个包的虚拟完成时间$
#### 综合在一起
准入控制根据流的流量描述，决定是否允许该流进入网络
- 一旦允许，就配置合适的分组调度机制来满足QoS
- 如果接受该流会导致现有的服务质量下降，则拒绝该请求
流量描述：

| 参数     | 含义             | 单位        |
| ------ | -------------- | --------- |
| 令牌桶速率  | 流量允许的长期平均发送速率  | Bytes/sec |
| 令牌桶容量  | 允许的最大突发流量大小    | Bytes     |
| 峰值数据速率 | 流量允许的瞬时最大发送速率  | Bytes/sec |
| 最小分组大小 | 流中可能出现的最小数据包长度 | Bytes     |
| 最大分组大小 | 流中可能出现的最大数据包长度 | Bytes     |
保证一条流的带宽B和时延D的结构：
把流量整形成一个(R,B)令牌桶
→用加权公平队列，给这条流足够大的权重W
- $\frac{W}{all\quad weights}\gt\frac{流速R}{capacity}$
	- 原因：$该流获得的带宽=\frac{W}{all \quad weights}*C$
	- $带宽\gt R$
- 无法做到则拒绝该流
e.g.流速=1Mbps，输出链路流量=1Gbps=1000Mbps
保证1Mbps：$\frac{W}{all \quad weights}\gt \frac{1}{1000}$，即这条流的权重必须大于总权重的1/1000
时延：$total \quad delay\approx 物理传输延迟+\frac{B}{R}$
- B/R：令牌桶带来的最大排队延迟
### 5.4.4 综合服务
>核心：RSVP协议
>在发送数据前，接收方必须向发送方发起请求，沿途的每一个路由器都必须为该流预留特定的资源（带宽、缓冲区）

在传送数据之前，根据业务的QoS需求进行网络资源预留，从而为该数据流提供端到端QoS保证
通常采用面向流的资源预留协议（RSVP），在流传输路径上的每个节点为流预留并维护资源
- 主机利用RSVP向网络为应用流提出QoS的请求
- 路由器利用RSVP将QoS请求信息传给流的路径中的其他路由器，并建立和保存该服务的信息；RSVP请求将会使得沿着数据路径的资源在路由器处预留
优点：能提供端到端的绝对的QoS保证
缺点：难以实现
- 由于预留是基于每个流而进行的，因此使得节点中要保留每个流的状态信息，导致核心路由器负担太重，因此可扩展性很差
- 网络中每个节点都要维护各类数据库，并实现复杂的功能模块（如资源预留、路由、接纳控制等），造成了极大的复杂性
#### 资源预留协议工作机制
接收方向发送方发送RSVP请求
→沿途的每个路由器都检查自己是否还有足够资源（带宽、缓冲、调度能力）     
- 如果可以→临时锁定资源
- 如果不行→拒绝，整个请求失败
→路由器可以合并多个接收者的请求
→要么整条路径都成功，要么完全不建立
### 5.4.5 区分服务
网络按类别对待数据包：加急类&普通类
>在网络入口（边界路由器），客户根据购买的服务等级将数据包分类，并打上DSCP(区分服务代码点) 标签。
>PHB: 网络内部的核心路由器不关心具体是哪个流，只根据DSCP标签决定转发优先级（如使用WFQ调度）
#### 实现
1.用户在数据包上标记想要的服务等级
- 在网络的入口处为每个数据包分类，并在数据包中标记相应的区分服务代码点（DSCP，DiffServ CodePoint）， 用于指示数据包在网络转发路径的中间节点上被处理的方式
- 网络内部的核心路由器只保存简单的DSCP与PHB（PerHop Behavior, 每跳行为）的对应机制，根据数据包头部中的DSCP值对数据包进行相应的优先级转发
- 业务流状态信息的保存与流量控制机制的实现等都在网络边界节点进行，内部节点与状态无关
2.SP进行流量整形和流量监管
3.路由器用WFQ给不同等级不同带宽和时延
#### 特点
优点：实现简单，扩展性好。目前在IP网中区分服务得到了绝大部分厂家的支持，其具体实现技术包括分类、重标记、速率限制、流量监管、拥塞避免、队列调度等。
缺点：
- 只承诺相对的服务质量，因而不能对用户提供绝对的服务质量保证
- 在拥塞发生时，只能采取丢弃报文的方式，而不能采用例如旁路的方式使部分流量通过其他路径到达终点
- 对相同优先级的业务而言，设备在拥塞时对报文的丢弃是非智能化的， 也就是说，设备只能随机地丢弃报文，其结果是所有业务的服务质量都受到影响。而此时希望的结果是只丢弃少部分业务流的报文，从而避免剩下的大多数的业务流的服务质量受到影响
## 5.5 网络互联
### 5.5.1 网络互连概述

### 5.5.2 网络如何不同

| 项目    | 可能的情况                |
| ----- | -------------------- |
| 提供的服务 | 无连接/面向连接             |
| 寻址方式  | 地址长度不同；扁平结构/层次结构     |
| 广播能力  | 支持/不支持/支持多播          |
| 分组大小  | 每种网络都有各自的最大分组长度      |
| 顺序保证  | 保证有序传输/不保证顺序         |
| 服务质量  | 支持/不支持，可能有多种不同类型     |
| 可靠性   | 不同程度的丢包率             |
| 安全性   | 隐私规则、加密机制等           |
| 参数设置  | 不同的超时设置、流量描述参数等      |
| 计费方式  | 按连接时间/分组数/字节数计费，或不计费 |
### 5.5.3 异构网络互联[[ch05.pdf#page=83&selection=8,0,8,33|ch05, p.83]]
基于公共网络层IP的互联
### 5.5.4 跨异构网络连接端点
隧道：通过一个中间网络连接两个网络，数据包在中间网络中被封装
### 5.5.5 互联网络路由
### 5.5.6 支持不同的数据包长度：数据包分段
原因：不同网络支持的最大数据包大小不同
1.数据包分段[[ch05.pdf#page=86&selection=8,0,10,22|ch05, p.86]]
透明分片：在每个网络出口重组
非透明分片：在最终出口重组
2.基本数据大小=1Bytes时的段[[ch05.pdf#page=87&selection=8,0,10,22|ch05, p.87]]
头：
- 分组标识：所有属于同一个原始分组的碎片的标识号相同
- 分片偏移：本分片的数据在原始数据中的起始位置（从0开始）
- 数据包结束标志位
	- 1：这是最后一个分片
	- 0：后面还有分片
①原始数据包，包含10Bytes的数据
②经过一个最大数据包长度为8的网络后加上头的段
③经过一个最大数据包长度为5的网关后的段
3.路径MTU发现[[ch05.pdf#page=88&selection=8,0,10,22|ch05, p.88]]-避免分片
源主机先发送一个较大的包，中途路由器如果发现包>自己链路的MTU，则不分片，直接丢弃，返回一个错误消息给源主机，源主机缩小包大小再试，直到找到一条整条路径都能通过的最大MTU
## 5.6
跳过
## 5.7 Internet的网络层
网络设计的十大原则：[[ch05.pdf#page=95&selection=12,0,12,17|ch05, p.95]]
Internet是许多网络互联的集合[[ch05.pdf#page=97&selection=8,0,8,42|ch05, p.97]]
IP和其他网络层协议在TCP/IP协议组中的位置[[ch05.pdf#page=98&selection=8,0,10,35|ch05, p.98]]
### 5.7.1 <span style="background:rgba(240, 200, 0, 0.2)">IPv4协议</span>
#### 1.IPv4头的格式[[ch05.pdf#page=99&selection=10,0,10,46|ch05, p.99]]：
- 第1行
	- 版本4bits：该数据报属于IP的哪个版本（4/6）
	- IHL4bits：指明头的长度（单位：32bits=4bytes），以4Bytes为单位，IHL∈[5,15]，头的长度∈[15,60]
	- 区分服务8bits：区分服务类别
	- 总长度16bits：包含了数据报的头+数据，最大长度=65535Bytes
- <span style="background:rgba(240, 200, 0, 0.2)">第2行</span>
	- 标识16bits：让目标主机确定一个新到达的段属于哪个数据包
	- 分段机制
		- DF1bit：不分段
			- =1：不能分段
			- =0：可以分段
		- MF1bit：更多的段
			- =1：后续还有段
			- =0：后续没有段
		- 段偏移量13bits：该段在当前数据包中的位置
- 第3行
	- 生存期8bits：限制数据包生存期的计数器，在每一跳上递减，递减到0时数据包被丢弃
	- 协议8bits：上层协议类型
	- <span style="background:rgba(240, 200, 0, 0.2)">头校验和</span>16bits：<font color="#c00000">只校验头部</font>（由于头部携带了地址等关键信息，因此使用自己的校验和加以保护）
		- 校验和计算：[[ch05.pdf#page=105&selection=8,0,10,27|ch05, p.105]]
		- 只校验头部：IPv4数据报中所有的高层协议均有校验和字段来对整个分组进行校验；<font color="#c00000">IPv4头部在经过路由器是会发生改变</font>，而数据字段不变，即<font color="#c00000">校验和仅需要对变化的部分进行校验</font>。如果对整个分组进行校验，则会增加处理时间。
- 第4行：源地址32bits，源网络接口的IP地址
- 第5行：目的地址32bits，目标网络接口的IP地址
- 第6行：选项
	- 安全性：标明数据包的保密程度
	- 严格源路由：给出要遵循的完整路径
	- 松散源路由：给出不能错过的路由器的列表
	- 记录路由：要求每台路由器附加上自己的IP地址
	- 时间戳：要求每台路由器附加上自己的IP地址和时间戳
2.使用协议字段的值进行多路复用和解路复用[[ch05.pdf#page=101&selection=8,0,10,27|ch05, p.101]]

|协议|Protocol 值|
|---|---|
|ICMP|1|
|IGMP|2|
|TCP|6|
|UDP|17|
|OSPF|89|
①发送端-多路复用
传输层→网络层：传输层可能同时有TCP、UDP、ICMP、OSPF、IGMP等协议，它们的数据都要交给IP层发送。IP层把不同上层协议的数据统一封装成IP数据报，在IP Header的Protocol字段中写明数据来自谁
②接收端-分用
当一个IP数据报到达接收主机时，IP 层解析IP Header，读取Protocol 字段，根据取值把Payload交给对应上层协议模块
**练习1**[[ch05.pdf#page=102&selection=8,0,8,7|ch05, p.102]]
到达IPv4报文，报文的前8位如下所示：01000010，丢弃该报文。为什么
0100：IPv4
0010：IHL=2，但IHL最小值为5
**练习2**[[ch05.pdf#page=103&selection=8,0,8,7|ch05, p.103]]
HLEN/IHL
IHL=8→首部总长度=8×4bytes=32bytes
基本首部：20bytes
options：12bytes
**练习3**[[ch05.pdf#page=104&selection=8,0,8,7|ch05, p.104]]
`45 00 00 28 00 01 00 00 01 02`
IPv4首部前12个bytes：

|字节序号|字段|
|---|---|
|1|Version + IHL|
|2|TOS|
|3–4|Total Length|
|5–6|Identification|
|7–8|Flags + Fragment Offset|
|**9**|**TTL**|
|**10**|**Protocol**|
|11–12|Header Checksum|
⑨01-还剩1跳
⑩02-IGMP
3.checksum
IPv4首部所有字段=20bytes拆成10个16-bit十六进制数，然后相加-回卷-取反
4.最大传输单元MTU
<font color="#c00000"><span style="background:rgba(240, 107, 5, 0.2)">MTU=IP报文最大长度=IP header（通常20字节）+IP payload</span></font>
- 如果IP数据报≤MTU→可以直接封装
- 如果>MTU→分片
每个分片的结构：
<span style="background:rgba(240, 107, 5, 0.2)">IP Header+一部分的 IP Payload（可能含 TCP header 的某一部分）</span>
5.IP碎片化和重组[[ch05.pdf#page=108&selection=8,0,8,31|ch05, p.108]]
8的整数倍
e.g.数据报=4000bytes，MTU=1500bytes
IP总长度≤MTU→数据部分≤1500−20=1480bytes
原始数据：4000−20=3980 bytes
<font color="#c00000">【一些解释】</font>
<font color="#c00000">1.TCP header是IP payload的一部分</font>
<font color="#c00000">2.total length（数据报长度）</font>
<font color="#c00000">=IP header+IP payload</font>
<font color="#c00000">=IP header+TCP header+TCP data</font>
<font color="#c00000">3.MTU</font>
<font color="#c00000">=frame header+最大可以传输的IP报文</font>
<font color="#c00000">=frame header+IP header+IP payload</font>
<font color="#c00000">所以要将【IP header+IP payload】的值与【MTU-frame header】的值对比</font>
<font color="#c00000">4.关于【8】</font>
<font color="#c00000">①计算每个分片的payload：需要将【MTU-frame header-IP header】的值向下取整为8的倍数</font>
<font color="#c00000">②计算分片数量：用IP payload【=total length-IP header（20bytes）】去除这个8的倍数值</font>
<font color="#c00000">③计算段偏移量：用当前位置【=当前片之前的所有片的payload之和】除以8</font>
<font color="#c00000">5.每个分片的length=IP header+每个分片的payload</font>
#### 第1片：1480
`length = 1500 ID = x fragflag = 1 offset = 0`
- length=20+1480=1500
- MF（More Fragments）=1（后续还有分片）
- offset=0（从原始数据的第0字节开始）
#### 第2片：1480
`length = 1500 ID = x fragflag = 1 offset = 185`
Fragment Offset的单位是8bytes
前一片数据大小=1480bytes
offset=1480/8=185，表示本片数据从原始数据的第1480字节处开始
#### 第3片：1020
`length = 1040 ID = x fragflag = 0 offset = 370`
- 剩余数据=1020bytes，length=20+1020=1040
- MF=0（最后一片）
- offset=(1480×2)/8=2960/8=370
e.g.数据包分组[[ch05.pdf#page=109&selection=24,0,24,29|ch05, p.109]]
**练习**[[ch05.pdf#page=110&selection=8,0,8,7|ch05, p.110]]
MTU=576bytes，IP header=20bytes，IP data=1484bytes
<font color="#c00000">【MTU包含header】</font>
数据部分≤576-20=556bytes
<font color="#c00000">由于offset以8bytes为单位，所以最大数据长度是8的倍数=552bytes</font>
3个分片：

|     | 总长度  | id  | MF  | offset |
| --- | ---- | --- | --- | ------ |
| 原包  | 1504 | x   | 0   | 0      |
| 分片1 | 572  | x   | 1   | 69     |
| 分片2 | 572  | x   | 1   | 69     |
| 分片3 | 400  | x   | 0   | 138    |
分片1：
data-552
总长度=552+20=572
MF=1
offset=0

分片2
data-552
总长度=552+20=572
MF=1
offset=552/8=69

分片3
data-380
总长度=380+20=400
MF=0
offset=（552+552）/8=138
e.g.[[ch05.pdf#page=110&selection=8,0,8,7|ch05, p.110]]
报文到达，偏移值为100，HLEN值为5，总长度字段值为100。第一个字节和最后一个字节的数字是多少
在源数据的第100×8=800bytes-第一个字节号=800
IHL=5-header=20bytes
总长度=100bytes
数据=80bytes
最后一个字节号=800+80-1=879
### 5.7.2 <span style="background:rgba(240, 200, 0, 0.2)">IP地址</span>
1.IPv4地址：32位，地址空间=$2^{32}$
2.IP地址格式：点分十进制表示法[[ch05.pdf#page=113&selection=8,0,10,28|ch05, p.113]]
范围：0-255
不能以0开头
最多4Bytes
e.g.`10000000 00001011 00000011 00011111`
`10000000-128`
`00001011-11`
`00000011-3`
`00011111-31`
→`128.11.3.31`
e.g.[[ch05.pdf#page=114&selection=8,0,8,7|ch05, p.114]]
a.没有前导0
b.最多4bytes
c.范围0-255
d.二进制和点分十进制不能混用
#### 前缀
一个网络对应于IP地址（网络部分+主机部分）空间的一个连续块，由网络部分决定，共有$2^{32-L}$个
<font color="#c00000">【地址块的起点只能是地址个数的倍数】</font>
1.写法-CIDR表示法：`IP地址 / 前缀长度`
e.g.`18.0.31.0/24`
- 前缀长度=24（固定前24位，后8位可变）
- 网络部分=`18.0.31`
- 主机部分=最后8位
- 地址范围：`18.0.31.0~18.0.31.255`
- 总地址数：`2^8=256`
不可以是`18.0.31.7/24`
<font color="#c00000">分配给主机的种类</font>：$2^{32-L}-2$（全0为子网本身，全1为广播地址）
2.一个前缀和一个子网掩码：前缀长度=掩码中连续1的个数
e.g.`11111111 11111111 11111111 00000000`
3.从CIDR前缀读取信息[[ch05.pdf#page=116&selection=8,0,10,10|ch05, p.116]]
任意一个32位IPv4地址
- nbits（前缀）：固定不变→决定是哪一块  
- （32−n）bits（后缀）：可以变化→决定块里有多少个地址
$地址数N=2^{32−n}$
第1个地址后缀全0；最后一个地址后缀全1
e.g.`205.16.37.32/28`的网络配置[[ch05.pdf#page=117&selection=8,0,10,15|ch05, p.117]]
前28位固定，后4位可变
地址数量$N=2^4=16$
起始地址`.32`：32是地址数量16的倍数
起始地址`205.16.37.32`
结束地址`32+16−1=47`
`205.16.37.32 205.16.37.33…205.16.37.47`
4.IP+前缀长度唯一确定地址块
e.g.`230.8.24.56`
/16:后缀16位，地址数量65536`Block: 230.8.0.0  ~  230.8.255.255`
/20:后缀12位，地址数量4096`Block: 230.8.16.0  ~  230.8.31.255`
/26:后缀6位，地址数量64`Block: 230.8.24.0  ~  230.8.24.63`
/27:后缀5位，地址数量32`Block: 230.8.24.32  ~  230.8.24.63`
/29:后缀3位，地址数量8`Block: 230.8.24.56  ~  230.8.24.63`
/31:后缀1位，地址数量2`Block: 230.8.24.56  ~  230.8.24.57`
#### 子网
1.子网划分：将一个IP前缀切分为单独的网络
$K=2^{10}=1024$
e.g.
128.208.0.0
128.208.1.0
128.208.2.0
...
128.208.63.255
128.208.64.0
128.208.65.0
...
128.208.127.255
128.208.128.0
...
128.208.255.255
![[Pasted image 20251209114539.png]]
- 整个地址：`128.208.0.0/16`
	- 后缀：16位，64K个地址
	- 对外只公布`128.208.0.0/16`
`128.208`不动：
- EE：`128.208.0.0/18`
	- 固定第17、18位为`00`
	- 后缀：14位，16K个地址
	- `00000000 00000000-00111111 11111111`
	- `128.208.0.0-128.208.63.255`
- CS：`128.208.128.0/17`
	- 固定第17位为1
	- 后缀：15位，32K地址
	- `10000000 00000000-11111111 11111111`
	- `128.208.128.0-128.208.255.255`
- ART：`128.208.96.0/19`
	- 固定第17、18、19位为`011`
	- 后缀：13位，8K个地址=8192，每8192个地址是一块，每个第3个字节=256个地址，8192/256=32，所以/19的块的第3个字节必须是32的倍数【哪个字节包含了关键的边界位，就看哪个字节，比如第19位落在第3个字节】
	- `01100000 00000000-01111111 11111111`
	- `128.208.96.0-128.208.127.255`
二进制：
Computer Science:  10000000 11010000 1xxxxxxxx xxxxxxxx
Electrical Eng:     10000000 11010000 00xxxxxxx xxxxxxxx
Art:               10000000 11010000 011xxxxx xxxxxxxx
``` markdown
128.208.0.0/16  (65,536)
├── CS   128.208.128.0/17  (32,768)
└── 128.208.0.0/17  (32,768)
    ├── EE   128.208.0.0/18   (16,384)
    ├── 剩余 128.208.64.0/19  (8,192)
    └── Art  128.208.96.0/19  (8,192)
```
还剩$2^{13}$个地址：`128.208.64.0-128.208.127.255`
子网大小必须是 2 的幂，而且起点必须对齐在对应的边界上
2.子网中的配置和地址
- 对外使用路由聚合：`Network: 17.12.14.0/26`
	- 地址数量：$2^{32-26}=64$
- 子网1：`17.12.14.0/27`，地址数量：$2^{32-27}=32$，`17.12.14.0  ~  17.12.14.31`
- 子网2：`17.12.14.32/28`，地址数量：$2^{32-28}=16$，`17.12.14.32  ~  17.12.14.47`
- 子网3：`17.12.14.48/28`，地址数量：$2^{32-28}=16$，`17.12.14.48  ~  17.12.14.63`
3.主机地址=子网地址+5bits=网络地址+1bit+5bits
e.g.
①网络前缀=26bits，子网前缀=1bit（子网0/子网1），主机地址=5bits（32个地址，30个主机）-/27
②网络前缀=26bits，子网前缀=2bit（子网0/子网1/子网2/子网3），主机地址=4bits（16个地址，14个主机）-/28
#### CIDR——无类域间路由[[ch05.pdf#page=122&selection=8,0,10,8|ch05, p.122]]
1.$地址块大小 = 2^{32−前缀长度}$
$前缀长度 = 32 − log_2(地址块大小)$
`194.24.0.0/21`
$2048=2^{11}$
$32-11=21$-`/21`
21落在第3个字节，每字节256位，2048/256=8，所以第三个字节占0～7，`194.24.0.0 —— 194.24.7.255`
`194.24.8.0/22`
$1024=2^{10}$
$32-10=22$-`/22`
1024=4×256  
22落在第3个字节，每字节256位，1024/256=8，所以第三个字节占8～11，
`194.24.8.0 —— 194.24.11.255`
`194.24.12.0/22`
$1024=2^{10}$
$32-10=22$-`/22`
1024=4×256  
22落在第3个字节，每字节256位，1024/256=8，所以第三个字节占12～15，
`194.24.12.0 —— 194.24.15.255`
`194.24.16.0/20`
$4096=2^{12}$
$32-12=20$-`/20`
20落在第3个字节，每字节256位，4096/256=16，所以第三个字节占16～31，`194.24.16.0 —— 194.24.31.255`
**练习**[[ch05.pdf#page=123&selection=36,0,36,7|ch05, p.123]]
一个 **ISP（互联网服务提供商）** 获得了一个以 **190.100.0.0/16** 开头的地址块（总计 65,536 个地址）。该 ISP 需要将这些地址分配给三组客户，具体要求如下：
- **a.** 第一组有 **64** 个客户，每个客户需要 **256** 个地址。
- **b.** 第二组有 **128** 个客户，每个客户需要 **128** 个地址。
- **c.** 第三组有 **128** 个客户，每个客户需要 **64** 个地址。
任务： 请设计这些子块（Subblocks），并计算在完成这些分配之后，还有多少个地址可用。
总共：前缀=16，后缀=32-16=16，共$2^{16}$个地址
##### a
$256=2*8$，后缀=8，前缀=32-8=24
24落在第3字节，256/256=1，故第一个客户`190.100.0.0/24-190.100.0.255/24`
总共$64*256=2^{14}$，后缀=14，前缀=32-14=18，18落在第3字节，64×256/256=64，故`190.100.0.0/24-190.100.63.255/24`
最后一个客户`190.100.63.0/24-190.100.63.255/24`
##### b
$128=2^7$，后缀=7，前缀=32-7=25
25落在第4字节，128/256=1/2，故第一个客户`190.100.64.0/25-190.100.64.127/25`
总共$128*128=2^{14}$，后缀=14，前缀=32-14=18，18落在第3字节，128×128/256=64，故`190.100.64.0/25-190.100.127.255`
最后一个客户`190.100.127.128/25-190.100.127.255/25`
##### c
$64=2^6$，后缀=6，前缀=32-6-26
26落在第4字节，64/256=1/4，故第1个客户`190.100.128.0/26-190.100.128.63/26`
总共$128*64=2^{13}$，后缀=13，前缀=32-13=19，19落在第3字节，128×64/256=32，故`190.100.128.0/26-190.100.159.255/26`
最后一个客户`190.100.159.192/26-190.100.159.255/26`

还剩$2^{16}-2^{14}-2^{14}-2^{13}=3*2^{13}$个地址

e.g.[[ch05.pdf#page=127&selection=8,0,10,22|ch05, p.127]]
- /16
	- /18
		- /24
	- /18
		- /25
	- /19
		- /26
2.最长匹配前缀路由[[ch05.pdf#page=130&selection=12,0,12,54|ch05, p.130]]
匹配成功的路由里，前缀最长（/x 最大）的那一条，优先级最高
3.超网：把多个连续、对齐的小网络合并成一个更大的前缀，对外只公布这一条
- Internet part（Network ID）：对外路由用
- Local part（Host ID）：本地细分
e.g.4个class C网络
- 192.230.20.0/24
- 192.230.21.0/24
- 192.230.22.0/24
- 192.230.23.0/24
``` markdown
20 → 00010100
21 → 00010101
22 → 00010110
23 → 00010111
```
只有后2位变-主机位
24-2=22位前缀-`192.230.20.0/22`
4.无分类域间路由[[ch05.pdf#page=130&selection=8,0,10,8|ch05, p.130]]
在CIDR中，路由器对每个数据包执行最长前缀匹配：若多个前缀匹配目的地址，则选择前缀长度最长（地址块最小）的那一条进行转发。
5.简化无类地址转发模块[[ch05.pdf#page=131&selection=8,0,10,7|ch05, p.131]]
目的地址→前缀匹配→最长前缀→出接口
**练习**[[ch05.pdf#page=132&selection=16,0,16,10|ch05, p.132]]
按照图中所示的配置，为路由器R1创建转发表。显示目的地址为180.70.655.140.的报文到达R1时的转发过程。
<span style="background:rgba(3, 135, 102, 0.2)">m0</span>：前缀=25，后缀=7，$2^7=128$个地址
25落在第4个字节，128/256，`180.70.65.128/25-180.70.65.255`
m1：前缀=22，后缀=10，$2^{10}$个地址
22落在第3个字节，$2^{10}$/$2^8$=4，`201.4.16.0/22-201.4.19.255/22`
m2：前缀=26，后缀=6，$2^{6}=64$个地址
26落在第4个字节，64/256=1/4，`180.70.65.192/26-180.70.57.263/26`
m3：前缀=24，后缀=8，$2^{8}=256$个地址
24落在第3个字节，256/256=1，`201.4.22.0/24-201.4.22.255/24`

【对齐】
![[Pasted image 20251223170431.png]]
#### 分类和特殊寻址
1.分类寻址
IP地址[[ch05.pdf#page=134&selection=20,0,20,19|ch05, p.134]]
- A：0
- B：10
- C：110
- D：1110
- E：1111
2.特殊IP地址[[ch05.pdf#page=135&selection=8,0,8,20|ch05, p.135]]
- 全0：本机
- 主机号非0，其它全0：本网络中的某个主机
- 全1：本地广播
- `Network | 1111...1111`：向某个指定网络的所有主机广播
- `127.(Anything)`：回环地址-这台主机自己
3.五类地址[[ch05.pdf#page=137&selection=8,0,8,59|ch05, p.137]]
e.g.[[ch05.pdf#page=136&selection=8,0,8,7|ch05, p.136]]
a.A
b.C
c.00001110-A
d.11111100-E
<font color="#c00000">【填充8位】</font>
4.子网地址
①子网号：从Host ID里借几位当作Subnet ID
$子网数量 = 2^{借用的主机位数}$
②子网掩码：连续的1表示网络+子网，连续的0表示主机
e.g.`11111111 11111111 11111100 00000000`
前22位-网络+子网，后10位-主机
e.g.给定Class B`150.100.0.0`
默认网络位=主机位=16，
默认掩码`/16=255.255.0.0`
每个子网最多100个主机，设计子网掩码并判断某IP属于哪个子网地址
主机位：$2^7-2=128-2=126\gt 100$→主机位=7
子网位=16-7=9
结构：`Network (16) | Subnet (9) | Host (7)`
前缀=25→子网掩码：`/25`-`11111111 11111111 11111111 10000000`
找到`150.100.12.176`的子网：`10010110 01100100 00001100 10110000`
相与→`10010110 01100100 00001100 10000000`-`150.100.12.128`
#### NAT-网络地址转换
1.核心思想：将一个外部IP地址映射到多个内部IP地址
①发出：修改IP和端口
②回传：映射表
2.内网地址（不出现在公共Internet上）[[ch05.pdf#page=141&selection=14,0,14,30|ch05, p.141]]
3.操作过程[[ch05.pdf#page=145&selection=8,0,8,23|ch05, p.145]]
建立映射表项（发出）→改源地址（发出）→查表（回传）→改目的地址（回传）
4.缺点：违背分层原则
### 5.7.3 IPv6协议
1.地址空间[[ch05.pdf#page=150&selection=22,0,22,13|ch05, p.150]]：$2^{128}$
①全局单播地址[[ch05.pdf#page=151&selection=8,0,8,22|ch05, p.151]]
`128bits=全局路由前缀+子网标识+接口表示`
②特殊地址[[ch05.pdf#page=152&selection=8,0,8,17|ch05, p.152]]
（1）未指定地址`0000::/128`：全0
（2）回环地址`0000::/128`：只有最后一位=1
（3）直接表示IPv4地址`0000::/96`：前96bits=0+32位IPv4地址
（4）用IPv6格式表示IPv4地址`0000::FFFF/96`：前80bits=0，16bits=1+32位IPv4地址
2.地址格式：IPv6冒分十六进制标志法[[ch05.pdf#page=153&selection=74,0,74,20|ch05, p.153]]
`X:X:X:X:X:X:X:X`，`X`表示地址中的16bits（16进制）`0000`-`FFFF`
①1组内的前导0可省略
0db8  →  db8
02de  →  2de
0370  →  370
`2001:0db8:85a3:0000:1319:8a2e:0370:7344
=`2001:db8:85a3:0:1319:8a2e:370:7344`
②连续的全0分组可用`::`压缩
`2001:0DB8:0000:0000:0000:0000:1428:57ab`
=`2001:DB8::1428:57ab`
③`::`只能出现1次
`2001::25de::cade❌`
④前导0省略+`::`可以同时使用
**练习**[[ch05.pdf#page=154&selection=51,0,51,8|ch05, p.154]]
A：应8个字节
C：不能用.
D：`::`只能用1次
#### 主要的IPv6头[[ch05.pdf#page=155&selection=8,0,8,20|ch05, p.155]]
1.共32位，头固定长度40字节
- 第1行
	- 版本4bits
	- 区分服务8bits
	- 流标签20bits
- 第2行
	- 有效载荷长度16bits
	- 下一个头8bits：指向扩展头[[ch05.pdf#page=156&selection=8,0,8,27|ch05, p.156]]
	- 跳数限制8bits
- 第3行：源地址（16字节）
- 第4行：目标地址（16字节）
2.扩展头
①IPv6扩展头：[[ch05.pdf#page=157&selection=8,0,8,26|ch05, p.157]]
②用于大型数据报（巨型报）的逐跳扩展头[[ch05.pdf#page=158&selection=8,0,8,26|ch05, p.158]]
③路由扩展头[[ch05.pdf#page=159&selection=8,0,8,26|ch05, p.159]]
3.IPv4→IPv6
①双栈：同时运行IPv4和IPv6
②管道：把IPv6数据包封装在IPv4数据包里，让它能穿过只支持IPv4的网络
③头部转换：在网络边界把IPv6报文翻译成IPv4报文
#### 争论
跳过
### 5.7.4 Internet控制协议
#### ICMP-Internet控制消息协议
ICMP协议被封装在IP数据包中
1.功能：处理错误和控制消息
①主机不可达：如果路由器无法投递或转发数据包，会给源主机发送一个ICMP“主机不可达”信息
②重定向：如果路由器接收到一个本应发送到另一个路由器的数据包，它会向发送者发送一个ICMP重定向消息；发送方修改其路由表
③路由器发现：ICMP路由器发现消息允许主机了解其网络中的路由器，并初始化和更新其路由表
④`ping`：ICMP echo request和echo reply便于诊断，在ping中使用
2.ICMP消息通用格式[[ch05.pdf#page=167&selection=8,0,8,31|ch05, p.167]]
①差错报告报文
②查询报文
3.消息类型[[ch05.pdf#page=168&selection=12,0,12,18|ch05, p.168]]
#### ARP-地址解析协议
1.功能[[ch05.pdf#page=171&selection=8,0,8,35|ch05, p.171]]：在同一个局域网内，允许节点用IP地址找到对应的以太网MAC地址
2.在TCP/IP协议体系中的位置
把网络层的IP地址映射成链路层的MAC地址
3.ARP包
- 操作码=1→ ARP Request（请求）  
- 操作码=2→ ARP Reply（应答）
4.工作流程
①请求-广播
②响应-单播

| 项目        | ARP Request   | ARP Reply   |
| --------- | ------------- | ----------- |
| Operation | `0x0001`      | `0x0002`    |
| 发送方式      | 广播            | 单播          |
| 目标 MAC 字段 | 全 0           | 已填写         |
| 谁发        | 不知道目标 MAC 的主机 | 拥有目标 IP 的主机 |
| 目的        | “你是谁？”        | “我就是”       |
5.代理ARP：路由器用自己的MAC地址回答本来不属于自己的IP的ARP请求
6.缓存表：大小有限；ARP映射仅在限定时间内保留
7.反向地址解析协议RARP：发送-广播，响应-单播，用于无盘工作站
ARP：IP→MAC
RARP：MAC→IP
#### DHCP-动态主机配置协议
1.DHCP是一个<font color="#c00000">应用层</font>程序，使用客户端-服务器模式，实际帮助网络层的TCP/IP
结构：
opcode：1发送2响应
flags：0单播1多播
options
2.工作过程
①DHCP DISCOVER（发现）
客户端广播
②DHCP OFFER（提供）
DHCP服务器提供IP
③DHCP REQUEST（请求）
客户端选中IP
④DHCP ACK（确认）
DHCP服务器确认
### 5.7.5 标签交换和多协议标签交换MPLS
1.MPLS：在每个分组前加一个标签
2.MPLS在转发数据之前，已经为数据流建立好一条标签交换路径；可将ISP用于QoS
MPLS=Label8bits+QoS3bits+S1bit+TtL8bits
3.工作流程：
- 分组进入MPLS网络时，根据IP地址加标签
- MPLS 网络内部转发只依赖标签
- 分组离开MPLS网络时，标签被移除
### 5.7.6 OSPF——域内路由协议
1.自治系统内部负责路由的协议：
域内路由：IGP
- RIP-适合小网络
- OSPF-广泛用于企业网
	- 计算最短路径[[ch05.pdf#page=188&selection=8,0,10,17|ch05, p.188]]
	- OSPF把一个自治系统划分为多个Area，所有Area都必须通过Area0（骨干区）互联，从而减少规模、降低开销、支持路由汇总。
	- OSPF先用一套消息机制，让所有路由器拿到一致的网络拓扑图，然后每台路由器自己跑Dijkstra算法算最短路。
	- 消息类型
		- Hello：发现邻居
		- Database description：宣布发送者拥有的更新
		- Link state request：请求缺失的那部分
		- Link state update：向邻居提供发送方的开销
		- Link state ack：确认收到
- IS-IS-广泛用于ISP网络
### 5.7.7 BGP——域间路由协议
在相互连接的自治网络中计算路由
1.首要目标：满足网络策略
2.可能的路由限制的例子[[ch05.pdf#page=191&selection=24,0,24,28|ch05, p.191]]
3.域间工程流量：通过调整网络协议的参数和配置，控制流量怎么走，以避免拥塞、提高链路利用率、降低成本。
①入站工程流量
- 通过选择路由来控制流量如何进入网络
- 为单个路由设置本地优先级属性
- 使用AS路径前置
- 利用最长前缀匹配：将一个前缀拆分为多个较小（较长的）前缀，使上游路由器优先选择前缀较长的路由
②出站工程流量

### 5.7.8 Internet多播
跳过

