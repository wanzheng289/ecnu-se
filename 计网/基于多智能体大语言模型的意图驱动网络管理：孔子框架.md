## abstract
用于开发和部署大语言模型辅助网络管理应用程序的开创性综合框架
## 1 Introduction
3个关键组件-将特定领域的知识有效地纳入通用多智能体大语言模型框架
### ①通过结构化网络程序增强规划
集成有助于大语言模型将复杂的网络管理任务分解为多个较小的任务。
### ②将工具与特定领域的语言连接起来
利用现有的众多网络管理工具（需要格式化正确的输入和命令）
方法：提出了一组原语，将人类友好的指令转换为每个工具的DSL兼容输入
Confucius具有提供到拓扑图、网络时间序列数据和网络数据模型的转换的内置模块，使Confucius代理和许多现有网络管理工具之间能够无缝交互
### ③用特定领域的检索增强长期和短期记忆
短期记忆-分层树结构
长期记忆-检索增强生成（RAG），允许开发人员配置存储在内存中的详细级别，并基于特定的查询提取相关信息
### ④系统地确保正确性
与现有的验证和确认系统紧密集成
提供了一套促进人类频繁反馈的原语
基准测试系统：使开发人员能够在不同的配置、提示算法和基础模型下评估应用程序

优点：为开发人员节省了大量时间&高准确性
## 2 Motivation
### 1.网络管理用例
【table1】Confucius支持的网络管理应用程序的类别，以及示例查询
网络管理生命周期的四类用例
- 网络设计：涉及生成满足容量和性能要求的拓扑设计
	- 大语言模型可以帮助自动将抽象设计转换为具体数据模型
	- 减少时间&错误
- 网络操作：涉及按照已建立的MOP执行配置更新、软件安装和硬件更换等任务
	- 大语言模型可以通过建议现有的MOP、生成新的MOP、执行复杂指令、监控操作状态以及降低内部工具的门槛来改进这些流程
	- 高效
- 网络监控：涉及从各种供应商的API收集数据
	- 大语言模型通过建议和编写API以及自动解析检索到的数据提供了一个有前途的解决方案
	- 高效&通过自我学习开发新的故障排除流程
- 知识库和入职：涉及网络领域特定的术语和工具
	- 大模型管理API
### 2.容量假设分析
Meta的容量规划
- 涉及确定何时何地增加网络容量，以确保长期的网络健康
- 该过程依赖于假设分析和优化
- 关键挑战：确定主干拓扑应该如何改变，以将这些具有适当容量的新区域互连起来
解决-Confucius的子任务
#### ①规划子任务
step1-用户收集当前网络拓扑和有关即将到来的光纤可用性的信息
step2-用户提出假设问题
step3-用户创建执行计划：更新流量预测→增加即将部署光纤的拓扑→运行故障模拟→分析结果以支持A/B测试。
#### ②子任务的复杂性【figure1】
每个子任务可以有多个变体→多个工具&多个输出
##### （1）Confucius通过自动生成操作的有向无环图（DAG）并根据规划者定义的假设场景编排远程执行来简化手动配置和链接这些工具的流程
用户通过自然语言界面与容量相关信息进行交互，而无需理解表模式或查询语法。
##### （2）Confucius根据关键指标总结结果，提供了差异的可视化分析，帮助用户快速解释和比较结果。
### 3.网络性能诊断【figure2】
问题：网络工程师必须筛选大量监控数据并考虑众多潜在原因
解决：Confucius通过分析数千个计数器和指标来协助故障诊断
流程：分析网络问题、主要区域、路由路径、受影响的前缀，并确定是否有任何网络更改与这些因素相关联
#### ①规划子任务
诊断网络问题第1步-规划复杂诊断任务的执行
问题：在生产中使用由子工作流或步骤（会调用不同工具）组成的工作流或运行手册，很难确定将哪个工作流用于特定诊断问题
解决：按区域和前缀识别主机→检查TCP重传的异常→分析NetNORAD数据的分组丢失→检查链接到受影响的LSP路径的网络更改日志
#### ②子任务的复杂性
问题：需要大量的数据集和领域知识；网络工程师必须手动创建和管理数十个步骤的工作流
解决：Confucius通过自动生成模板、建议可重用的构建块、执行查询和识别相关性来自动化这一过程，通过减少分诊和根本原因分析所需的工时来提高诊断效率
### 4.观察和挑战
关键观察结果：
#### ①多步骤复杂任务
网络管理任务很复杂，涉及多个需要特定领域知识的步骤
#### ②专用工具
开发了许多专门的工具来解决网络管理的特定方面，包括网络建模、基于意图的路由、容量规划、拓扑设计、监控和诊断
在Meta，我们拥有数百种跨越主干、数据中心和边缘网络的工具和API
#### ③搜索空间大
现代网络的规模和异构性导致网络管理任务的搜索空间很大
#### ④安全要求高
网络管理对可靠性的要求极高，单纯依靠AI是不切实际的
#### ⑤隐私问题
网络数据具有很强的专有性，必须对敏感信息进行保护，防止恶意攻击。在将输入数据发送到大语言模型之前，仔细编辑输入数据至关重要。
## 3 Overview
### 1.原则
#### ①将推理与事实知识分开
利用大语言模型完成推理
依靠现有的操作手册、工具和数据库来检索事实信息
#### ②利用现有的专业知识：
在网络管理中利用已建立的工具和专家知识
#### ③使用精心设计的提示进行编排：
将管理任务分解为单个组件，并使用精心设计的提示来指导大语言模型推理→保持对推理过程的控制
#### ④优先考虑迭代改进
优先考虑基本实现
#### ⑤不依赖微调
有效地与不需要微调作为先决条件的基础模型一起工作
### 2.关键设计思想
【figure3-大语言模型代理与四个部分的交互：计划、记忆、工具和人类，构建网络特定的原语来促进它们之间的交互】
#### ①多智能体框架
问题：复杂的任务→多个相互关联的、需要不同的专门工具和领域知识的子任务
解决：Confucius通过采用多智能体框架将复杂的工作流分解为不同的子任务，这些子任务可以由多个专业智能体来处理。
#### ②利用现有MOP和工作流进行规划
让大语言模型从这些工作流程中学习的挑战：
- 弥合结构化语言和自然语言之间的差距
- 融入深入的领域知识
- 管理众多工作流
解决：Confucius提供了编程原语来弥合结构化数据和大语言模型之间的差距；结合了多个智能体的输出，以实现更好的规划。
#### ③与工具连接的结构化数据
问题：网络工程师依赖于处理结构化数据的复杂工具
解决：用一组将自然语言输入转换为符合DSL的输出的原语与多个特定于领域的工具进行交互
#### ④长期和短期记忆的特定领域检索
问题：协调多个智能体
解决：Confucius提供了跟踪与人类和工具交互的记忆功能，提供短期内存管理，利用RAG来处理大量的上下文
#### ⑤通过验证和人工输入确保正确性
Confucius与现有的验证框架集成
对于高度敏感的任务，需要人工批准：使用了一种叫做收集器的原语，通过结构化的人类交互来系统地收集用户输入
### 3.编程框架
【figure4：用原语和抽象简化应用程序开发的编程框架】
#### ①编程抽象
Confucius的核心是建立在Pydantic（一种用于定义自定义数据结构的Python模式语言）之上的
核心抽象类：Analect，保存输入、输出和运行时的可重用逻辑和数据。其操作符实现了基本功能
#### ②Confucius原语
e.g.ranslator原语将自然语言输入转换为结构化输出，将命令、查询和配置从一种语言翻译成另一种语言
#### ③工具DSL
Confucius支持网络管理应用中常用的三种DSL
#### ④应用
不同的团队开发了各种基于大语言模型的网络管理应用程序来解决特定领域的问题
#### ⑤外部系统
Confucius利用几个外部系统来增强其能力
- LangChain
- MetaGen API：用于AI模型访问
- FAISS：用于高效相似性搜索
- Instructor：用于嵌入
- NLTK：用于自然语言处理
## 4 Confucius的设计
### 1.规划阶段
#### ①网络工作流
常用MOPs来完成网络规划任务
缺点：模糊性和松散的文档
解决：Meta开发了一个工作流系统，将MOP编码并分解为更小的模块化构建块(BB)，从而促进更好的模块化和代码重用。
BB：是灵活的脚本或configlets（模块化的“配置片段”，设计用于跨设备和工作流）以各种编程语言或二进制文件编写
#### ②利用工作流进行大语言模型规划
##### （1）DAG表示
将网络任务的规划逻辑表示为有向无环图（DAG），使用基于Python的DSL实现
DAG中的每个节点代表一个子任务，与构建块相同。每个节点的输出由大语言模型解析，并用作后续节点的输入。独立的子任务可以并行执行，运行时环境根据输入/输出依赖关系自动确定最优执行计划。
【figure5】用于容量假设分析的示例DAG：用户定义的场景涉及修改网络拓扑、扩展需求和评估多种条件下的结果，被分解为离散的、可组合的子任务。每个操作都被封装为DAG中的一个节点，以实现模块化执行和清晰的数据流。
##### （2）建议现有工作流程
工作流和BB发现的挑战：由于有数百个工作流和数千个BB，工程师很难为特定任务确定正确的BB
解决：开发了一种基于RAG的方法来有效地搜索和推荐工作流和BB
【figure16】系统架构由两个主要组件组成：索引器和检索器。
- 索引器利用大语言模型来分析每个工作流和BB，提取关键信息来计算语义嵌入，然后将其存储在数据库中。
- 检索器分两个阶段运行：粗粒度相似性搜索以选择大约10个候选工作流/BB，然后是细粒度选择以将选项细化到少于3个。
#### ③Confucius用于规划的原语
##### （1）Ensemble
Ensemble在单个任务上并行调用多个大语言模型，并将它们的结果组合成单个输出，保持了原始的字符串到字符串接口，允许它无缝地替换标准的大语言模型调用。【figure15】编程构造的示例
用户向支持的API提供LLMParams列表来激活Ensemble
Confucius支持四种合成模式：
- 第一模式选择最快智能体的结果
- 合并模式合并所有智能体的结果以供人工审查
- 验证过滤器使用验证框架过滤掉错误结果
- Return-all将所有答案作为一个集合返回
Ensemble接受自定义合成函数，支持灵活的策略来确保来自潜在不可靠的构建块的可靠结果。
##### （2）Orchestrator
Orchestrator是一种新颖的AI框架，它使大语言模型能够通过逐步调用构建块来自主创建工作流。
在提示中提供详细的示例和说明+告知大语言模型何时使用哪些构建块
在自主操作和受控执行之间取得了谨慎的平衡
### 2.工具：网络管理抽象
为什么：将自然语言翻译成现有的网络管理工具可以处理的结构化数据DSL→与现有的网络管理工具集成
#### ①Confucius引入了三个原语-系统地定义了翻译逻辑，并收集了完成翻译所需的附加信息
##### （1）翻译器
将自然语言转换为结构化输出。可以处理多种语言，并在不同的CLI命令、查询和特定于供应商的配置之间进行翻译。
##### （2）选择器
使用可定制的逻辑来基于用户的查询选择相关选项的子集
为什么：虽然大语言模型通常可以缩小到结构化数据的子集，但它们需要额外的信息来生成精确的输出。
##### （3）收集器
从包括用户在内的各种来源收集和处理数据，以阐明意图并识别相关实体。可以减轻自然语言中的歧义。可以提出后续问题来完善用户的指令。
- 用户通过定义特定于其用例的CollectorTask来实例化Collector类
- 允许提供直接指令；允许提供少量的CollectorExample对象
- CollectorExample结构：用户输入的示例（与封装在CollectorArtifact中的正确响应配对）+包含得出答案的分步逻辑的CollectorThinking对象
- 【figure18】基于这些类创建的具体对象的示例
#### ②基础网络管理DSL
为什么：Translator原语用于将自然语言转换为结构化数据，但仍然需要确定要转换为哪种结构化数据格式，而现有的网络工具依赖于各种结构化数据格式
支持网络管理中三个广泛使用的DSL类可以更轻松地加入大量工具：
##### （1）网络图
网络拓扑图是各种应用中的基本元素
使用Thrift定义的图来表示拓扑:区域+第1层节点+第3层节点+第1层光学边缘+第3层IP边缘+流
节点的命名约定对于理解拓扑至关重要,提供了关于拓扑属性和角色的有价值的信息,举例说明了我们明确嵌入到大语言模型提示中的特定领域知识的类型，以便大语言模型可以识别和解释DSL中的这些模式。
使用TML来方便对图的修改，支持拓扑对象的系统更新、转换和选择。【figure7a】
##### （2）时间序列网络数据
时间序列网络数据是网络管理中的基本结构
在Meta中，时间序列数据存储在ODS的键值存储中
数据的基本单位：一个实体，可以表示任何被测量的对象。每个实体的数据由一系列<时间，值>快照组成【figure7b】
为了让大语言模型熟悉时间序列数据，我们在提示中嵌入了特定的领域知识，即明确指示大语言模型如何处理这类数据
##### （3）网络数据模型
通常将网络管理数据存储在结构化模型中
现代生产网络通常在管理数据库中维护其真实数据源，并在顶部提供对象关系映射（ORM）层以便于访问。
在Meta中，Robotron数据模型是几乎所有管理工具的基本组件【figure7c】。
- 接口由多个组件组成，每个组件链接到关系数据库中的其他对象
- 将大语言模型与现有的各种网络管理工具连接起来
- 将高级网络设计意图捕获为关系数据对象，然后将其转换为低级的、特定于供应商的设备配置和网络操作
- 大语言模型通过将用户的自然语言意图映射到Robotron中来进一步提升这种抽象，而Robotron又映射到低级配置
- 主要挑战：涉及大量模型
- 解决：开发了一种检索增强生成（RAG）方法
#### ③提示词工程技术→提高翻译准确性
技术&各自的DSL翻译任务
##### （1）0样本思维链
要求模型在翻译前进行思考，迫使模型首先考虑输入文本的网络上下文，而不是直接生成直译。
##### （2）少量样本思维链
为模型提供了翻译的相关例子。
##### （3）对比思维链
给模型错误的例子，并告诉他们这些例子是不正确的。
##### （4）工具调用
为模型提供了对API、CLI、库和数据库的访问，以实现代理规划
##### （5）推理与行动
使用一个编排器让大语言模型为网络调查中的复杂任务进行规划，适用于需要执行多个任务或响应不断变化的环境的情况
##### （6）作为推理的代码
让大语言模型编写代码来回答数据检索问题
- 允许编译器或人类容易地验证生成的代码
- 人类可以修改代码或合并多个代码片段，从而促进更易于管理和处理的任务分解
【figure8】ODS提示示例-Translator将用户查询转换为子问题
- 键：使用选择器缩小相关键的范围
- 实体：标识查询中涉及的特定实体
- Reduction：为常见的reduction运算符提供内置提示
- 时间范围：将时间范围转换为开始值和结束值
- 转换：应用复杂的函数，如平滑和计算样本之间的差异
#### ④内置验证→减少人工验证所需的人工工作&&使错误消息能够自动反馈给大语言模型进行自动更正→符合网络用例严格的安全要求
Confucius采用三种内置方法来验证生成的DSL的正确性：
##### （1）内置解析器
使用自定义解析器来检查一些专门的DSL的语法
如果解析器失败，它会提供一个清晰的错误消息，并反馈给大语言模型
迭代过程一直持续到输出解析成功或达到允许的最大试验次数
##### （2）外部API
##### （3）外部工具
检测到的错误被反馈到大语言模型
### 3.内存管理
短期记忆由单个用户会话中的会话历史组成，长期记忆包括与同一用例的不同会话相关的外部领域知识。
#### ①短期记忆：存储一个用户跨不同Analects的上下文。
- 开发专用的内存管理器组件，使用消息树作为内存的抽象
- 每个Analect都有自己的内存管理器，维护一个私有的消息列表+指向父内存、会话内存和其他相关上下文的指针→允许Analects访问和管理来自其父母、祖父母、条目和会话的消息→提供对会话历史的全面理解
Analects可以独立控制对其消息的访问，确保消息历史的完整性和隔离性。
#### ②RAG
开发了一种专门为网络数据模型设计的新的RAG方法，通过将相似的模型分组在一起并一次将每个模型输入大语言模型来预先计算嵌入存储→在查询（用户提交查询→分解成子查询→使用相似性搜索算法将每个子查询与我们商店中的嵌入进行比较→该算法识别最相似的嵌入→检索到的嵌入与用户的原始查询一起反馈到大语言模型中）处理过程中能够进行高效的相似性搜索，有效地管理我们数据库的规模和复杂性【figure16】
RAG的种类：
##### （1）朴素RAG
- 为各种数据源构建向量存储，并执行相似性搜索
- 适用于小型数据集
##### （2）混合RAG
使用两阶段过滤方法来检索相关信息
step1-获取相似性搜索结果并按相关性对它们进行排名
step2-应用额外的过滤器
step3-将预过滤后的结果发送到大语言模型进行基于语义的二次过滤
##### （3）查询转换
使用大语言模型来细化用户查询，生成更准确、更相关的搜索结果
step1-根据用户输入细化问题
step2-采用收集器模式通过与用户的对话收集额外的上下文
适用于用多种模糊方式描述的情况
#### ③隐私
实施预处理步骤，对敏感数据进行匿名化
step1-使用由不同团队开发的标识符编辑服务来识别40种类型的敏感信息，并用虚构的占位符替换它们
step2-在处理内容并收到大语言模型的响应后，反转匿名化过程，用原始敏感数据替换占位符
### 4.基准框架
采用软件测试的概念，同时广泛利用大语言模型来处理模糊匹配案例

优化Confucius应用程序可能是一项复杂的任务，用户通常希望考虑不同模型之间的性能以及特定数据集上的提示技术。为了简化这个过程，我们开发了一个具有三个功能的基准测试框架→评分过程标准化
- 使用开发人员为其特定用例提供的数据进行测试
- 评估不同提示技术和基础模型的影响
- 优化端到端性能并调整准确性和计算成本之间的权衡
#### ①工作流
评估管道=用户提供的数据集+Confucius应用程序+一组评估标准
step1-评估器读取input-output对的数据集，并在这些输入上调用应用程序
step2-收集实际输出，并根据预期输出进行评分
用户可以可视化分数，以比较不同评估的性能
#### ②评价标准
三个内置评估标准→显著减少了在快速工程和识别回归上花费的时间
##### （1）精确匹配
对于确定性和数值输出
##### （2）正则表达式匹配
适用于集合或字符串输出，以验证特定关键字
##### （3）大语言模型作为判断
对于复杂的输出，它判断意义的接近度
## 5 应用案例研究
### 1.容量假设
①问题：
- 生成分析不同拓扑场景的实验计划是复杂的
- 对于用户：
	- 有多种工作负载和场景；多次运行规划软件耗时长
	- 大量重复性任务→低效
	- 跟踪和记录实验结果很麻烦
	- 跨工作负载的互操作性很低
②解决：在Confucius上构建了一个假设分析，使用一个规划智能体来创建DAG工作流+一个工具智能体来将拓扑变化转换为TML+短期内存来记录每次运行的结果
③【figure9】
（1）流程：用户描述一个意图：生成TML来修补几个供应场景→生成TML来修补几个需求场景→运行NAPT
（2）关键步骤：在每一步，Confucius通过使用收集器支持人工干预来确保灵活性和准确性
- DAG创建：Confucius根据用户意图协助工作负载选择→用户使用选择器从实时注册的工作负载列表中进行选择→规划代理创建相应的DAG
- 确保节点之间的互操作性：对于每个节点，系统提供输入预选、使用自然语言的输入/输出传递和节点信息收集过程的可视化，以及特定于输入的提示
- Confucius使用Translator生成一个TML代码片段
### 2.故障诊断
①问题：网络故障排除具有挑战性
②解决：Code Assist：一个人工智能编码助手，利用Orchestrator进行高级规划
③【figure10】故障排除工作流程
用户请求诊断与Scribe发布/订阅系统中的读取操作相关的网络延迟问题
→Confucius Code Assist执行一系列交错的思考和工具使用步骤/生成RTT数据的热图来提供见解
→Confucius识别出最高延迟区域对涉及“DC1”数据中心，并将这些发现呈现给用户
④过滤和聚合常见的监控数据和运行时指标→产生针对特定场景定制的工作流→解决故障排除场景

灵活架构：用户向Confucius Orchestrator提供工具使用函数列表→表示为可定制的代理。Confucius Orchestrator利用高级模型执行“思考”步骤→确定调用哪些代理工具、传递哪些参数


## 6 Implementation
1.基于python
2.【figure4】Confucius的工程部件
①核心抽象类Analect（强类型）：LangChain的Runnable的轻量级包装器
使用基类Analect定义原语：Translator、Selector、Collector、Ensemble、Orchestrator
②Pydantic：提供了贯穿Confucius的几个基本特性，如类型验证、序列化、泛型和继承
③Entry：一个专门的Analect，确保输入和输出类型都是字符串，分别封装在EntryInput和EntryOutput对象中
④短期内存：使用内置的AnalectRunContext实现。
AnalectRunContext是一个自定义Pydantic对象，用于存储相关元数据和上下文数据，如会话ID、会话历史和以前生成的工件；或指定用于长期存储器的存储器管理器，其通过访问基于MySQL的数据库系统来实现
【figure17】使用Pydantic和AnalectRunContext来实现用于ODS翻译的Analect

## 7 Evaluation
在一系列网络管理任务上系统地评估Confucius
- 证明
- 了基于集成的自一致性提高了性能
- 演示Confucius如何利用不同的基础模型来执行DSL翻译，其准确性高于微调的基线模型
- 评估了RAG的效益
### 1.方法论
#### ①数据集
为以下用例管理合成数据集：TML、ODS转换、ODS减少、Robotron、Netgram和Wiki问答。
每个数据点都由一个自然语言查询及其基本事实答案组成。
【figure12&figure13】每个数据集的大小N
#### ②度量
使用正则表达式匹配：
- 如果大语言模型输出包含基本事实Netgram块的名称以及指向块源代码的正确URL链接，则该值为1
- 如果其中只有一个被正确识别，则该值为0.5
使用大语言模型作为判断来给出0到1之间的整体分数
#### ③模型
使用Llama 3.1和3.3、Claude 3.5 Sonnet、Gemini 1.5 Pro和2.0 Flash以及GPT-4o&使用针对特定领域数据进行微调的内部模型
#### ④基准
- 7.2-使用Llama 3.1评估了集成与单模型生成的使用
- 7.3-将Confucius与微调模型在几个DSL翻译任务上进行了比较，说明了将领域知识仔细嵌入到提示中的优势，而不是将该领域知识放在模型的训练数据中
- 7.4-在几个用例上评估了Confucius（这些用例依赖于这些用例特有的大量知识），以说明通过RAG检索领域知识的优势，而不是将领域知识嵌入模型的训练数据中
- 混合RAG和查询转换的有效性
### 2.多智能体推理集成
#### ①设置
集成是提高规划精度的关键原语。
通过以下设置评估集成对ODS减少和转化的准确性的影响：
- 使用Llama 3.1的单模型生成
- 同类集成，结合了三个temperature=0.5的Llama 3.1模型
- 异类集成，结合了Llama 3.1、Claude 3.5 Sonnet和Gemini 2.0 Flash模型
对于集成实验，使用Llama 3.1根据Confucius对任务的内部知识来选择最佳答案。
#### ②结果
【figure11】对于两个数据集，所有集合设置的性能都严格优于单模型设置&多模型集成降低了基线的标准误差
（1）多模型集成实现了最佳性能
（2）集成通过聚合不同智能体输出中的不一致性来减少分数的方差
### 3.DSL翻译
#### ①实验设置
（1）评估3个结构化数据类型的DSL翻译：拓扑图的TML，数据模型的Robotron，时间序列的ODS简化/转换
（2）将Confucius与微调的基线进行比较，以强调仔细提示词工程的好处
#### ②结果与分析
##### （1）Robotron用例
评估了Confucius和Llama 3.1的端到端性能，涉及到：
- 使用Translator从自然语言查询中提取和关联实体
- 使用retrieval来查找最相关的数据模型
【figure13】Confucius超过微调基线的性能13%
→强调了其将自然语言翻译成Robotron查询的能力的有效性&其通过上下文检索识别正确数据模型的能力的有效性
##### （2）TML和ODS实验
在7个不同的基础模型中评估Confucius，比较了有和没有思维链（CoT）提示的性能。
【figure12】Confucius在TML方面优于基线35%，在ODS转化方面优于基线22.4%，在ODS减少方面优于基线23%
→Confucius的领域感知提示的有效性，特别是它使用结构化提示和内置验证来生成准确、格式良好的响应。
Confucius在不同的基础模型中表现一致，为开发人员提供了更大的灵活性来利用新的大语言模型模型。
【figure12】通过结合CoT提示，Confucius进一步提高了其在大多数基础模型中的性能，在TML上使用Gemini 2.0 Flash的准确性显著提高了7%。
问题：在少数情况下，使用CoT会影响性能，因为CoT有时会鼓励模型过度思考并产生过于复杂的响应。
尽管如此，CoT提示仍然提高了92.4%的所有翻译数据点的准确性，强调了中间推理步骤在DSL翻译中的价值。
### 4.用于知识检索的RAG
#### ①实验设置
在Meta的3个网络用例中评估了RAG的使用与领域知识在微调数据中的使用，以及混合RAG和查询转换的优势：Robotron、Netgram和Wiki Q&A。
##### （1）Robotron
Confucius通过上下文学习从400多个期望的模型中检索
##### （2）Netgram
Confucius从具有118.6 K向量和1.24 GB内存占用的嵌入存储中检索
##### （3）Wiki Q&A
Confuciuss从33.5 GB内存占用的3.3 M向量的嵌入存储中检索
#### ②结果与分析
【figure13】Confucius在所有检索任务上都优于微调后的基线。
评估不同k值的RAG：
k：通过相似性搜索检索到的邻居的数量
当k>5时，我们应用混合RAG技术从检索到的候选中过滤前5个最相关的响应
将Netgram和Wiki Q&A的k分别增加到15和k增加到10时，混合RAG的性能提高了3%
问题：增加k超过某一点会导致收益递减
解决：应用查询转换技术，在检索前用大语言模型从用户查询中提取关键术语→减少匹配长文档时的噪声
【figure13c】在k=10时，该技术将Confucius的性能从0.73提高到0.77

### 5.采用和使用统计
广泛应用
人工智能生成的消息与人类消息的比率很高
【table3】不同类别的网络管理任务的应用程序
【figure14】调查数据中报告的每个应用每周节省的工程师总工时

## 8 Experiences
开发Confucius和onboarding应用程序的生产经验
### 1.Meta基于大语言模型的网络助理的发展

|      | Confucius                              | MetaMate                    |
| ---- | -------------------------------------- | --------------------------- |
| 目的   | 为MetaMate的结果可能不是最佳的特定用例而设计的            | 通用的人工智能助手                   |
| 能力   | 依赖于在安全环境中执行的自定义脚本                      | 提供聊天UI、命令执行和代码完成等功能         |
| 目标受众 | 为需要执行特定任务的用户量身定制的，这些任务需要自定义脚本和更高的执行安全性 | 适用于通用的内部数据检索和帮助Meta内不同平台的用户 |

### 2.什么效果好
#### ①网络问题的检索与总结
许多网络应用程序共享一个共同的模式：利用现有内容来建议相似的项目，并通过用户修改生成新的项目。
Confucius的嵌入和检索方法能够与RAG prompt工程直接集成，通常会产生令人满意的结果。
#### ②与现有管理工具集成，可快速采用
与现有自动化系统和工具的集成是更广泛采用的关键，这些系统具有结构明确的输入和输出，以辅助自动化。
通过理解和生成这些结构化数据，可以将大语言模型添加到现有的自动化管道中，从而促进日常使用。
### 3.经验教训
#### ①迭代过程在网络问题中的重要性
问题：许多网络管理任务很复杂，通常被建模为调用多个工具的工作流。然而，准确地编写工作流需要对所有涉及的工具有深入的领域知识。
解决：Confucius的设计包括一个工件，它演示了UI中的中间步骤，允许开发人员一步一步地处理工作流。这种方法使开发人员能够首先绘制整个步骤的草图，然后放大每个单独步骤的细节。
#### ②大语言模型在网络故障排除中的局限性
问题：网络故障排除问题具有最大的变体，并且实现与领域专家相当的性能具有挑战性；专家是基本模型和命令的大师，大模型难以显示价值；由于缺乏结构，网络故障排除也具有挑战性；大语言模型无法通过MOP解决困难问题
#### ③故障场景
（1）上下文传播可能会在会话的后期丢失
解决：采用即时工程来重申重要的约束
（2）幻觉和未能及早失败
（3）隐私问题
一些网络调查需要访问应用程序和服务数据，每种数据都有不同级别的隐私.侵犯隐私导致的错误没有被大语言模型清楚地突出显示。
## 9 Related work
### 1.通用智能体框架
Confucius建立在LangChain[13]之上，并提供了几个额外的优势，包括跟踪、公共原语和可运行的可重用性以及跨工具的互操作性。
LangGraph
AutoGen
### 2.使用大语言模型将任务联网
ABR算法
PROSPER
### 3.系统级应用
Ciri
DIO Copilot
ChatAFL
ShieldGPT
LLo11yPop
AssetOpsBench
## 10 Conclusion
在本文中，我们介绍了Confucius，这是一个多智能体大型语言模型（大语言模型）框架，旨在解决Meta网络管理的复杂挑战。通过将推理与特定领域的知识和工具解耦，Confucius实现了与现有基础模型的有效协作，而无需进行微调。我们的框架将管理任务分解为更小的结构化子任务，允许使用特定于领域的工具和数据库精确执行。我们已经通过Confucius在生产中的部署展示了它的有效性，为数千名用户和60多项管理任务提供了服务。Confucius有潜力实现并彻底改变真正基于意图的网络管理。