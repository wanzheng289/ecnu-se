## 7.1 经典同步问题
### 7.1.1 有界缓冲区问题
1.共享数据结构
``` c
int n;//n个缓冲区，每个缓冲区可存一个数据项
semaphore mutex=1;//二进制信号量，提供互斥要求
semaphore full=0;//满的缓冲区数量
semaphore empty=n;//空的缓冲区数量
```
2.生产者
``` c
while(true)
{
	...
	/*生产一个item放入next_produced*/
	...
	wait(empty);//检查是否有空缓冲区，没有则挂起
	wait(mutex);//获取锁
	...
	/*将next_produced存入缓冲区*/
	...
	signal(mutex);//释放锁
	signal(full);//表示有一个item被放入
}
```
3.消费者
``` c
while(true)
{
	wait(full);//检查是否有满缓冲区，没有则挂起
	wait(mutex);//获取锁
	...
	/*将一个item从缓冲区移入next_consumed*/
	...
	signal(mutex);//释放锁
	signal(empty);//表示释放了一个空位
	...
	/*消费next_consumed的一个item*/
	...
}
```
### 7.1.2 读者-作者问题
1.读者-只需读数据库的进程；作者-读和写数据库的进程
2.允许多个读者同时访问数据库；作者在写入数据库时具有共享数据库独占的访问权
3.第一读者-作者问题
①共享数据结构
`数据库`
``` c
semaphore rw_mutex=1;//控制写者进入，也被第一个读者和最后一个读者操作
semaphore mutex=1;//保护read_count的互斥访问
int read_count=0;//正在读对象的进程的数量
```
②作者进程
``` c
while(true)
{
	wait(rw_mutex);//只要有一个写者在写，rw_mutex会为0，其它写者和读者都会被阻塞
	...
	/*写*/
	...
	signal(rw_mutex);
}
```
③读者进程
``` c
while(true)
{
	wait(mutex);
	read_count++;
	if(read_count==1)//第一个读者
	{
		wait(rw_mutex);//锁住写者
	}
	signal(mutex);
	...
	/*读*/
	... 
	wait(mutex);
	read_count--;
	if(read_count==0)//最后一个读者
	{
		signal(rw_mutex);//释放锁，允许写者写
	}
	signal(mutex);
}
```
### 7.1.3 哲学家就餐问题
#### 一、采用信号量的解决方案
1.共享数据：`semaphore chopstick[5]`
`chopstick[i]`指一只筷子
2.哲学家i
``` c
while(true)
{
	wait(chopstick[i]);//获取筷子
	wait(chopstickp[i+1]%5);
	...
	/*进食*/
	...
	signal(chopstick[i]);//释放筷子
	signal(chopstick[(i+1)%5]);
	...
	/*思考*/
	...
}
```
缺点：可能导致死锁
#### 二、采用管程的解决方案
1.共享数据
``` c
enum{THINKING,HUNGRY,EATING}state[5];//哲学家i只有在其两个邻居不在就餐时才能设置变量state[i]=EATING为（state[(i+4)%5]!=EATING）和（state[(i+1)%5]!=EATING）
condition self[5];//哲学家i饥饿&&拿不到筷子时延迟请求
```
2.实现：`pickup`→就餐→`putdown`
``` c
monitor DiningPhilosophers
{
	enum{THINKING,HUNGRY,EATING}state[5];
	condition self[5];
	
	void pickup(int i)//申请筷子
	{
		state[i]=HUNGRY;
		test(i);
		if(state[i]!=EATING)//如果相邻的哲学家在使用筷子
		{
			self[i].wait();//挂起等待
		}
	}
	
	void putdown(int i)//放下筷子
	{
		state[i]=THINKING;
		//看邻居是否需要进食
		test((i+4)%5);
		test((i+1)%5);
	}
	
	void test(int i)
	{
		if((state[(i+4)%5]!=EATING)&&(state[i]==HUNGRY)&&(state[(i+1)%5]!=EATING))
		{
			state[i]=EATING;
			self[i].signal();//释放
		}
	}
	
	initialization_code()
	{
		for(int i=0;i<5;i++)
		{
			state[i]=THINKING;
		}
	}
}
```
①调用顺序
``` c
DiningPhilosophers.pickup(i);
/*进食*/
DiningPhilosophers.putdown(i);
```
②缺点：可能饿死
## 7.2 内核的同步
### 7.2.1 Windows的同步
1.对于单处理器系统，当Windows内核访问一个全局资源时，它会暂时屏蔽一些中断
2.对于多处理器系统
①内核使用自旋锁保护全局资源
②内核使用自旋锁保护短代码
③内核确保绝不抢占拥有自旋锁的线程
3.对于内核外的线程同步，Windows提供调度对象
①采用调度对象的线程同步机制：互斥锁/信号量/事件/定时器
②事件：类似条件，用于线程间的同步，允许一个线程通知其他线程某个事件已经发生
③定时器到期后会通知一个/多个线程
④调度对象可以处于触发状态/非触发状态[[lesson7-sync-example.pdf#page=17&selection=11,0,15,7|lesson7-sync-example, p.17]]
（1）触发状态：对象可用，线程在获取时不会阻塞
（2）非触发状态：对象不可用，线程在试图获取时会阻塞
### 7.2.2 Linux的同步
1.2.6版本前Linux为非抢占内核，2.6版本后Linux为抢占式内核
2.Linux提供用于内核中同步的机制：
①原子整数：所有采用原子整数的数学运算在执行时不会中断
（1）类型：抽象数据类型`atomic_t`
（2）实现
``` c
atomic_t counter;
int value;
atomic_set(&counter,5);//counter=5
atomic_add(10,&counter);//counter+=10
atomic_sub(4,&counter);//counter-=4
atomic_inc(&counter);//counter+=1
value=atomic_read(&counter);//value=12
```
②互斥锁
③自旋锁
④信号量
⑤信号量和自旋锁的读者-作者版本
## 7.3 POSIX的同步
广泛应用于UNIX、Linux、masOS
### 7.3.1 POSIX互斥锁
``` c
#include<pthread.h>
pthread_mutex_t mutex;//数据类型：pthread_mutex_t
pthread_mutex_init(&mutex,NULL);//创建互斥锁，&mutex为互斥锁的指针
pthread_mutex_lock(&mutex);//获取互斥锁
pthread_mutex_unlock(&mutex);//释放互斥锁
```
操作正确-返回0
发生错误-返回非0错误代码
### 7.3.2 POSIX信号量
多个不相关的进程可以使用一个命名信号量作为同步机制，而无名的则不能
#### 一、POSIX命名信号量
``` c
#include<semaphore.h>
sem_t *sem;
sem=sem_open("SEM",O_CREAT,0666,1);
/*sem_open：创建和打开一个POSIX命名信号量
将信号量命名为SEM
标志O_CREAT表示如果该信号量尚不存在，则创建该信号量
0666：信号量通过参数0666对其他进程具有读写访问权限
1：信号量被初始化为1
*/
sem_wait(sem);//=wait
sem_post(sem);//=signal
```
#### 二、POSIX无名信号量
``` c
#include<semaphore.h>
sem_t sem;
sem_init(&sem,0,1);
/*sem_init：创建和初始化无名信号量
0：传递标志0，表示该信号量可以仅由属于创建信号量的进程的线程共享；非0标志允许其他进程也能访问信号量
1：将信号量初始化为1
*/
sem_wait(&sem);//=wait
sem_post(&sem);//=signal
```
### 7.3.3 POSIX条件变量
``` c
pthread_mutex_t mutex;//互斥锁
pthread_cond_t cond_var;//Pthreads条件变量的数据类型：pthread_cond_t

pthread_mutex_init(&mutex,NULL);
pthread_cond_init(&cond_var,NULL);//初始化条件变量

/*线程等待条件a==b*/
pthread_mutex_lock(&mutex);//互斥锁，在调用pthread_cond_wait前加锁
while(a!=b)
{
	pthread_cond_wait(&cond_var,&mutex);
}
pthread_mutex_unlock(&mutex);//释放锁

/*线程修改共享数据*/
pthread_mutex_lock(&mutex);//加锁
a=b;//修改数据
pthread_cond_signal(&cond_var);//唤醒一个等待条件变量的线程（不释放互斥锁）
pthread_mutex_unlock(&mutex);//释放互斥锁，唤醒线程成为互斥锁的所有者，并将控制权返回到对pthread_cond_wait的调用

```
## 7.4 Java的同步
跳过
## 7.5 其他方法
跳过