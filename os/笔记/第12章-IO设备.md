## 12.2 I/O硬件
概念
- 端口：设备连接到计算机的接口
- 总线/菊花链：不同设备可以共用同一根总线与主机通信
	- PCIe总线[[lesson12-IO.pdf#page=7&selection=11,0,11,26|lesson12-IO, p.7]]
	- 扩展总线
	- 串行连接SCSI
- 控制器：负责驱动端口、总线和设备的电子硬件
	- 集成/独立的
	- 组成：处理器、微代码、私有内存、总线控制器
	- 有些主机控制器并不直接控制硬件，而是与每个设备的局部控制器通信
- 寄存器：让设备驱动程序与设备进行交互
	- 数据输入寄存器、数据输出寄存器、状态寄存器、控制寄存器
	- 大小：1-4字节或FIFO缓冲区
### 12.2.1 内存映射I/O
1.操作系统或CPU通过设备地址来访问设备的寄存器
2.设备地址的使用方式
①直接 I/O 指令：一种特殊的 CPU 指令，专门用于 I/O 操作
PC 中设备的 I/O 端口地址分布：[[lesson12-IO.pdf#page=10&selection=11,0,11,33|lesson12-IO, p.10]]
②内存映射 I/O：用内存地址空间中的某一部分来映射设备寄存器，即把设备的数据寄存器和控制寄存器当作内存一样访问
### 12.2.2 轮询
1.每处理一个字节的输入/输出的流程：
①读取状态寄存器中的 busy 位，直到其为 0
②主机设置读/写位，如果是写操作，则将数据写入数据输出寄存器
③主机设置 command-ready 位
④控制器设置 busy 位，执行数据传输
⑤传输完成后，控制器清除 busy 位、error 位和 command-ready 位
2.缺点：低效
### 12.2.3 中断
1.中断请求线IRL：CPU中断请求线由I/O设备触发。CPU 在每执行完一条指令后，都会检查中断请求线是否被拉高，如果是，就暂时停止当前程序，转去处理中断。
2.中断处理程序：中断发生后，控制权会转交给中断处理程序
有些中断是可屏蔽的，可以暂时忽略或延迟响应
3.中断向量：根据中断类型编号，跳转到对应的中断处理函数地址
①前后都要切换上下文：必须保存当前任务的状态，处理完中断后再恢复
②支持中断优先级：哪个中断先响应，取决于其优先级
③有些中断不可屏蔽，必须立即响应
④中断串联：若多个设备共享一个中断号，则需逐个尝试，找到触发中断的那个设备
4.中断驱动的I/O循环
①设备驱动发起 I/O 请求
②I/O 控制器启动 I/O 操作
③当输入准备就绪、输出完成、或发生错误时，设备向 CPU 发送中断信号
④CPU 接收到中断后，转移控制权到中断处理程序
⑤中断处理程序处理设备数据，并从中断返回
⑥CPU 恢复执行原来的任务
⑦回到第1步
5.中断机制也用于处理异常
页错误是内存访问异常的一种
6.系统调用也是一种受控中断
7.多 CPU 系统支持并发处理中断
8.中断处理必须快速、用于实时任务
### 12.2.4 直接内存访问DMA
批量传输大量数据
1.DMA控制器：控制数据在设备与内存之间流动，而不需要每次都依赖CPU
2.工作原理：绕过CPU，在I/O设备和内存之间直接传输数据
3.操作系统会向内存中写入一个DMA命令块，内容包括：
- 数据的源地址和目的地址；
- 是读操作还是写操作；
- 传输的数据大小（字节数）；
最后，把这个命令块的位置告诉 DMA 控制器
4.DMA控制器具有总线主控权，可以从CPU手中抢占系统总线使用权
周期窃取
5.一旦DMA完成了数据搬运，就会发出一个中断，CPU收到通知后，知道数据准备就绪或操作完成
6.虚拟地址直接内存访问DVMA：支持虚拟地址访问
7.完成一次 DMA 传输的六个步骤
①设备驱动被告知要将 drive2（磁盘2）的数据传输到内存地址为 x 的缓冲区中
②设备驱动将“传输 c 字节数据到地址 x”的命令传递给磁盘控制器
③驱动控制器启动 DMA 传输
④DMA 控制器将 drive2 的数据搬运到内存地址 x 开始的缓冲区中，边搬运边增加地址（x++），并减少剩余字节数（c--），直到全部搬完（c=0）
⑤当所有字节传输完成（c=0）后，DMA 控制器向 CPU 发送中断，表示“数据传输完毕”
⑥CPU 响应中断并恢复任务，继续处理接收到的数据
## 12.3 应用程序I/O接口
内核I/O结构
（从上到下：）
①软件层
- 内核
- 内核I/O子系统
- 设备驱动程序
	- SAS 硬盘驱动
	- 键盘驱动
	- 鼠标驱动
	- PCIe 总线驱动
	- 无线网卡驱动  
	- USB 驱动
②硬件层
- 设备控制器
- 实体设备
### 12.3.4 非阻塞与异步I/O
1.阻塞：进程会被挂起，直到 I/O 操作完成后才恢复执行
- 易于使用和理解
- 对部分情况效率较低
2.非阻塞（自己问）：I/O 调用会立刻返回，返回当前能读取/写入的那部分数据
- 通过多线程实现
- 快速返回读取或写入的字节数
3.异步（别人通知）：I/O 操作在后台进行，进程不等待，继续运行，直到 I/O 完成时被系统通知
- 难以实现
- 一旦完成会通过信号、回调、事件等方式通知用户进程
4.阻塞&异步[[lesson12-IO.pdf#page=20&selection=11,0,11,15|lesson12-IO, p.20]]
①阻塞：
- 用户进程发起 I/O 请求，陷入内核 → 设备驱动；
- 驱动程序调用设备，等待硬件完成数据传输；
- 在传输完成之前，用户进程处于等待状态；
- 当设备准备好后，触发中断，由中断处理程序处理；
- 最后唤醒用户进程，返回数据。
②异步：
- 用户进程发起 I/O 请求后立即返回 → 不等待；
- I/O 请求在内核中由设备驱动和硬件完成；
- 等数据准备好后，由中断处理程序响应；
- 中断处理程序将结果交回给进程，或通过信号/回调通知；
- 用户进程此时可以继续其他工作，不会被阻塞
5.I/O请求的周期
① 用户态：`request I/O` → `system call`
用户调用 I/O（如 `read()`、`write()`）→ 进入内核 → 发起系统调用
② 内核：`can already satisfy I/O request?`
判断内核是否已经有数据（例如缓冲区中已有数据）
- 是：不必真正访问设备
 把数据直接放入返回值或用户进程空间，立刻返回 → 快速完成          
- 否：必须实际访问设备
	- 发送请求到设备驱动	
	- 如是阻塞式 I/O，则挂起当前进程（blocking）
③ 设备驱动层：
- `process request, issue commands to controller, configure controller to block until interrupt`
    - 设备驱动解析请求
    - 向硬件控制器下发命令
    - 配置控制器工作，并设置为 “当中断到来时再解除阻塞”
④ 控制器：`execute command, monitor device`
- 控制器执行数据传输操作（例如从磁盘读取数据）
- 完成后触发：  
    → `I/O complete, generate interrupt`  
    发送一个 硬件中断 信号给 CPU
⑤ 中断处理程序：
- `receive interrupt, store data in device-driver buffer if input, signal to unblock device driver`
    - 中断处理器响应
    - 将结果数据（若是输入）存入设备驱动缓冲区 
    - 通知设备驱动：I/O 已完成
⑥ 回到驱动 → 回到内核：
- `determine which I/O completed, indicate state changes to I/O subsystem`
    - 驱动确定哪个 I/O 完成
    - 告诉 I/O 子系统该唤醒哪个进程，更新其状态（从阻塞 → 就绪）
⑦ 回到用户态：
- `return from system call`
    - 将最终结果返回用户程序  
    - 用户态程序得知：I/O 已完成，数据就绪
## 12.7 性能
1.问题
- 需要CPU来执行设备驱动程序和内核I/O代码
- 因中断引起上下文切换
- 数据拷贝开销
- 网络流量尤其令人头痛
2.提升方法
①减少上下文切换的次数
②减少数据拷贝
③通过使用大块传输、智能控制器、轮询机制等方式减少中断
④使用DMA（直接内存访问）
⑤使用更智能的硬件设备
⑥在 CPU、内存、总线和I/O 性能之间进行平衡，以实现最高吞吐量
⑦将用户态进程或守护进程转换为内核线程