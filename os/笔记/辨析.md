1.进程&管程&线程
①进程&管程
（1）进程：进程是程序在某一数据集上的一次执行过程
（2）管程：管程是封装了共享数据结构及其所有操作过程，并严格保证在任何时刻，最多只有一个进程或线程在其内部执行操作的机制
（3）区别：进程是执行的单位；管程是同步的单位
（4）联系：管程存在于进程之中，进程间共享需要管程

【标答】
（1）管程：是一种并发行的构造，包括用于分配一个共享资源或者一组共享资源的数据的过程。为了完成分配资源的功能，进程必须调用特定的管程入口。管程采用资源集中管理的方法，将系统中的资源用某种数据结构抽象地表示出来。由于临界区是访问共享资源的代码段，因而建立一个管程来管理进程提出的访问要求。采用这种方式对共享资源的管理就可以借助数据结构及数据结构上的实施操作的若干过程来进行；对共享资源的申请和释放可以通过管程在数据结构上的操作来实现
（2）进程：进程是计算机中的程序关于某数据集的一次运行活动。在传统操作系统中，它是资源拥有的基本单元。进程之间可以并发执行。进程虽然拥有自己的资源系统，但也因此导致创建或撤销进程的开销都很大，切换、通信、同步也会比线程之间的实现更加复杂。进程存在的标志是进程控制块
（3）联系：进程可以通过管程对临界资源进行排它使用

②进程&线程
（1）进程是执行中的程序，是资源分配的最小单位
（2）线程是轻量级的进程，是资源调度的最小单位
（3）对于单线程的进程，进程既是资源管理/资源分配的单位，也是任务调度/CPU调度的单位；对于多线程的进程，线程是任务调度单位，进程是资源管理单位
（4）线程相关的硬件资源包括CPU的寄存器以及堆栈，进程相关的资源包括除堆栈外的其他内存、打开文件列表等

| 特征       | 进程                                                       | 线程                                                                                |
| -------- | -------------------------------------------------------- | --------------------------------------------------------------------------------- |
| **定义**   | **资源分配**的基本单位，是程序在一个数据集合上的一次动态执行过程。                      | **CPU 调度**和**分派**的基本单位，是进程内部的一个独立执行流。                                             |
| **调度**   | 在传统的不支持线程的系统中，$\text{CPU}$ 调度的单位是**进程**。                 | 在支持核心态线程的系统中，$\text{CPU}$ 调度的单位是**线程**。                                           |
| **并发性**  | **进程间**的并发性：通过操作系统隔离和切换实现。开销大。                           | **进程内**的并发性：一个进程可以有多个线程**并行**（多核）或**并发**（单核）执行。                                   |
| **系统开销** | **创建、撤销、切换**的开销**大**。因为需要分配和回收独立的地址空间、$\text{PCB}$ 等资源。  | **创建、撤销、切换**的开销**小**。因为线程共享进程的绝大部分资源和地址空间。                                        |
| **拥有资源** | **独立拥有**资源。拥有独立的地址空间、文件描述符、信号、内存、$\text{PCB}$ 等**系统资源**。 | **共享**进程的资源，但**独立拥有**自己的执行上下文（$\text{TCB}$）、程序计数器 ($\text{PC}$)、栈、寄存器等**执行相关资源**。 |

2.MLFQ&FCFS&RR
①MLFQ&FCFS
MLFQ多级反馈队列调度：是指设置多个不同的就绪队列，每个队列采用不同的调度算法并为每个队列设置不同的优先级
FCFS：是指按照作业进入就绪队列的先后顺序进行调度
区别：MLFQ是抢占式调度，存在多个队列优先级，有时间片，对短任务有利，但可能导致饥饿；FCFS是非抢占式调度，无优先级或时间片，任务独占CPU直到完成或被阻塞，不存在饥饿
联系：MLFQ中可能包含FCFS；都致力于实现公平性

②MLFQ&RR
（1）MLFQ多级反馈队列调度算法：设置多个就绪队列，并为每个队列赋予不同的优先级别和不同的时间片；第一个队列优先级最高，进程执行的时间片最少，新创建的进程挂到第一个优先级的队列后，然后按照FCFS排队等待。当轮转到其执行时，如果在其时间片内完成，便可以撤离系统；如果不能完成，便挂入第二级队列尾部；仅当第一个队列为空闲时，调度程序才调度第二级队列中的进程运行，以此类推。新进程可以抢占低优先级进程占有的处理机。优点是小作业响应快，大作业也能快速得到响应；缺点是可能导致低优先级队列的进程长时间得不到执行而导致饥饿，但是可以通过老化来解决
（2）RR时间片轮转法：每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，那么CPU将被剥夺并分配给另一个进程。优点是公平，而且使用最广；缺点是时间片设得太短会导致过多的进程切换，降低了CPU效率，而设得太长有可能引起短的交互请求的相应变差
（3）联系：时间片轮转法可以作为多级反馈队列调度算法的一个组成部分，即所及反馈队列中的某个队列采用时间片轮转的方法。

3.死锁&饥饿&不安全状态
①死锁&饥饿
死锁：多个进程循环等待对方，都无法继续执行
饥饿：某个或某些进程由于无法得到资源长时间无法执行
区别&联系：死锁必然发生饥饿，但是饥饿不一定发生死锁

②死锁&不安全状态
（1）不安全状态：指在当前的系统状态下，找不到一个安全序列使得当前所有的进程能够运行结束
（2）死锁：多个进程循环等待对方，都无法继续执行
（3）区别：死锁一定处于不安全状态，但是不安全状态不一定死锁

4.互斥量&信号量/互斥&同步
①功能：互斥量用于线程的互斥，信号量用于进程的同步
（1）互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排他性，无法限制访问者对资源的访问顺序，即访问是无序的
（2）同步是指大多数情况下，在互斥的基础上通过其他机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的；少数情况是指可以允许多个访问者同时访问资源。
②取值：互斥量值只能为0或1，信号量值可以为非负整数
（1）一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题
（2）信号量可以实现多个同类资源的多线程互斥和同步；当信号量为单值信号量时，也可以完成一个资源的互斥访问
③互斥量的加锁和解锁必须由同一线程分别对应使用；信号量可以由一个线程释放、另一个线程得到。

5.进程间同步&互斥&信号量
①进程同步：并发进程之间相互合作，完成一项工作，它们之间有一定的时序关系。互相约束，其表现为一个进程等待另一个进程的变量结果。采用私有信号量协同处理
②进程互斥：并发进程之间相互竞争临界资源的排他性关系，使用公用信号量mutex互斥处理
③联系：进程之间协同工作，既需要同步控制也需要对临界资源互斥访问

6.核心态&用户态
①核心态：核心态是操作系统内核执行的受保护的状态，拥有对所有硬件和内存的完全控制权，保护着系统资源不被用户程序的错误或恶意行为破坏
②用户态：用户态是用户进程执行所在的状态，是CPU执行的最低特权级别。在这个状态下，执行的是用户应用程序的代码
③区别：处在用户态只能访问进程的地址空间
在用户态中，进程只能访问分配给它的用户地址空间
在内核态中，CPU可以访问所有地址空间
④联系：用户态需要通过中断或系统调用进入内核态

7.并发&并行
①并发：一个时间间隔内有多个任务在执行。并发性支持多个执行进度的任务，但可能并不是真正的同时运行，是逻辑层面的同时推进
②并行：同一时刻内有多个任务在执行。并行性意味着一个系统可以同时执行多个任务，通常需要多核处理器或多个处理器支持，是物理层面的同时运行


8.死锁预防措施&死锁避免措施
①预防：需要破坏产生死锁的必要条件之一：互斥、占有并等待、非抢占、循环等待。该方法是最容易实现的，是一种粗粒度的解决方法，但是系统资源利用率较低
②避免：通过资源分配图（单实例资源）和银行家算法（多实例资源）等，在执行过程中计算资源的供需关系，从而避免死锁的发生。该算法需要较多的数据结构，实现起来比较困难，但资源利用率较高。

9.wait&signal
①wait：负责把当前进程由运行状态转换为阻塞状态或忙等状态，直到另外一个进程唤醒它或跳出忙等。其操作为：申请一个空闲资源，把信号量减1，若成功则退出，若失败则该进程被阻塞或忙等
②signal：负责把一个被阻塞的进程唤醒或跳出忙等，在唤醒的机制中有一个参数表，存放着等待被唤醒的进程信息。其操作为：释放一个被占用的资源，把信号量加1，如果发现有被阻塞的进程，则选择一个唤醒或跳出忙等
③联系：对信号量施行相反的操作，但是在解决互斥和同步时又需要配合完成

10.进程调度&进程通讯
①进程调度是指协调、分配进程占用CPU资源的算法
②进程通讯是操作系统负责不同进程间共享内存、磁盘文件、打印机等硬件的方法
③区别：进程调度只负责进程间CPU资源的共享，而进程间通讯主要负责非CPU资源的共享
11.微内核&模块化内核
①微内核：操作系统内核只包含最基本的功能：进程调度和进程间通讯。进程间通过消息传递进行通讯。如文件系统、设备驱动、网络协议栈、内存管理等服务作为独立的用户级进程运行。
②模块化内核：操作系统内核的一些功能可以作为模块挂载。它保留了宏内核的结构，但将这些服务组织成独立、可动态加载和卸载的模块。所有服务的代码都在核心态运行。
③区别：微内核中内核和其他操作系统的功能模块在不同的地址空间运行，模块化内核中它们在一个地址空间

| 区别角度       | 微内核                                                         | 模块化内核                            |
| ---------- | ----------------------------------------------------------- | -------------------------------- |
| **核心服务位置** | 大部分服务（驱动、文件系统等）运行在**用户空间**。                                 | 所有服务模块都运行在**核心空间**。              |
| **通信机制**   | **消息传递** ($\text{IPC}$)，开销大。                                | **函数调用**，开销小。                    |
| **切换开销**   | 高（频繁的用户/核心态切换）。                                             | 低（只需加载/卸载模块，服务调用无切换）。            |
| **容错性**    | 高（服务进程崩溃不影响内核）。                                             | 相对低（模块崩溃可能导致整个内核崩溃）。             |
| **设计理念**   | **最小化内核**，将服务抽象为进程。                                         | **优化宏内核**，将服务组织为动态组件。            |
| **典型系统**   | $\text{Mach}$ ($\text{macOS}/\text{iOS}$ 的基础）、$\text{QNX}$。 | $\text{Linux}$、$\text{FreeBSD}$。 |

12.对称多处理系统调度&非对称多处理系统调度
①SMP对称多处理系统调度：在SMP系统中，所有CPU都具有相同的功能，地位平等，并且共享内存和I/O设备。操作系统内核可以在任何一个可用的 CPU上运行，并且每个CPU都可以独立地执行调度程序，从公共的就绪队列中选择进程/线程来运行。
②ASMP非对称多处理系统调度：在ASMP系统中，各个处理器在功能上和地位上不对等。系统中有一个主处理器，由它来运行操作系统内核、执行所有调度、I/O 操作以及系统管理功能。其他从处理器只执行用户代码。只有主处理器执行调度程序，负责将任务分配给从处理器。

| 角度        | 对称多处理系统调度                             | 非对称多处理系统调度                                        |
| --------- | ------------------------------------- | ------------------------------------------------- |
| **处理器地位** | **对等**。所有 $\text{CPU}$ 地位相同，可执行任何代码。  | **不对等（主/从）**。一个 $\text{CPU}$ 为主，其他为从。             |
| **内核运行**  | 内核代码可以在**任何** $\text{CPU}$ 上运行。       | 内核代码**只在主 $\text{CPU}$** 上运行。                     |
| **调度执行**  | **每个 $\text{CPU}$** 都可以独立地运行调度程序。     | **只有主 $\text{CPU}$** 运行调度程序，将任务分配给从 $\text{CPU}$。 |
| **负载均衡**  | **容易**实现负载均衡，性能扩展性好。                  | **困难**实现完美均衡，主 $\text{CPU}$ 容易成为瓶颈。               |
| **内核同步**  | **高度复杂**。需要复杂的锁机制来保护共享的就绪队列。          | **简单**。调度集中在主 $\text{CPU}$，同步开销小。                 |
| **容错性**   | 较好。任一 $\text{CPU}$ 故障，系统仍可继续运行（性能下降）。 | 较差。主 $\text{CPU}$ 故障将导致**系统崩溃**。                  |