## 4.1 概述
### 4.1.1 动机
#### 0.单线程进程&多线程进程[[lesson4-Threads&Concurrency.pdf#page=5|lesson4-Threads&Concurrency, p.5]]
1.单线程进程：所有执行任务都只能串行运行，代码、数据、文件、寄存器、程序计数器、堆栈都被1个线程用
2.多线程进程：
①共享：代码、数据、文件
②每个线程私有：寄存器、堆栈、程序计数器
#### 一、需求
1.现代应用普遍采用多线程结构
2.线程是应用内部的执行单位，线程之间可以共享同一进程的资源
#### 二、并行任务场景
一个应用程序中可以有多个线程同时执行不同任务，例如：更新图形用户界面；异步加载数据；后台拼写检查；处理网络请求
#### 三、线程&进程
创建线程的开销远小于创建进程

| 区别    | 进程                            | 线程                       |
| ----- | ----------------------------- | ------------------------ |
| 资源分配  | 每次运行程序时都会分配新的资源。              | 共享所属进程的资源。               |
| 资源共享  | 通常资源不共享。对于相同程序，代码段可能会被多个进程共享。 | 线程之间共享代码段、堆、数据区，但不共享栈空间。 |
| 地址空间  | 拥有各自独立的地址空间                   | 共享同一个地址空间                |
| 通信方式  | 需要使用进程间通信机制进行通信               | 可以通过修改共享变量直接通信           |
| 上下文切换 | 一般比线程且缓慢                      | 一般比进程切换快，开销较小            |

#### 四、现代操作系统内核通常本身就是多线程的
#### 五、多线程服务器架构[[lesson4-Threads&Concurrency.pdf#page=6|lesson4-Threads&Concurrency, p.6]]
客户端向服务器发送请求，服务器创建新线程来服务请求，并继续监听额外的客户端请求
### 4.1.2 优点
多线程编程的优点：
1.响应性：如果进程的一部分被阻塞，该多线程交互程序可以继续执行，这对用户界面设计尤其由于
2.资源共享：线程共享进程的资源，比共享内存或消息传递更容易
3.经济：线程共享进程的资源，比共享内存或消息传递更容易
4.可伸缩性：进程可以利用多线程架构

## 4.2 多核编程
### 4.2.1 编程挑战
#### 一、挑战
多核或多处理器系统给程序员带来了压力，挑战包括识别任务；平衡；数据分割；数据依赖；测试与调试
#### 二、并发&并行[[lesson4-Threads&Concurrency.pdf#page=10|lesson4-Threads&Concurrency, p.10]]
1.并发：并发性支持多个执行进度的任务，但可能并不是真正的同时运行【逻辑层面的同时推进】
单核/单处理器+操作系统调度器⇒提供并发
2.并行：并行性意味着一个系统可以同时执行多个任务，通常需要多核处理器或多个处理器支持【物理层面的同时运行】
【谁有“行”，谁就可以同时执行】
#### 三、Amdahl定律
1.Amdahl定律：对于既有串行也有并行组件的应用程序，该公式确定由于计算核的增加而得到的性能改进
2.公式：
$Speedup \leq \frac{1}{S+\frac{(1-S)}{N}}$
$S:程序中串行部分所占比例$
$1-S:程序中并行部分所占比例$
$N:可用的处理器核心的数量$
$Speedup:加速比，表示使用N个核后比单核块多少倍$
### 4.2.2 并行的类型[[lesson4-Threads&Concurrency.pdf#page=12|lesson4-Threads&Concurrency, p.12]]
#### 一、数据并行
将数据分布于多个计算核上，并在每个核上执行相同操作
对同一种操作，作用于不同数据子集
#### 二、任务并行
将任务（线程）而不是数据分配到多个计算核，每个线程都执行唯一的操作
对同一数据执行不同任务

## 4.3 多线程编程
### 0.用户线程&内核线程[[lesson4-Threads&Concurrency.pdf#page=17|lesson4-Threads&Concurrency, p.17]]
1.用户线程：管理由用户级线程库完成
3个主线程库：
①POSIX Pthreads
②Windows线程
③Java线程
2.内核线程：由内核支持
几乎所有现代操作系统都支持内核线程：Windows；Linux；Mac OS X；iOS；Android

|          | 用户级线程         | 内核级线程       |
| -------- | ------------- | ----------- |
| 是否被内核感知  | 否             | 是           |
| 创建/切换效率  | 块             | 慢           |
| 是否支持多核并发 | 否             | 是           |
| 阻塞影响范围   | 一个线程阻塞会拖累整个进程 | 阻塞线程不影响其他线程 |
| 调度方式     | 由用户线程库负责      | 由操作系统内核调度   |

### 4.3.1 多对一模型[[lesson4-Threads&Concurrency.pdf#page=19|lesson4-Threads&Concurrency, p.19]]
1.多对一：多用户线程映射到一个内核线程
2.特点：多个线程在用户空间中切换，内核只感知到一个线程
3.缺点：缺乏并发性 + 易受阻塞影响，现代os几乎不使用多对一模型
①只要有一个线程调用了阻塞系统调用，整个进程的所有线程都会被挂起
②即使系统有多个CPU核，这些用户线程也只能在一个核上串行运行
e.g.Solaris Green Threads；GNU Potable Threads
### 4.3.2 一对一模型[[lesson4-Threads&Concurrency.pdf#page=20|lesson4-Threads&Concurrency, p.20]]
1.一对一：每个用户线程映射到一个内核线程，创建一个用户线程就会产生一个内核线程
2.特点
①比多对一模型有更强的并发能力
②每个进程能拥有的线程数量有时候会受到限制
e.g.Windows；Linux
### 4.3.3 多对多模型[[lesson4-Threads&Concurrency.pdf#page=21|lesson4-Threads&Concurrency, p.21]]
1.多对多：多个用户线程可以映射到多个内核线程
2.特点：系统可以根据需要动态创建足够多的内核线程；在现代os系统中少见
e.g.Windows系统中ThreadFiber技术
3.变体-两级模型[[lesson4-Threads&Concurrency.pdf#page=22|lesson4-Threads&Concurrency, p.22]]：和多对多模型类似，但允许用户线程绑定到某个特定内核线程

## 4.4 线程库
### 0.线程库
1.功能：线程库为程序员提供了创建和管理线程的API，可以通过线程库创建线程、销毁线程、切换线程、同步线程等
2.实现方式
①在用户空间中提供一个没有内核支持的库
②实现由操作系统直接支持的内核级库

|            | 用户空间线程库                                      | 内核级线程库                                        |
| ---------- | -------------------------------------------- | --------------------------------------------- |
| **实现位置**   | 完全在用户空间中实现                                   | 由操作系统内核提供支持                                   |
| **线程可见性**  | 操作系统看不到这些线程                                  | 每个线程对内核可见                                     |
| **线程切换开销** | ✅ 快（不涉及系统调用）                                 | ❌ 慢（需要陷入内核）                                   |
| **线程调度**   | 由用户线程库自行调度                                   | 由操作系统调度                                       |
| **阻塞影响**   | ❌ 一个线程阻塞会导致整个进程阻塞                            | ✅ 一个线程阻塞不影响其他线程                               |
| **并行能力**   | ❌ 无法利用多核，只能在一个CPU上串行                         | ✅ 支持多线程并行运行（多核CPU）                            |
| **灵活性**    | ✅ 编程灵活，可移植性强                                 | ❌ 依赖操作系统，不易跨平台                                |
| **应用示例**   | GNU Portable Threads  <br>Java Green Threads | POSIX Threads (pthreads)  <br>Windows Threads |
| **使用场景**   | 教学、嵌入式、轻量并发场景                                | 主流现代操作系统、高性能服务器                               |
3.主要线程库：POSIX Pthreads；Windows；Java
### 4.4.1 Pthreads
1.Pthreads是POSIX 标准（IEEE 1003.1c）中定义的线程库接口，专门用于多线程编程。
①POSIX 标准只规定API行为，不规定具体实现方式，可以是用户级/内核级
②这是一个标准接口，提供线程创建与同步的API
e.g.
- 创建线程（`pthread_create`）
- 等待线程结束（`pthread_join`）
- 互斥锁（`pthread_mutex_lock`）
③POSIX只定义规范，不提供实现。接口行为由标准规定，具体实现由系统开发者负责
- 是API标准文档，规定函数名、参数、语义
- 每个操作系统可以自己实现它，只要对外接口一致就行
④Pthreads广泛用于UNIX系系统（Linux和macOS）
2.e.g.
```c
#include<stdio.h>
#include<pthread.h>//提供pthread API
#include<unistd.h>//提供sleep函数
void *work(void *arg)//arg：pthread_create传出的参数
{
    int id=*(int*)arg;//转换成int再取值(将void*→显示转换int*指向整数的指针→解引用取值)
    for(int i=0;i<5;i++)//每个线程执行5次循环
    {
        printf("Thread %d:interation %d\n",id,i);//当前线程的编号和迭代次数
        sleep(1);//模拟线程的工作延时
    }
    return NULL;
}
int main()
{
    pthread_t t1,t2;
    int id1=1;//线程编号
    int id2=2;
    pthread_create(&t1,NULL,work,&id1);//创建的线程ID存放到t1；使用默认线程属性；线程创建后执行work函数；把变量id1的地址作为参数传进去
    pthread_create(&t2,NULL,work,&id2);
    pthread_join(t1,NULL);//主线程等待t1完成
    pthread_join(t2,NULL);
    printf("All threads finished.\n");
    return 0;
}
```
输出：
【第1次运行】
Thread 1:interation 0
Thread 2:interation 0
Thread 1:interation 1
Thread 2:interation 1
Thread 2:interation 2
Thread 1:interation 2
Thread 1:interation 3
Thread 2:interation 3
Thread 1:interation 4
Thread 2:interation 4
All threads finished.
【第2次运行】
Thread 1:interation 0
Thread 2:interation 0
Thread 2:interation 1
Thread 1:interation 1
Thread 2:interation 2
Thread 1:interation 2
Thread 2:interation 3
Thread 1:interation 3
Thread 2:interation 4
Thread 1:interation 4
All threads finished.
- 两个线程轮流打印输出：`Thread 1` 和 `Thread 2` 的输出交替出现，说明两个线程是并发执行的。
- 两个线程执行顺序不确定，取决于调度器调度
- 最后一行 "All threads finished." 是主线程输出。这行只会在 `pthread_join(t1)` 和 `pthread_join(t2)` 都执行完后才出现，说明两个子线程都执行完毕，主线程才继续向下执行
①`pthread_create`
```c
int pthread_create(
    pthread_t *thread,//参数1：线程ID输出位置
    const pthread_attr_t *attr,//参数2：线程属性（通常填 NULL）
    void *(*start_routine)(void *),//参数3：线程函数
    void *arg//参数4：传给线程函数的参数
);

```
(1)`pthread_t *thread`：输出参数，用于存放创建出的线程 ID，以便后续使用（如 `pthread_join`）
(2)`const pthread_attr_t *attr`：输入参数，用于指定线程属性，如是否为“分离线程”、栈大小、调度策略等。通常填 `NULL` 表示默认属性
(3)`void *(*start_routine)(void *)`：函数指针，线程创建后要执行的函数，格式必须是 `void* f(void*)` 类型
(4)`void *arg`：输入参数，传递给线程函数的参数指针（可传结构体、数组、基本变量地址）
(5)return：返回0创建成功，返回非0创建失败
②`pthread_join`
```c
int pthread_join(pthread_t thread, void **retval);
```
(1)`thread`：要等待的线程ID（由`pthread_create`返回），主线程会阻塞，直到这个线程运行结束
(2)`retval`：用于获取线程的返回值，可以填`NULL`表示不关心返回值
(3)return：返回0调用成功，返回非0错误码
### 4.4.2 Windows线程
jump
### 4.4.3 Java线程
jump
## 4.5 隐式线程
### 0.
1.隐式进程：线程的创建和管理由编译器或运行时库负责，而不是程序员手动编码
2.三种典型的隐式线程机制：线程池；复刻加入；OpenMP
### 4.5.1 线程池
1.线程池是一种预创建线程的机制，在线程池初始化时，程序就会提前创建好固定数量的线程。当有任务到来时，线程池中的某个线程会被派去执行该任务。
2.优点
①比新创建线程响应快，开销小
②线程池固定数量可防止线程过多导致上下文切换开销或资源耗尽
③把任务逻辑（要做什么）和线程控制（怎么做）分开，可以灵活地安排任务
e.g.支持周期性执行、定时任务、任务重试等策略
3.Python线程池

```python
from concurrent.futures import ThreadPoolExecutor,as_completed
import time

def work(task_id):#模拟任务运行过程
    print(f"Task {task_id} is running")#开始
    time.sleep(1)#休眠1s
    print(f"Task {task_id} done")#结束

with ThreadPoolExecutor(max_workers=3)as pool:#创建一个最多同时运行3个线程的线程池
    tasks=[]
    for i in range(0,6):
        task=pool.submit(work,i)
        tasks.append(task)
    for f in as_completed(tasks):
        f.result()
print("All tasks finished")
```
①`with ThreadPoolExecutor(max_workers=3) as pool:`
`with`是Python中的上下文管理器语法,它的本质作用是确保资源在使用完之后能够自动释放或清理。
②`ThreadPoolExecutor`
```python
from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor(max_workers=3) as pool:
    pool.submit(func, arg1, arg2, ...)
```
(1)`max_workers`：线程池中最多同时运行的线程数.如果提交的任务数量多于这个数字，任务会排队等待
(2)`submit(func, *args)`：向线程池提交一个任务，返回一个 `Future`对象
③`as_completed`是Python中用于并发编程的工具，可以让你在任务完成的那一刻立即处理结果，而不是按照提交顺序一个个等
```python
from concurrent.futures import as_completed
as_completed(fs, timeout=None)
```
(1)`fs`：一个可迭代的`Future`对象集合（如 `[f1, f2, f3]`）
(2)`timeout`（可选）：最长等待时间（秒），超过这个时间未完成会抛出 `TimeoutError`
(3)return：返回值是一个迭代器，每次迭代会返回已完成的Future对象
④Future对象是一个代表还没完成但将来可能会有结果的任务对象
- `.result()`：获取任务结果（阻塞直到完成）
- `.done()`：判断任务是否已经完成
- `.running()`：判断是否正在运行
- `.cancel()`：尝试取消任务（如果没开始可以取消）
- `.exception()`：获取任务中的异常（如果抛出了）
- `.add_done_callback()`：添加回调函数，任务完成时自动调用

输出：
【第1次运行】
Task 0 is running
Task 1 is running
Task 2 is running
Task 0 done
Task 3 is running
Task 2 done
Task 4 is running
Task 1 done
Task 5 is running
Task 3 done
Task 4 done
Task 5 done
All tasks finished
【第2次运行】
Task 0 is running
Task 1 is running
Task 2 is running
Task 1 done
Task 0 done
Task 3 is running
Task 2 done
Task 5 is running
Task 4 is running
Task 3 done
Task 5 done
Task 4 done
All tasks finished
多线程环境下，执行顺序不是固定的[[lesson4-Threads&Concurrency.pdf#page=30|lesson4-Threads&Concurrency, p.30]]
### 4.5.2 复刻加入[[lesson4-Threads&Concurrency.pdf#page=34|lesson4-Threads&Concurrency, p.34]]
1.fork&join：把主线程拆成多个子任务（fork），等子任务都完成后再合并（join）[[lesson4-Threads&Concurrency.pdf#page=31|lesson4-Threads&Concurrency, p.31]]
2.算法[[lesson4-Threads&Concurrency.pdf#page=32|lesson4-Threads&Concurrency, p.32]]
3.Python复刻加入[[lesson4-Threads&Concurrency.pdf#page=33|lesson4-Threads&Concurrency, p.33]]
```python
import threading
def fork_join_sum(arr):
    if len(arr)<=2:#小任务直接求和
        return sum(arr)
    mid=len(arr)//2
    left_sum=[0]
    right_sum=[0]
    def calc_left():
        left_sum[0]=fork_join_sum(arr[:mid])
    def calc_right():
        right_sum[0]=fork_join_sum(arr[mid:])
    #fork：创建2个进程
    t1=threading.Thread(target=calc_left)
    t2=threading.Thread(target=calc_right)
    t1.start()
    t2.start()
    #join：等待2个子线程完成
    t1.join()
    t2.join()
    return left_sum[0]+right_sum[0]
data=list(range(1,10001))#1-10000
```
①`threading.Thread`是Python中用于创建并运行线程的类，可以用它把一个函数或代码段放到另一个线程中运行，从而实现多任务并发。
```python
import threading
thread = threading.Thread(target=some_function, args=(arg1, arg2, ...))
thread.start()
```
(1)`start()`：启动线程，调用`target`函数
(2)`join()`：阻塞主线程，直到该线程执行完毕
(3)`is_alive()`：检查线程是否还在运行
(4)`getName()`/`setName()`：获取或设置线程名
(5)`daemon=True`：设置为“守护线程”，主线程结束时会强制杀死该线程
### 4.5.3 OpenMP
1.OpenMP
①编译器指令集和用于C，c++，FORTRAN的API
②提供对共享内存环境中并行编程的支持
③创建和CPU核心数量相同的线程个数
④用`#pragma omp parallel`标识可以并行运行的代码块的并行区域

```c
#include<omp.h>
#include<stdio.h>
int main(int argc,char *argv[])
{
    /*sequential code*/
  
    #pragma omp parallel
    {
        printf("I am a parallel region.");
    }
    /*sequential code*/
    
    return 0;

}
```

2.c

```c
#include<omp.h>
#include<stdio.h>
#include<unistd.h>
int main()
{
    int a[5]={1,2,3,4,5};
    int b[5]={10,20,30,40,50};
    int c[5];
    #pragma omp parallel for //让后续代码块被多个线程同时执行
    for(int i=0;i<5;i++)
    {
        c[i]=a[i]+b[i];
        sleep(1);
        printf("%d\n",c[i]);
    }
    return 0;
}
```
输出：
PS D:\MyPython> gcc -fopenmp OpenMP.c -o OpenMP
PS D:\MyPython> .\OpenMP
33
55
11
44
22
PS D:\MyPython> .\OpenMP
11
55
44
33
22
并发线程的执行顺序是非确定性的，每次运行都可能不同
### 4.5.4 大中央调度
jump
### 4.5.5 Intel线程构建模块
jump
## 4.6 多线程问题
### 4.6.1 系统调用fork()和exec()
1.fork()
一些UNIX系统提供了2个版本的fork：复制整个进程/复制调用进程
2.exec()：会替换掉当前进程，包括所有线程
### 4.6.2 信号处理
1.信号是一种软中断机制，是操作系统用来通知进程某个事件发生的一种方式
2.信号处理函数：用于产生信号
①某些事件产生信号
- 用户按下 `Ctrl+C`（SIGINT）
- 程序除以 0（SIGFPE）
- 子进程退出（SIGCHLD）
②内核把信号投递给目标进程
③处理信号：2种信号处理函数
（1）default：系统内置的默认处理方式 。默认处理器是操作系统提供的，作用包括终止进程、忽略、生成core dump等
- `SIGINT` 默认终止进程
- `SIGCHLD` 默认忽略
（2）user-defined：用户自定义处理函数，程序员可以通过`signal()`或`sigaction()`注册自己的处理函数来替代默认行为
3.在单线程程序中，信号由整个进程中的那个线程统一处理；在多线程程序中，信号可能投递给不同的线程
4种处理策略：
①将信号送到与该信号有关的线程
②将信号广播给进程内所有线程
③将信号发送给某些符合条件的线程
④指定某个线程为信号处理线程，所有信号都由它负责处理
### 4.6.3 线程撤销
1.线程撤销：在线程完成之前终止它，要取消的线程是目标线程。
2.方法
①异步取消：立即终止目标线程
②延迟取消：允许目标线程定期检查是否应该取消
3.Pthread-创建并取消一个线程

```c
pthread_t tid;

/*创建线程*/
pthread_create(&tid,0,worker,NULL);

...

/*取消线程*/
pthread_cancel(tid);

/*等待线程终止*/
pthread_join(tid,NULL);
```
4.取消请求≠立即终止线程
①调用线程取消请求取消，但实际取消取决于线程状态
②3种取消模式

| mode        | state    | type        |
| ----------- | -------- | ----------- |
| off         | disabled | -           |
| deferred    | enabled  | deferred    |
| asychronous | enabled  | asychronous |
（1）Off关闭：线程取消功能被关闭，即使有取消请求，也会被挂起等待，不会真正发生，直到线程启用它。
（2）Deferred延迟：默认模式，取消请求会保留，直到线程主动执行某个取消点时才会终止，即取消只在线程到达取消点时发生，然后调用清理处理程序。
e.g.pthread_testcancel()
（3）Asychronous异步：线程会立即终止
5.在Linux系统中，线程取消的底层机制通过信号实现
### 4.6.4 线程本地存储
1.TLS：允许每个线程拥有某个变量的独立副本，其它线程无法访问
2.在无法控制线程创建时非常有用
3.TLS&local局部变量
①TLS在函数调用中可见
②局部变量仅在单个函数调用期间可见

|特性|局部变量|TLS 变量|
|---|---|---|
|生命周期|仅在函数执行期间有效|跨函数调用期间也能访问|
|作用域|当前函数|当前线程全局|
|多线程安全|每次调用独立|每个线程独立|
4.TLS与static静态数据相似，TLS对每个线程是独特的
- 两者都可跨函数访问，不会因为函数调用结束而销毁。
- `static`是全线程共享的
- TLS是每个线程私有的，不会产生数据竞争
e.g.
```c
__thread int counter = 0;  // TLS变量，每个线程有自己的 counter
void* work(void* arg) 
{
    for (int i = 0; i < 3; i++) 
    {
        counter++;  // 操作的是自己线程的副本，每个线程的counter互不影响
        printf("Thread %ld: counter = %d\n", (long)arg, counter);
    }
    return NULL;
}
```
### 4.6.5 调度程序激活
jump
## 4.7 操作系统示例
### 4.7.1 Windows线程
1.Windows API：线程的主要接口。Windows线程管理的主要工具，是用户在 Windows上创建和管理线程的主接口
2.线程映射模型：一对一映射，每个用户线程对应一个内核线程
3.线程结构
①线程id：系统分配的唯一标识符，用于区分不同线程。
②寄存器集合：保存线程当前的CPU状态，用于上下文切换时恢复线程运行状态。
③用户栈&内核栈：Windows 为每个线程分配两个独立的栈，以支持从用户态切换到内核态
（1）用户栈：用户态代码执行时使用的栈
（2）内核栈：当线程执行系统调用、进入内核态时使用的栈
④私有数据存储区：运行时库和DLL动态链接库使用的内存区域，用于存储线程本地变量等
4.线程上下文：寄存器集合+栈（用户栈+内核栈）+私有数据区
5.主要数据结构：ETHREAD→KTHREAD→TEB[[lesson4-Threads&Concurrency.pdf#page=49|lesson4-Threads&Concurrency, p.49]]
①ETHREAD
（1）位于内核空间
（2）结构：指向所属进程的指针+指向KTHREAD的指针
（3）功能：线程的生命周期管理、与进程的关系管理
②KTHREAD
（1）位于内核空间
（2）结构：线程的调度信息+内核栈+指向TEB的指针
（3）功能：线程运行状态、调度与同步机制
③TEB
（1）位于用户空间
（2）结构：线程id+用户栈+线程本地存储
（3）每个线程都有自己的TEB，在用户程序执行时访问
### 4.7.2 Linux线程
1.Linux把线程与进程都称为"task"，并用同一种结构体 `task_struct`表示
2.创建线程方式：`clone()`系统调用
①`clone()`：允许子线程和父线程之间共享资源
②flags标志位：控制子线程和父线程之间共享哪些资源

|flag|meaning|
|---|---|
|`CLONE_FS`|共享文件系统信息（如当前工作目录、root 目录等）|
|`CLONE_VM`|共享同一个内存空间（即代码段、数据段、堆等）|
|`CLONE_SIGHAND`|共享信号处理函数（signal handlers）|
|`CLONE_FILES`|共享已打开文件的文件描述符集合|

3.`struct task_struct`：Linux中描述线程/进程的数据结构
每一个task在Linux内核中都有一个`struct task_struct`结构体来表示
结构：线程/进程id+状态/调度信息+指向内存、文件、信号等子结构体的指针（共享/独有）
#### Quiz
Goggle Chrome浏览器对于每一个页面、每一个插件，都分别用一个进程来进行渲染。如果Chrome设计成为只有一个进程，但是每一个页面和插件都用单独的线程来处理，会有什么好处？会有什么坏处？