## 10.1 背景
#### 虚拟内存
虚拟内存将用户逻辑内存与物理内存分开
好处：
- 只需要将程序的一部分加载到内存中即可执行
- 逻辑地址空间可以远大于物理地址空间[[lesson10-virtual-memory.pdf#page=7&selection=11,0,11,50|lesson10-virtual-memory, p.7]]
- 地址空间可以由多个进程共享
- 更高效的进程创建
- 可以支持更多的并发程序运行
- 更少的 I/O 操作（加载/交换）
#### 虚拟地址空间
进程在内存中的逻辑视图
1.特点
- 通常从地址0开始，一直连续增长到它的逻辑空间结束；实际的物理内存是分散的、按页框组织的
- 内存管理单元MMU将逻辑地址映射为物理地址
- 支持稀疏地址空间
2.实现方式
- 按需分页
- 按需分段
3.共享
- 多个进程共享相同的系统库[[lesson10-virtual-memory.pdf#page=9&selection=11,0,11,35|lesson10-virtual-memory, p.9]]：通过将这些库映射到各自的虚拟地址空间实现
- 共享内存：通过将一段物理内存映射为多个进程的虚拟页，实现共享内存
- `fork()`时页面共享
## 10.2 请求调页
仅在需要时才加载页面
### 10.2.1 基本概念
- 传统方式：在程序启动时就把整个进程加载到内存中
- 请求调页：只在真正需要访问某个页时才加载该页到内存，也包含换入换出[[lesson10-virtual-memory.pdf#page=11&selection=11,0,11,13|lesson10-virtual-memory, p.11]]
	- 换出：Program A 的某些页暂时不需要→从内存中移出→存入磁盘中
	- 换入：Program B的页17、18、19被访问→从磁盘调入内存中
1.优势
- 减少 I/O 操作
- 节省内存
- 提高响应速度
- 支持更多用户或进程
2.页访问机制
- 页号无效-程序终止
- 页号合法但不在内存-触发缺页中断，从磁盘加载该页到内存
3.懒惰换页器：不会主动换入页，只有在真的要用时才换入
#### 换页行为
- 传统：换页器需要预测哪些页将被访问，然后提前加载这些页
- 请求调页：只在页面真正被访问时才加载
1.硬件支持：依赖内存管理单元MMU提供新功能
- 如果访问的页已在内存-无需加载
- 如果访问页不在内存-由MMU触发异常，检测这个访问，将缺失的页从磁盘加载到内存
#### 有效-无效位
- v表示该页在内存中
- i表示该页不在内存中
	- 如果某个虚拟页对应的页表项的有效-无效位是i，就会触发缺页异常
使用页表记录虚拟页到物理帧的映射关系[[lesson10-virtual-memory.pdf#page=14&selection=11,0,13,15|lesson10-virtual-memory, p.14]]
#### 缺页异常
如果某个指令访问了一个虚拟页，而这个页没有驻留在内存中（页表中 valid bit = i），就会触发缺页异常
1.步骤：[[lesson10-virtual-memory.pdf#page=16&selection=11,0,11,30|lesson10-virtual-memory, p.16]]
操作系统会查表判断是非法引用还是合法但页不在内存中
→寻找一个空闲页框
→将需要的页从磁盘加载进这个帧
→更新页表信息
→重新执行触发缺页的指令
2.极端情况-纯按需分页：启动时内存中没有任何页
操作系统将程序计数器设置为第一条指令的虚拟地址，但由于该指令所在的页尚未载入内存，会立刻触发缺页异常。即只有在实际访问页面时才加载页面，一开始什么都不加载
3.一条指令可能访问多个页面
e.g.C=A+B
取指-访问指令所在页
→读取A和B的数据-各访问一个页
→将结果写入C-再访问一个页
→引发多个缺页异常
4.请求调页的硬件支持
- 有效-无效位
- 二级存储
- 指令重启机制
5.缺页异常的局限性：
对于像块移动这样复杂且具有副作用（如地址自增、自减、可能重叠）的指令，重启操作可能不安全或不可恢复，因此操作系统/编译器/硬件设计时需考虑如何支持安全重启或将这类操作拆分为多个原子步骤
### 10.2.2 空闲帧列表
发生缺页时，操作系统通过空闲帧列表来分配物理内存页
空闲帧列表：记录空闲页框地址
按需清零：在将页框分配给用户进程之前，操作系统通常会把页框的内容清零
初始化：开机后，操作系统会将所有可用的物理内存页框都加入到空闲帧列表中， 之后按需使用
### 10.2.3 请求调页的性能
1.发生缺页异常时，系统可能经历的最坏路径流程：
- 触发陷入操作系统
- 保存用户进程寄存器和状态
- 判断此次中断是否是缺页异常
- 检查该页是否合法，并找到磁盘上的位置
- 从磁盘读取该页，放入空闲页框中
	- 等待磁盘设备排队服务
	- 等待磁盘寻道/旋转延迟
	- 读取并传输页面数据
- 在等待 I/O 的过程中，将 CPU 分配给其他进程
- 当磁盘 I/O 完成后，收到中断通知
- 保存当前运行进程（另一个用户进程）的上下文
- 判断此次中断来自磁盘
- 更新页表和其他结构，表示页面已在内存
- 等待 CPU 重新分配给该进程
- 恢复原进程上下文，重新执行触发缺页的指令
2.按需分页的性能分析
①当发生缺页中断时，系统主要涉及以下三个过程：
- 处理中断
- 读取页面-最好事
- 重启进程
缺页错误的处理时间=处理缺页错误中断+读入页面+重新启动进程
②有效访问时间EAT：
p：缺页错误概率∈[0,1]
$有效访问时间=(1-p)*内存访问时间+p*缺页错误时间(处理缺页错误中断+读入页面+重新启动进程)$
很小的缺页率也会极大影响系统性能
## 10.3 写时复制COW
通过允许父进程和子进程最初<font color="#31859b">共享相同的页面</font>（标记为写时复制）来工作
1.写入时才复制：有任意一个进程尝试修改这个共享页面，才会发生真正的复制
~~复制地址空间~~×
复制地址空间的引用√
2.优点：只有被修改的页面才会被复制，进程创建效率高
3.空闲页的分配：用于零填充按需分配页池
4.UNIX：`vfork()`系统调用
e.g.
进程1修改页面C之前的页面状态：[[lesson10-virtual-memory.pdf#page=25&selection=11,0,11,32|lesson10-virtual-memory, p.25]]
进程1修改页面C之前的页面状态：[[lesson10-virtual-memory.pdf#page=26&selection=11,0,11,31|lesson10-virtual-memory, p.26]]

|组件|修改前（上一页）|修改后（本页）|
|---|---|---|
|Page C|被两个进程共享|只被 process₂ 使用|
|Copy of C|不存在|process₁ 得到一份 **Page C 的副本**|
|映射关系|两个进程都指向同一个 Page C|process₁ 指向副本，process₂ 仍指向原始页 C|
## 10.4 页面置换
当没有空闲页框可用时，就需要从内存中找出一些暂时不用的页，将其换出
替换算法&性能问题
### 10.4.1 基本页面置换
#### 流程
- 查找磁盘中目标页的位置：找到所需页面存储在磁盘哪个位置
- 寻找一个空闲帧
	- 如果有空闲帧，直接使用即可
	- 如果没有空闲帧，就必须启用页面置换算法来选择一个牺牲帧
		- 该牺牲页有被修改过（即为脏页），则必须先将它写回磁盘
		- 此时一个缺页错误可能涉及两次页面传输：
		    1. 把脏页写回磁盘；
		    2. 把所需页面从磁盘读入内存。
	        →显著增加有效访问时间EAT，导致系统性能下降
- 将所需页从磁盘中加载进刚才获得的帧中，并且更新页表和帧表的信息
- 重新执行原先导致缺页错误的那条指令
#### 算法
1.帧分配算法：决定如何将内存中的页框分配给各个进程
- 给每个进程分配多少个页框
- 当发生页置换时，替换哪一个页框中的页面
2.页面置换算法：希望在页面首次访问和重新访问时都尽可能减少缺页率
评估：通过在特定<font color="#31859b">内存引用串</font>（引用串）上运行某个置换算法，统计其造成的缺页次数
- 字符串只包含页号而非完整地址
- 重复访问相同的页不会造成缺页
e.g.`7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1`
3.可用帧数量⬆️缺页错误⬇[[lesson10-virtual-memory.pdf#page=32&selection=11,0,11,48|lesson10-virtual-memory, p.32]]
### 10.4.2 FIFO页面置换
置换最旧的页面
<font color="#c00000">最旧：被加载到页框中</font>，不是~~被访问~~
e.g.3个页框
15次替换

| 7                                                 | 0                                                        | 1                                                        | 2                                                        | 0   | 3                                                        | 0                                                 | 4                                                        | 2                                                        | 3                                                        | 0                                                        | 3   | 0   | 3   | 2   | 1                                                        | 2                                                        | 0   | 1   | 7                                                        | 0                                                        | 1                                                        |
| ------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | --- | -------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | --- | --- | --- | --- | -------------------------------------------------------- | -------------------------------------------------------- | --- | --- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- |
| <span style="background:rgba(3, 135, 102, 0.2)">7 | 7                                                        | 7                                                        | <span style="background:rgba(3, 135, 102, 0.2)">2</span> | 2   | 2                                                        | 2                                                 | <span style="background:rgba(3, 135, 102, 0.2)">4</span> | 4                                                        | 4                                                        | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0   | 0   | 0   | 0   | 0                                                        | 0                                                        | 0   | 0   | <span style="background:rgba(3, 135, 102, 0.2)">7</span> | 7                                                        | 7                                                        |
|                                                   | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0                                                        | 0                                                        | 0   | <span style="background:rgba(3, 135, 102, 0.2)">3</span> | 3                                                 | 3                                                        | <span style="background:rgba(3, 135, 102, 0.2)">2</span> | 2                                                        | 2                                                        | 2   | 2   | 2   | 2   | <span style="background:rgba(3, 135, 102, 0.2)">1</span> | 1                                                        | 1   | 1   | 1                                                        | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0                                                        |
|                                                   |                                                          | <span style="background:rgba(3, 135, 102, 0.2)">1</span> | 1                                                        | 1   | 1                                                        | <span style="background:rgba(3, 135, 102, 0.2)">0 | 0                                                        | 0                                                        | <span style="background:rgba(3, 135, 102, 0.2)">3</span> | 3                                                        | 3   | 3   | 3   | 3   | 3                                                        | <span style="background:rgba(3, 135, 102, 0.2)">2</span> | 2   | 2   | 2                                                        | 2                                                        | <span style="background:rgba(3, 135, 102, 0.2)">1</span> |


问题：Belady异常-增加内存页框数，反而导致更多的缺页次数
### 10.4.3 最优页面置换Optimal Algorithm
【开天眼】
置换最长时间不会使用的页面
问题：需要引用串的未来知识
无法实际使用，通常用来评估页面置换算法表现得好不好
e.g.9次替换

| 7                                                        | 0                                                        | 1                                                        | 2                                                        | 0   | 3                                                        | 0   | 4                                                        | 2   | 3   | 0                                                        | 3   | 0   | 3   | 2   | 1                                                        | 2   | 0   | 1   | 7                                                        | 0   | 1   |
| -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | --- | -------------------------------------------------------- | --- | -------------------------------------------------------- | --- | --- | -------------------------------------------------------- | --- | --- | --- | --- | -------------------------------------------------------- | --- | --- | --- | -------------------------------------------------------- | --- | --- |
| <span style="background:rgba(3, 135, 102, 0.2)">7</span> | 7                                                        | 7                                                        | <span style="background:rgba(3, 135, 102, 0.2)">2</span> | 2   | 2                                                        | 2   | 2                                                        | 2   | 2   | 2                                                        | 2   | 2   | 2   | 2   | 2                                                        | 2   | 2   | 2   | <span style="background:rgba(3, 135, 102, 0.2)">7</span> | 7   | 7   |
|                                                          | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0                                                        | 0                                                        | 0   | 0                                                        | 0   | <span style="background:rgba(3, 135, 102, 0.2)">4</span> | 4   | 4   | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0   | 0   | 0   | 0   | 0                                                        | 0   | 0   | 0   | 0                                                        | 0   | 0   |
|                                                          |                                                          | <span style="background:rgba(3, 135, 102, 0.2)">1</span> | 1                                                        | 1   | <span style="background:rgba(3, 135, 102, 0.2)">3</span> | 3   | 3                                                        | 3   | 3   | 3                                                        | 3   | 3   | 3   | 3   | <span style="background:rgba(3, 135, 102, 0.2)">1</span> | 1   | 1   | 1   | 1                                                        | 1   | 1   |

### 10.4.4 <span style="background:rgba(240, 200, 0, 0.2)">LRU页面置换</span>
最近最少使用算法：置换最长时间没有使用的页
<font color="#c00000">使用：上一次被访问</font>，不是~~被加载到页框中~~
e.g.12次替换

| 7                                                        | 0                                                        | 1                                                        | 2                                                        | 0   | 3                                                        | 0   | 4                                                        | 2                                                        | 3                                                        | 0                                                        | 3   | 0   | 3   | 2   | 1                                                        | 2   | 0                                                        | 1   | 7                                                        | 0   | 1   |
| -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | --- | -------------------------------------------------------- | --- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | -------------------------------------------------------- | --- | --- | --- | --- | -------------------------------------------------------- | --- | -------------------------------------------------------- | --- | -------------------------------------------------------- | --- | --- |
| <span style="background:rgba(3, 135, 102, 0.2)">7</span> | 7                                                        | 7                                                        | <span style="background:rgba(3, 135, 102, 0.2)">2</span> | 2   | 2                                                        | 2   | <span style="background:rgba(3, 135, 102, 0.2)">4</span> | 4                                                        | 4                                                        | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0   | 0   | 0   | 0   | <span style="background:rgba(3, 135, 102, 0.2)">1</span> | 1   | 1                                                        | 1   | 1                                                        | 1   | 1   |
|                                                          | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0                                                        | 0                                                        | 0   | 0                                                        | 0   | 0                                                        | 0                                                        | <span style="background:rgba(3, 135, 102, 0.2)">3</span> | 3                                                        | 3   | 3   | 3   | 3   | 3                                                        | 3   | <span style="background:rgba(3, 135, 102, 0.2)">0</span> | 0   | 0                                                        | 0   | 0   |
|                                                          |                                                          | <span style="background:rgba(3, 135, 102, 0.2)">1</span> | 1                                                        | 1   | <span style="background:rgba(3, 135, 102, 0.2)">3</span> | 3   | 3                                                        | <span style="background:rgba(3, 135, 102, 0.2)">2</span> | 2                                                        | 2                                                        | 2   | 2   | 2   | 2   | 2                                                        | 2   | 2                                                        | 2   | <span style="background:rgba(3, 135, 102, 0.2)">7</span> | 7   | 7   |

#### 实现方式
1.计数器：每次内存引用都会递增时钟，置换具有最小时间的页面
问题：需要为每个页维护一个寄存器&置换需要遍历&时钟溢出
2.堆栈：每当页面被引用时，它就从堆栈中移除并放在顶部，置换底部的页面
问题：每次更新费时，但置换不需要搜索

最优页面置换和LRU页面置换属于堆栈算法，无Belady异常
### 10.4.5 近似LRU页面置换
#### 1.额外引用位算法
引用位机制：页表的每个条目关联一个引用位，初始化为0，被引用则置1
缺点：不知道这些引用位为0的页面之间的精确使用顺序
#### 2.第二次机会算法
FIFO+引用位
时钟替换：页面按照环状队列排列，每次替换时时钟指针指向某页并检查它的引用位
- 引用位=0：说明该页近期未被访问，可以直接替换
- 引用位=1：把这个页的引用位设为0，然后保留该页，移动指针继续检查下一个页，对下一个页重复上述规则
#### 3.增强型第二次机会算法
将引用位和修改位作为有序对
优先级从高到低：
- (0,0)-最近没有使用且没有修改-最佳的页面置换
- (0,1)-没被最近使用，但已被修改
- (1,0)-最近被使用，未被修改
- (1,1)-最近被使用，且已被修改
每当要进行页替换时：
- 用时钟算法扫描环形页队列；
- 按照上述四个类别的优先级查找可以替换的页；
- 选择最低非空类别中的一个页进行替换；
- 可能需要循环扫描多次，才能找到符合条件的页面。
### 10.4.6 基于计数的页面置换
不常用
为每个页面维护一个引用计数器，记录该页被访问的总次数
1.最不经常使用LFU：替换访问次数最少的页（计数值最小）
- 如果一个页在过去几乎没被访问过，那将来可能也不会再用
2.最经常使用MFU：替换引用次数最多的页（计数值最大）
- 引用次数小的页可能是刚刚加载进来的新页，还没来得及被访问；
- 引用次数高的页，可能已经使用完它的生命周期
### 10.4.7 页面缓冲算法
核心思想：始终保留一组空闲帧
- 当页面发生缺页时可以立即使用空闲帧，无需临时淘汰已有页面再空出帧，提升响应速度
- 把新页读入空闲帧→选择一个牺牲页淘汰出去，将其加入空闲帧池中→当系统空闲时再慢慢淘汰牺牲页，延迟淘汰
可能会维护一个已修改页/脏页列表
- 脏页：被修改但尚未写回磁盘的页
- 当磁盘处于空闲时，后台进程可以将这些脏页异步写回磁盘，清为非脏页
可能会保留已被替换帧的内容不立即清除
- 如果这些帧在再次被访问之前没有被重用，可以直接恢复，无需再次从磁盘加载
- 降低错误淘汰带来的惩罚
### 10.4.8 应用程序与页面置换
某些应用程序比操作系统更了解自己的内存访问模式
问题：双重缓冲-同一页数据被系统和应用重复缓存了一次
- 操作系统会将页缓存一份，作为 I/O 缓冲区
- 应用程序也会将页缓存一份，作为业务处理数据
解决方案：原始磁盘模式-操作系统允许应用程序直接访问磁盘，不再插手，这样应用可以自行控制磁盘读写、缓存、锁管理等
**Quiz**
假设一个操作系统的内存管理采用分页机制，页大小为4KB，系统中有以下页面访问序列：
1，2，7，9，1，2，5，1，9，3，7，5
内存容量为3个页帧，初始时内存为空，请使用FIFO/LRU/Optimal页面置换算法计算缺页次数

1.FIFO：11次

| 1   | 2   | 7   | 9   | 1   | 2   | 5   | 1   | 9   | 3   | 7   | 5   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 1   | 9   | 9   | 9   | 5   | 5   | 5   | 5   | 7   | 7   |
|     | 2   | 2   | 2   | 1   | 1   | 1   | 1   | 9   | 9   | 9   | 5   |
|     |     | 7   | 7   | 7   | 2   | 2   | 2   | 2   | 3   | 3   | 3   |
2.LRU：11次

| 1   | 2   | 7   | 9   | 1   | 2   | 5   | 1   | 9   | 3   | 7   | 5   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 1   | 9   | 9   | 9   | 5   | 5   | 5   | 5   | 7   | 7   |
|     | 2   | 2   | 2   | 1   | 1   | 1   | 1   | 9   | 9   | 9   | 5   |
|     |     | 7   | 7   | 7   | 2   | 2   | 2   | 2   | 3   | 3   | 3   |

3.Optimal：7次

| 1   | 2   | 7   | 9   | 1   | 2   | 5   | 1   | 9   | 3   | 7   | 5   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 3   | 3   | 3   |
|     | 2   | 2   | 2   | 2   | 2   | 5   | 5   | 5   | 5   | 5   | 5   |
|     |     | 7   | 9   | 9   | 9   | 9   | 9   | 9   | 9   | 7   | 7   |
## 10.5 帧分配
### 10.5.1 帧的最小数
每个进程运行时至少需要分配一些帧才能正常执行
### 10.5.2 分配算法
1.平均分配
2.按比分配：根据各个进程的大小占比来分配页框数
### 10.5.3 全局分配与局部分配
1.全局置换：某个进程在发生缺页时，可以从系统中所有可用的页框中选择一个进行替换。也就是说，它可以抢占其他进程的页框。
- 优点：系统整体吞吐量更高
- 缺点：进程执行时间不稳定，受其他进程影响大
2.局部置换：进程只能从自己已经分配的页框中选择一个来置换，不会干扰其他进程的内存
- 优点：每个进程的性能更一致、更可控，系统响应更稳定
- 缺点：可能会出现内存资源未充分利用的情况
#### 回收页
一种实现全局页置换策略的方式
- 所有内存请求都从空闲帧列表中满足，而不是等到空闲帧用完才开始进行页面置换
- 当空闲帧列表下降到某个阈值以下时，就会触发页置换操作
- 目的：确保系统始终有足够的空闲内存来响应新的请求
``` markdown 
1. 空闲页不断被使用 → free memory 下降
2. 降至 minimum threshold → 启动页回收
3. 回收释放内存 → free memory 上升
4. 达到 maximum threshold → 停止页回收
5. 重复以上过程
```
### 10.5.4 非均匀内存访问NUMA
1.NUMA是一种多处理器系统架构，在这种架构中, 每个CPU有自己直接连接的局部内存, 访问本地内存速度快,访问其他CPU的内存需要通过系统互联，速度慢。
2.为了优化NUMA架构下的性能，应该尽量将内存分配到与线程所运行CPU接近的位置
Solaris操作系统通过创建延迟组lgroups来解决这个问题
## 10.6 抖动
抖动：进程忙于频繁地进行页的交换
### 10.6.1 抖动的原因
如果一个进程没有足够的页面，它的缺页率会非常高
缺页错误时，系统从磁盘中调入需要的页，为此可能会替换掉已有的页面，但很快又需要用回被替换掉的页面，这会导致：
- CPU利用率很低
- 操作系统误以为系统并发度不够（即多道程序程度太低），于是错误地添加更多进程到系统中，进一步加剧问题
1.请求调页按需加载页，不会频繁缺页：局部性模型
进程会从一个局部区域迁移到另一个局部区域，局部区域之间可能会重叠
程序在运行过程中，大多数时间只会访问一小部分内存（局部性区域），所以即使只加载部分页也够用了
2.抖动的原因：所有进程的当前活跃局部区域的总大小超过了系统的总内存大小
3.限制抖动的影响：
- 局部页替换：每个进程只能替换自己占用的页，避免一个进程影响到其他进程
- 优先级页替换：根据进程的重要性决定谁可以保留更多页面
### 10.6.2 工作集模型
$\Delta$：工作集窗口-一个固定长度的页面访问窗口，表示最近参考过的页面数
$WSS_i$：第i个进程的工作集-在最近$\Delta$条指令内，进程$P_i$实际访问的页面总数(随时间变化)
- $\Delta$太小-无法包含整个局部性区域
- $\Delta$太大-可能包含多个局部性区域
$D=\sum WSS_i$：系统的总需求帧数-所有进程的工作集之和，表示当前系统需要多少物理页帧来维持正常运行
- D>系统物理内存-系统将开始抖动
	- 应暂停某些进程/换出某些进程
- D≤系统物理内存-系统运行流畅
### 10.6.3 缺页错误频率
建立一个可接受的缺页率PFF，并使用局部页面置换算法
- 如果实际缺页率太高（>上界）：表示内存不够，给该进程分配更多页帧
- 如果实际缺页率太低（<下界）：表示内存分配太多了，收回一部分页帧
#### 缺页率&工作集
- 一个进程的工作集大小与它的缺页率之间存在直接关系
- 工作集是随时间变化的，不是固定不变的
- 缺页率会随着程序执行过程中的访问模式波动，呈现峰值和谷值
## 10.8 分配内核内存
内核内存与用户内存的处理方式不同，通常从空闲内存池中分配
- 内核会请求用于不同大小结构体的内存
- 有些内核内存必须是连续的
	- 例如，用于设备I/O
### 10.8.1 伙伴系统
1.核心机制：从固定大小的段中分配内存，这些段由物理上连续的页面组成  
- 采用2的幂次分配器进行内存管理：
    - 所有内存请求都满足为2的幂次大小（如 2KB、4KB、8KB…）
    - 每个请求会被向上取整到下一个 2 的幂，比如请求 21KB 会变成 32KB。
    - 若当前内存块太大，会一分为二，变成两个伙伴块，直到得到合适大小的块为止
    - 这个分割过程会递归进行，直到合适大小被找到。
e.g.假设系统中有一个256KB的空闲内存块，内核现在请求21KB：
- 先将256KB分成两个伙伴：$A_L$和$A_R$，每个是128KB
- 再将其中一个继续分为$B_L$和$B_R$，各为 64KB
- 再将其中一个继续分为$C_L$和$C_R$，各为 32KB
- 最终选择其中一个32KB块来满足21KB的请求（因为32是比21更小的最小的2的幂）
3.优点：可以快速合并未使用的伙伴块，当两个伙伴块都空闲时，可快速合并为更大的块，对提高内存利用率和减少碎片有帮助。
4.缺点：碎片化问题依然存在，尤其是内部碎片
### 10.8.2 slab分配
一种替代的内存分配策略
- Slab（板块）：由一个或多个物理连续的页面组成。
- Cache（缓存）：由一个或多个slab组成，是slab的集合。
1.slab分配器结构：系统中每一种内核数据结构会有一个对应的cache，每个cache都用来装特定类型的对象，即该数据结构的实例。
2.工作流程：
- 创建cache时：会预先在slab中放入多个对象，标记为空闲
- 当需要用到对象时：从slab中拿出一个对象，把它标记为已使用，并用于存储数据结构      
- 当当前slab已满（对象全被占用）时：
    - 若还有空闲的slab，就从中分配；
    - 如果所有slab都满了，就新建一个slab来继续分配。
3.优点
- 无碎片：对象都是固定大小，避免了内存碎片。  
- 快速响应请求：由于提前初始化好对象池，分配只需要更新指针状态，速度非常快。