## 5.1 基本概念
调度算法的目的：在I/O突发发生时，让CPU找到别的进程继续干活，从而提升CPU利用率
### 5.1.1 CPU-I/O突发周期
1.多道程序设计（多个进程同时处于ready/waiting状态）可以最大化 CPU 利用率
2.进程执行包括周期地进行CPU执行和I/O等待
CPU突发1→I/O突发1→CPU突发2→I/O突发2→...[[lesson5-scheduling.pdf#page=4&selection=11,0,11,14|lesson5-scheduling, p.4]]
CPU突发：进程使用CPU进行计算
I/O突发：进程等待I/O
3.CPU突发时长直方图：大量短CPU突发，少量长CPU突发[[lesson5-scheduling.pdf#page=5&selection=11,0,13,11|lesson5-scheduling, p.5]]
### 5.1.2 CPU调度程序
CPU空闲时，os应从就绪队列（多种）中选择一个进程来执行。进程选择采用CPU调度程序，调度程序从内存中选择一个能够执行的进程，并为其分配CPU。

### 5.1.3 抢占式和非抢占式调度
1.需要进行CPU调度的情况：
①运行→等待
②运行→就绪
③等待→就绪
④终止
①④必须调度，选择执行一个新进程
②③有选择

2.非抢占的/协作的调度方案：调度只能发生在①④情况下
一旦CPU被分配给一个进程，这个进程就会一直持有CPU，直到它通过终止或切换到等待状态来释放它

3.抢占的调度方案
①Win、macos、linux、UNIX
②当多个进程共享数据时，抢占调度可能导致竞争情况；抢占影响操作系统的内核设计
### 5.1.4 分派程序
1.分派程序/分派器：用于将CPU核控制权交给CPU调度器选择的进程的模块
功能：
①切换上下文：保存当前进程P0的上下文（状态）到它的PCB（进程控制块），恢复即将运行的进程P1的上下文
②切换到用户模式
由于调度和切换在内核模式下完成，需要切换到用户模式，让用户进程开始执行用户代码
③跳转到用户程序的合适位置，以便继续执行程序
2.分派延迟：分派程序停止一个进程而启动另一个所需的时间[[lesson5-scheduling.pdf#page=9&selection=11,0,11,10|lesson5-scheduling, p.9]]

## 5.2 调度准则
1. CPU利用率：尽量让CPU保持繁忙状态
2. 吞吐量：单位时间内完成的进程数量
3. 周转时间：执行特定进程的时间量
4. 等待时间：进程在就绪队列中等待的时间
5. 响应时间：从提交请求到生成第一个响应所花费的时间

目标：最大化12，最小化345
条件互斥的情况：e.g.死循环-CPU利用率↑&&等待时间↑
## 5.3 调度算法
#### 一、FCFS先到先服务调度
先请求CPU的进程首先分配到CPU
1.缺点：平均等待时间长
2.护航效应：一个长CPU突发的进程位于就绪队列最前端，导致所有后续短作业不得不等待它完成，从而使系统整体性能下降（包括平均等待时间增加、CPU利用率降低、吞吐量下降）
#### 二、SJF最短作业优先调度
1.SJF：当CPU变为空闲时，它会被赋给具有最短CPU突发的进程。如果两个进程具有同样长度的CPU突发，那么可以由FCFS来处理
2.SJF调度算法是最优的，但不能在CPU调度上加以实现
3.得到下次CPU突发的长度的方法
①近似SJF调度：指数平均值[[lesson5-scheduling.pdf#page=16&selection=11,0,11,36|lesson5-scheduling, p.16]]
![[Pasted image 20251114160141.png]]
②估算
4.抢占SJF调度/最短剩余时间优先调度：如果新进程的下次CPU突发＜当前运行进程的尚未完成的CPU突发→抢占当前运行进程
5.非抢占SJF调度：允许当前运行的进程先完成CPU突发
#### 三、RR轮转调度
1.RR：每个进程获得一个小的CPU时间单位（时间配额/时间片q），通常为10-100毫秒。在此时间过去之后，该进程被抢占并添加到就绪队列的末尾。
如果就绪队列中有n个进程，时间量为q，则每个进程一次最多获得q个时间单位的块，占CPU时间的1/n。没有进程等待超过（n-1）q个时间单位。
计时器中断每个量子来调度下一个进程。
- q大-FCFS
- q小-RR
2.RR算法-抢占的
3.周转时间↑
#### <span style="background:rgba(240, 200, 0, 0.2)">四、优先级调度</span>
1.每个进程都有一个优先级号（整数）。CPU分配给具有最高优先级的进程（最小整数=最高优先级/最低优先级）。
2.SJF是优先级调度，其中优先级是预测下一次CPU突发时间的倒数
3.主要问题：无穷堵塞/饥饿-低优先级进程可能永远不会执行
4.解决方案：老化-随着时间的推移，增加流程的优先级
**Quiz**

| 进程  | 执行时间 | 优先级 |
| --- | ---- | --- |
| p1  | 2    | 2   |
| p2  | 1    | 1   |
| p3  | 8    | 4   |
| p4  | 4    | 2   |
| p5  | 5    | 3   |
顺序：12345
数字越大优先级越高
①FCFS
p1等0s
p2等2s
p3等3s
p4等11s
p5等15s
avg=31/5=6.2s
②非抢占SJF
p2等0s
p1等1s
p4等3s
p5等7s
p3等12s
avg=23/5=4.6s
③非抢占优先级
p3等0s
p5等8s
p1等13s
p4等15s
（优先级相同：FIFS）
p5等19s
avg=55/5=11s
④RR（时间片=2）
p1-2s-等0s
p2-1s-等2s
p3-2s-等3s
p4-2s-等5s
p5-2s-等7s
p3-2s-等9s
p4-2s-等11s
p5-2s-等13s
p3-2s-等15s
p5-1s-等17s
p3-2s-等18s

p1-等0s
p2-等2s
p3-等45s
p4-等16s
p5-等37s
avg=100/5=20s
#### 五、多级队列调度
1.不同类型的进程需求不同→把就绪队列分成多个独立的队列，不同队列之间使用不同的调度策略，并且队列之间也有优先级。
2.永远从最高优先级的非空队列中调度进程。
e.g.实时进程→系统进程→交互进程→批处理进程
3.进程进入系统时被永久地分配到某个队列
4.特点：开销低，但不够灵活
#### 六、多级反馈队列调度
1.允许进程在队列之间迁移
2.参数：
- 队列数量
- 每个队列的调度算法
- 用以确定何时升级到更高优先级队列的方法
- 用以确定何时降级到更低优先级队列的方法
- 用以确定进程在需要服务时将会进入哪个队列的方法
3.如果低优先级进程等太久，可以自动提升它的优先级，避免饥饿；太复杂
## 5.4 线程调度
跳过
## 5.5 多处理器调度
多处理器适用于多核CPU、多线程核、NUMA系统、异构多处理等系统架构
#### 一、多处理器调度的方法
1.非对称多处理：让一个处理器处理所有调度决定、I/O处理以及其它系统活动，其他的处理器只执行用户代码
缺点：主服务器可能成为降低整体系统性能的瓶颈
2.（标准方法）SMP对称多处理：每个处理器都是自调度的。通过让每个处理器的调度程序检查就绪队列，并选择要运行的线程来进行调度
组织符合调度条件的线程的策略：[[lesson5-scheduling.pdf#page=33&selection=11,0,13,20|lesson5-scheduling, p.33]]
①所有线程可能在一个共同的就绪队列中
简单；锁竞争
②（最常用方法）每个处理器可能有自己的私有线程队列
避免锁竞争；必须实现负载均衡
#### 二、多核处理器
1.多核处理器：将多个处理器放置在同一个物理芯片上
采用多核处理器的SMP系统比采用单核处理器的SMP系统速度更快、功耗更低
2.调度问题
①内存停顿：当一个处理器访问内存时，它花费大量时间等待所需数据[[lesson5-scheduling.pdf#page=34&selection=37,0,39,16|lesson5-scheduling, p.34]]
②弥补：采用多线程的处理器核[[lesson5-scheduling.pdf#page=35&selection=22,0,23,6|lesson5-scheduling, p.35]]-每个核会被分配到≥2个硬件线程→如果一个线程停顿而等待内存，该核可以切换到另一个线程
芯片多线程[[lesson5-scheduling.pdf#page=36&selection=40,0,40,30|lesson5-scheduling, p.36]]：每一个硬件线程似乎作为一个逻辑处理器，以便运行软件线程
e.g.处理器包含4个计算核心，每个核心包含2个硬件线程→有8个逻辑CPU
## 5.6 实时CPU调度
跳过
## 5.7 操作系统示例
#### 5.7.1 示例：Linux调度
1.发展
①2.5版本之前Linux内核采用传统UNIX调度算法
②2.5版本采用了O(1)调度算法
③2.6.23版本采用完全公平调度程序CFS
CFS调度程序为每个任务分配一定比例（根据友好值-20-+19，友好值越低优先级越高）的CPU处理时间
2.Linux系统的调度基于调度类
①每一个类都有一个特定优先级
②调度程序从最高优先级调度类中选择具有最高优先级的任务
3.Linux标准内核实现2个调度类
①采用CFS调度算法的默认调度类
②采用CFS调度算法的实时调度类
4.根据POSIX标准实现实时调度
①实时任务的优先级固定
②Linux优先级范围
（1）实时任务：0-99（0=最重要的实时任务）
（2）正常任务：100-139（139=最低优先级的普通任务）
友好值映射：-20→100；+19→139
## 5.8 算法评估
首要问题：为算法选择定义准则
### 5.8.1 确定性模型
确定性模型是一种分析评估类型，采用特定的预先确定的负荷，计算在给定负荷下每个算法的性能
### 5.8.2 排队模型
1.CPU和I/O的执行分布是可以确定的，可以测量，然后近似或简单估计，得到数学公式，用于表示特定CPU突发的分布
2.排队网络分析：已知到达率、服务率，计算利用率、平均队列长度、平均等待时间
3.Little公式：$n=\lambda \times W$
n：平均队列长度
W：队列的平均等待时间
$\lambda$：新进程到达队列的平均到达率
离开队列的进程数量必须=到达进程的数量→Little公式
e.g.平均每秒7个进程到达，队列里通常有14个进程→进程的平均等待时间为2s
### 5.8.3 仿真

### 5.8.4 实现

