## 14.1 文件系统结构
- 文件的结构：文件是逻辑上的存储单位
- 文件系统存在于二级存储（磁盘）上
	- 向用户提供访问存储的接口
	- 负责把逻辑结构映射到物理结构
- 磁盘支持原地重写和随机访问
- I/O 传输以块为单位，块由多个扇区组成，扇区通常是 512 字节
- 文件控制块FCB：保存一个文件的所有元信息
- 设备驱动程序直接控制磁盘等物理设备
- 文件系统分层（从上到下）：
	- 应用程序
	- 逻辑文件系统
		- 管理**元数据**
		- 通过维护**文件控制块**（UNIX 中为 inode）将文件名转换为文件编号、文件句柄、文件位置
	- 文件组织模块
		- 理解文件、物理地址、物理块
		- 将**逻辑块号**转换为**物理块号**
	- 基本文件系统
		- 把块级请求转化为 I/O 请求
		- 负责管理内存缓冲区和缓存（分配、释放、替换）
	- I/O控制
		- **设备驱动程序**在 **I/O 控制层** 管理 I/O 设备，设备驱动向硬件控制器输出**底层的、与具体硬件相关的命令**
	- 设备
## 14.2 文件系统操作
靠磁盘上的结构和内存中的结构共同实现系统调用
- 启动控制块：包含从该卷启动操作系统所需的信息
	- 如果某个卷中包含操作系统，则需要这个结构
	- 通常放在该卷的第一个块中
- 卷控制块/超级块/主文件表：包含整个卷的详细信息
- 目录结构负责组织文件，包含文件名和 inode 编号，以及主文件表信息
#### 磁盘上的结构：FCB
包含许多关于文件的详细信息
~~保存文件内容~~
保存：
- **inode number**（inode 编号）
- **permissions**（权限）
- **size**（大小）
- **dates**（时间戳）
#### 内存中的结构
- 挂载表（os）：用于存储文件系统的挂载信息
- 系统级打开文件表（os）：包含每个被打开文件的 FCB 副本，以及其它信息
- 每个进程的打开文件表（进程）：包含指向系统级打开文件表中对应项的指针，以及其他信息
## 14.4 <span style="background:rgba(240, 200, 0, 0.2)">分配方法</span>
如何为文件分配磁盘块
### 14.4.1 连续分配
每个文件占用一组连续的块
优点：
- 性能好
- 简单
缺点：
- 需要为新文件找到空间
- 需要预先知道文件大小
- 产生外部碎片
### 14.4.2 链接分配
每个文件都是块的链表，块之间通过“**指针**”连接
优点：
- 没有外部碎片
- 提高效率
缺点：
- 可能导致内部碎片
- 可靠性差
- 不能有效支持文件的直接访问，定位某个块可能需要多次 I/O 和磁盘寻道
#### 变种-FAT：文件分配表
每个索引对应磁盘块号，每个值表示下一个块号
### 14.4.3 索引分配
每个文件都有自己的索引块，里面保存了所有数据块的指针
### 14.4.4 性能
链式分配适合顺序访问，不适合随机访问

## 14.5 空闲空间管理
>如何记录哪些磁盘块是空的、可以分配的
### 14.5.1 位向量
- $block[i]空闲:bit[i]=1$
- $block[i]被分配:bit[i]=0$
#### 查找空闲块
$第一个空闲块的号码=每个字的位数*值为0的字数+第一个值为1的偏移$
### 14.5.2 链表
将所有空闲块用链表链接起来,每个空闲块记录下一个空闲块的地址

（ZFS不考）
## 14.6 效率与性能
### 14.6.1 效率影响因素
- 磁盘分配与目录算法：指的是操作系统如何分配文件在磁盘上的空间，例如：
    - 连续分配
    - 链接分配
    - 索引分配
这些算法会直接影响文件读写的速度和碎片化程度。
        
- 目录项中存储的数据类型  
    不同文件系统可能在目录项中包含：
    - 文件名、大小、创建时间、权限等元数据
    - 甚至可能包含部分或全部的物理地址信息  
        保存越多信息，访问文件时越快，但目录项也越大，占用更多内存。
        
- 元数据结构的分配方式
    - 预分配：文件刚创建时就分配足够的元数据空间（如 i-node）
    - 按需分配：只有在需要时才扩展元数据结构（如增长的索引块）  
        预分配更快但可能浪费空间，按需更节省但可能增加访问延迟。
        
- 数据结构的大小类型
    - 固定大小：便于管理和索引，但浪费空间
    - 可变大小：更节省空间但管理更复杂

### 14.6.2 性能
- 缓冲区缓存
- 同步写：按磁盘子系统接受顺序进行，不缓冲写入
- 异步写【常见】：将数据存在缓存后，就将控制返回给调用者

- **将数据和元数据靠近放置（Keeping data and metadata close）**  
    这样可以减少磁盘寻道时间，提升访问效率（尤其在 HDD 上）。
    
- **缓冲区缓存（Buffer cache）**
    
    - 是主内存中专门用于保存常用磁盘块的区域。
        
    - 通过缓存热数据块，减少对磁盘的频繁访问，提高效率。
        
- **同步（Synchronous）与异步（Asynchronous）写入**
    
    - **同步写（Synchronous）**：写入数据后必须真正落盘才能返回成功，对应“无缓存写”。
        
        - 安全但慢，常用于数据库、日志系统。
            
    - **异步写（Asynchronous）**：写操作只写到缓存即可，不需要马上落盘。
        
        - 更快，常用于一般文件系统操作。
            
- **Free-behind 与 Read-ahead 技术**（顺序访问优化）
    
    - **Free-behind**：读取完某数据块后立即从缓存中释放，节省空间。
        
    - **Read-ahead**：在读取当前块的同时预取后续块，提高顺序读效率。
        
- **读比写慢（Reads frequently slower than writes）**  
    在某些文件系统/存储介质中（尤其是传统磁盘），**读操作**因需多次寻址或等待旋转而较慢，系统常通过缓存和预读优化读取速度。

##### 页面缓存：采用虚拟内存技术，将文件数据按页面缓存
- 内存映射 I/O（将文件映射到进程虚拟地址空间）直接使用页缓存，访问更快
- 常规I/O使用缓冲区缓存
##### 统一缓冲区缓存：统一MMIO和正常IO
使用同一个页缓存来缓存：
- 内存映射I/O中用到的页
- 以及传统的文件系统 I/O（如 `read()`、`write()`）中的数据块
## 14.7 恢复
### 14.7.1 一致性检查
将目录结构的数据和其他元数据与存储状态进行比较，若发现不一致，则尝试自动修复
### 14.7.2 基于日志的文件系统
执行/未执行
事物：实行特定任务的一组操作
1. 核心思想：所有更新都写入日志
- 每次对文件系统的元数据的更改都以事务的形式写入一份日志
- 日志以顺序方式写入磁盘，效率更高。
2. 写入过程：两步式
- 先将事务写入日志→表示提交完成
- 然后，异步地将数据真正写入文件系统结构。
    - 写入文件系统后，对应事务就可以从日志中清除了。
3. 崩溃恢复
- 如果系统崩溃，日志中尚未完成的事务**仍保留**。
- 系统重启后，扫描日志，**重做未完成的事务**，恢复文件系统的一致性。
4. 优点
- 崩溃恢复更快（只需重做日志）
- 避免了元数据不一致的风险
- 日志可放在独立设备或磁盘区域，进一步优化性能和隔离性