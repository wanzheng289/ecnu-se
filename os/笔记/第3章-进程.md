## 3.1 进程的概念
操作系统执行作为进程运行的各种程序
### 3.1.1 进程概述
1.进程：正在执行的程序。进程执行必须以顺序方式进行。单个进程的指令不能并行执行
2.进程的内存布局：[[lesson3-processes.pdf#page=6|lesson3-processes, p.6]]
- 当前活动：包括程序计数器、处理器寄存器
- 栈段：包含调用函数时的临时数据（函数参数；返回地址；局部变量）
- 堆段：包含在程序运行时动态分配的内存
- 数据段：包含全局变量（大小固定）
- 文本段：包含可执行代码（大小固定）
3.进程&程序：
- 进程是活动实体
- 程序时被动实体
- 程序→进程：当一个可执行文件被加载到内存时
	- 方法：双击一个代表可执行文件的图标/在命令行上输入可执行文件的名称
- 多个进程可与同一程序相关联
4.C程序的内存布局[[lesson3-processes.pdf#page=7&selection=11,0,11,28|lesson3-processes, p.7]]
### 3.1.2 进程状态[[lesson3-processes.pdf#page=9&selection=11,0,11,24|lesson3-processes, p.9]]
- 新建：进程正在创建
- 运行：指令正在执行
- 等待：进程等待发生某个事件
- 就绪：进程等待分配处理器
- 终止：进程已经完成执行
### 3.1.3 进程控制块PCB[[lesson3-processes.pdf#page=10&selection=11,0,11,27|lesson3-processes, p.10]]
1.进程控制块包含许多与某个特定进程相关的信息：
- 进程状态：新建/就绪/运行/等待/停止
- 程序计数器：表示进程将要执行的下个指令的地址
- CPU寄存器：累加器、索引寄存器、堆栈指针、通用寄存器、其他条件码信息寄存器
- CPU调度信息：进程优先级+调度队列的指针+其它调度参数
- 内存管理信息：基址+界限寄存器的值、页表、段表
- 记账信息：CPU时间、实际使用时间、时间期限、记账数据、作业、进程数量
- I/O状态信息：分配给进程的I/O设备列表、打开文件列表
2.Linux使用`task_struct`表示进程控制块，使用`task_struct`的双向链表表示所有活动的进程[[lesson3-processes.pdf#page=12&selection=17,0,115,10|lesson3-processes, p.12]]
### 3.1.4 线程
见第4章
线程独有stack，共享heap、data、text
## 3.2 进程调度
1.目标：最大化CPU利用率&&在进程间快速切换CPU核
2.实现：进程调度器-从多个可用进程集合中选择一个可用进程到CPU核上执行，每个CPU核一次只能运行一个进程
3.多道程序的程度：当前内存中的进程数量
4.进程的类型
（1）I/O密集型程序：花费在I/O上的时间多于花费在计算上的时间
（2）CPU密集型程序：很少生成I/O请求，而是使用更多的时间进行计算

### 3.2.1 调度队列[[lesson3-processes.pdf#page=15&selection=11,0,11,21|lesson3-processes, p.15]]
进程在各个队列之间迁移
基于链表：头节点的2个指针指向链表的第一个PCB块和最后一个PCB块；每个PCB块的指针指向队列的下一个PCB
1.就绪队列：驻留在主存中的所有进程的集合，准备好并等待执行
2.等待队列：等待某个事件发生的集合
3.进程在CPU上执行期间可能会因为以下事件而被切换状态
①I/O请求：当前进程请求I/O设备→从CPU进入I/O等待队列→I/O完成后进入就绪队列，等待重新被调度
②时间片耗尽：当前进程用完了分配的时间片→从CPU进入就绪队列，等待重新被调度
③创建子进程：当前进程创建子进程→从CPU进入子进程终止等待队列→子进程终止→父进程进入就绪队列
④等待中断：当前进程从CPU进入中断等待队列→中断发生→进程进入就绪队列

### 3.2.2 CPU调度
1.CPU调度器：从就绪队列的进程中进行选择，并为其中之一分配一个CPU核
2.交换：一种中间形式的调度（见第9章）
### 3.2.3 上下文切换
当CPU从一个进程切换到另一个进程时，就会发生上下文切换[[lesson3-processes.pdf#page=17&selection=11,0,11,34|lesson3-processes, p.17]]
1.切换过程：
$P_0$执行→发生中断或系统调用→os将$P_0$的CPU执行状态保存在$PCB_0$中，从$PCB_1$中读取保存的状态以恢复$P_1$的上下文→$P_1$执行，$P_0$转入空闲状态
→发生中断或系统调用→os将$P_1$的CPU执行状态保存在$PCB_1$中，从$PCB_0$中读取保存到状态以恢复$P_0$的上下文→$P_0$执行，$P_1$转入空闲状态
2.上下文切换的时间是纯粹的开销，应避免上下文切换
3.移动系统的多任务处理
①ios：前台应用程序&后台应用程序
②安卓：应用程序使用服务进行后台处理
### 3.3.1 进程创建
os提供进程创建&进程终止的功能
1.父进程→创建子进程→...→进程树[[lesson3-processes.pdf#page=26&selection=11,0,11,29|lesson3-processes, p.26]]
初始进程systemd的pid=1
2.os通过进程标识符pid识别进程
3.资源分配选择：
①父进程和子进程共享所有资源
②子进程从父进程获得资源子集
③父进程和子进程不共享资源
4.创建新进程时的执行可能：
①父进程和子进程并发执行
②父进程等待，直到某个或全部子进程执行完
5.地址空间
①子进程在创建时会复制父进程的整个地址空间（包括代码段、堆、栈等）
②子进程也可以通过 `exec()` 系统调用，将自身的内存空间替换为另一个程序的内容，即运行一个新的程序
e.g.UNIX os[[lesson3-processes.pdf#page=22&selection=27,0,27,13|lesson3-processes, p.22]]
①`fork()`用于创建子进程
创建后，父进程和子进程会从`fork()`返回处继续执行
父进程中`fork()`返回子进程的pid，子进程中`fork()`返回0
②`exec()`：子进程调用后，会用新的程序替换自己的进程映像（pid不变）
③`wait()`：父进程调用后阻塞自己直到某个子进程执行完毕（调用 `exit()`）并终止，防止父进程早于子进程退出/产生僵尸进程
### 3.3.2 进程终止
1.终止：进程执行完最后一条语句&&通过系统调用`exit()`请求os删除自身时终止。
①进程通过`wait()`将状态值返回到父进程
②进程的资源由os释放并回收
2.父进程终止子进程的执行：`abort()`
原因：
①子进程使用了超过它所分配的资源
②分配给子进程的任务不再需要
③父进程正在退出，而且os不允许无父进程的子进程继续执行
3.级联终止：一个进程终止，那么该进程的所有子进程都终止。
由os启动。
3.父进程等待子进程终止：`wait()`，返回状态信息和终止进程的pid
`pid=wait(&status)`
4.僵尸进程&孤儿进程
①僵尸进程：进程已经终止但其父进程尚未调用`wait()`
②孤儿进程：父进程没有调用`wait()`就终止，子进程变为孤儿进程
### Android进程的重要性层次结构
最重要→最不重要：
- 前台进程
- 可见进程
- 服务进程
- 后台进程
- 空进程
当系统必须终止进程以使资源可用于新的或更重要的进程时，它会按照重要性增加的顺序终止进程
### 多进程架构-谷歌浏览器
## 3.4 进程间通信IPC
1.os内的并发执行进程的类型
①独立的：不与任何其他进程共享数据
②协作的：能影响其他进程/受其他进程影响
2.要求提供允许进程协作的环境的原因：
①信息共享
②计算加速
③模块化
④便利性
3.进程间通信IPC：协作进程需要IPC机制以允许进程相互交换数据
两种模型[[lesson3-processes.pdf#page=32&selection=11,0,11,21|lesson3-processes, p.32]]：
①共享内存模型：建立起一块供协作进程共享的内存区域，进程通过向共享区域读写数据来交换信息
②消息传递模型：通过在合作进程中交换消息实现通信

## 3.5 共享内存系统的IPC-user
### 生产者-消费者问题
1.生产者进程生成信息以供消费者进程消费
2.解决方法：采用共享内存
缓冲区类型：
①无界缓冲区：没有限制缓冲区的大小
- 生产者不等，总是可以产生新项
- 消费者必须等待新数据项
②有界缓冲区：假设固定缓冲区的大小
- 如果缓冲区空-消费者必须等待
- 如果缓冲区满-生产者必须等待
### 共享内存[[lesson3-processes.pdf#page=35&selection=11,0,15,13|lesson3-processes, p.35]]
1.共享内存区域：在希望通信的进程之间共享的内存区域
2.用户进程控制通信
3.主要问题：提供允许用户进程在访问共享内存时同步其操作的机制
原因：多进程共享数据容易出现数据竞争，所以必须使用同步机制来确保访问的正确性。
## 3.6 消息传递系统的IPC-os
1.消息传递提供一种机制，允许进程不必通过共享地址空间来实现通信和同步
2.消息传递工具提供`send(message)`和`receive(message)`
3.进程发送的消息可以是定长的/变长的
4.进程P和Q通过建立通信链路和`send(message)`&`receive(message)`使用来通信
①物理实现：
- 共享内存
- 硬件总线
- 网络
②逻辑实现
- 直接或间接的通信
- 同步或异步的通信
- 自动或显式的缓冲
### 3.6.1 命名
#### 一、直接通信
1.需要直接通信的每个进程必须明确指定通信的接收者/发送者
2.原语`send()`&`receive()`的定义：
`send(P,message)`-向进程P发送message
`receive(Q,message)`-从进程Q接收message
3.通信链路的属性
①自动建立链路
②每个链路只与一对通信进程相关
③每对进程之间只有一个链路
④这种链路可能是单向的，但通常是双向的
#### 二、间接通信
1.通过邮箱/端口来发送/接收消息
①每个邮箱都有唯一的标识符
②两个进程只有拥有一个共享邮箱时才能通信
2.原语`send()`&`receive()`的定义：
`send(A,message)`-向邮箱A发送message
`receive(A,message)`-从邮箱A接收message
3.通信链路的属性
①只有在两个进程共享一个邮箱时才能建立通信链路
②一个链路可以与两个/多个进程相关联
③两个通信进程之间可有多个不同链路，每个链路对应于一个邮箱
④链路可能是单向的/双向的
4.邮箱
①由进程拥有：需要区分所有者（只能接收）和使用者（只能发送）。当拥有邮箱的进程终止，那么邮箱消失。
②由os拥有：独立存在，不属于某个特定进程
os提供机制来允许进程：
（1）创建新的邮箱
（2）通过邮箱发送/接收消息
（3）删除邮箱
5.邮箱共享
①问题：$P_1,P_2,P_3$共享邮箱A，$P_1$发送，$P_2,P_3$接收，那么哪个进程会收到$P_1$发送的消息？
②答案：取决于选择的方案
（1）允许一个链路最多只能与两个进程关联
（2）允许一次最多一个进程执行操作`receive()`
（3）允许系统随意选择一个进程（$P_{1}\quad or \quad P_{2}，not \quad both$）以便接收消息
### 3.6.2 同步
1.消息传递的种类[[lesson3-processes.pdf#page=44&selection=11,0,11,15|lesson3-processes, p.44]]
①阻塞的/同步的
（1）阻塞发送：发送进程阻塞，直到消息由接收进程/邮箱接收
（2）阻塞接收：接收进程阻塞，直到有消息可用
②非阻塞的/异步的
（1）非阻塞发送：发送进程发送消息并继续
（2）非阻塞接受：接收进程收到一个有效消息/空消息
### 3.6.3 缓冲
jump
## 3.7 IPC系统示例
### 3.7.1 POSIX共享内存
jump
### 3.7.2 Mach消息传递
jump
### 3.7.3 Windows
jump
### 3.7.4 管道
#### 一、管道
1.管道：允许两个进程进行通信
2.实现管道的问题：
- 单向/双向通信？
- 双向-半双工/全双工？
	- 半双工：数据在同一时间内只能按一个方向传输
	- 全双工：数据在同一时间内可在两个方向上传输
- 通信进程是否有关系？
- 管道通信通过网络/在同一台机器上运行？
3.管道种类
①普通管道不能从创建它的进程外部访问。通常，父进程创建一个管道，并使用它与它创建的子进程通信。
②命名管道可以在没有父子关系的情况下访问。
#### 二、普通管道
1.普通管道允许两个进程按照标准的生产者-消费者方式进行通信
①生产者从写入端写
②消费者从输出端读
→普通管道是单向的
2.普通管道只能由创建进程访问，要求通信进程之间的父子关系
普通管道的文件描述符：写入端fd[1]，读出段fd[0]
3.在Windows中，普通管道被称为匿名管道
#### 三、命名管道
1.命名管道比普通管道更强大，通信可以是双向的，父子关系不是必须的，多个进程可使用一个命名管道通信
2.UNIX和Windows支持命名管道
## 3.8 客户机-服务器系统中的通信
### 3.8.1 套接字socket
1.套接字：通信的端点
2.结构：一个IP地址+一个端口号
3.每个进程各有一个套接字，所有链接都由唯一的一堆套接字组成[[lesson3-processes.pdf#page=50&selection=11,0,11,20|lesson3-processes, p.50]]
4.所有低于1024的端口是众所周知的，可以用于实现标准服务
5.回送地址：IP地址=127.0.0.1，表示本机，不经过网络接口
### 3.8.2 远程过程调用RPC
1.RPC对通过网络连接系统之间的过程调用进行了抽象，允许一个程序调用另一个远程主机上的过程/函数
2.流程：消息传到RPC服务→RPC服务监听远程系统的端口号，消息包含用于指定执行函数的一个标识符+传递给函数的一些参数→函数按要求执行→所有结果通过零一消息传递回给请求者

RPC完整调用流程图解[[lesson3-processes.pdf#page=52&selection=11,0,11,22|lesson3-processes, p.52]]：
①客户端流程
客户端组成模块：应用程序代码+客户端存根+RPC底层运行时库
step1-客户端调用远程过程
用户程序中像平常一样调用某个函数，但这个函数其实是个代理函数，负责触发 RPC 流程
step2-客户端存根封装参数
客户端存根会将参数序列化，使用XDL转换为跨平台格式，支持大小端架构兼容
step3-RPC运行时库发送请求
客户端的RPC运行时库把封装好的数据打包成网络消息发送给服务器
②服务器端流程
服务器端组成模块：实际的服务器函数+服务器端存根+RPC底层运行时库
step4-服务器端存根解包参数并调用函数
收到消息后，服务器存根解包参数，然后调用本地真实的函数
step5-服务器端存根打包返回值
函数执行完成后返回值，存根将其封装为网络格式，准备回传
step6-客户端解包结果，继续执行
客户端RPC运行时库收到服务器返回，客户端存根解包，返回值传递给调用者，用户程序继续执行。

><span style="background:rgba(3, 135, 102, 0.2)">流程in文字：</span>
>当客户端程序需要调用一个远程过程时，它像调用本地函数一样发起请求。RPC系统通过客户端存根接收该调用，并将参数进行封装，随后交由底层的RPC 运行时库准备通过网络发送请求。发送前，客户端内核会先向服务端的匹配器发送一条查询消息，询问远程过程X绑定在哪个端口上。服务端的匹配器查找并返回具体端口 P。
>获取端口号后，客户端内核将真正的RPC请求打包，通过网络发送给服务端的P 端口。服务器上，守护进程监听着该端口并接收请求，然后由服务端的c存根解包参数并调用实际的过程逻辑。当远程过程执行完毕后，服务器将结果重新封装，通过网络返回给客户端。客户端的存根解包后，将结果返回给用户程序，从而完成一次完整的远程调用。
>整个过程隐藏了通信细节，实现了远程调用就像本地调用一样的体验。为了支持不同系统间通信，RPC使用统一的XDL格式处理字节序差异，并通过设计保证消息 恰好传递一次，以应对网络通信中的各种失败场景。

3.存根stub：由RPC系统自动生成的代理代码，封装了客户端与服务器之间的通信细节，负责把请求打包发送到远程服务器，并接收返回结果
①客户端存根：封装远程调用请求、参数封送、发送请求
参数封装设计处理客户机和服务器系统的不同数据表示
（1）大端结尾：使用内存的高地址来存储高位字节
（2）小端结尾：使用内存的高地址来存储低位字节
解决大端结尾&小端结尾的差异：RPC系统定义一个独立于机器的数据表示-外部数据表示XDR
②服务器端存根：解包参数、调用实际过程、封装返回值
4.Windows系统的存根代码根据用MIDL微软接口定义语言编写的规范编译
5.问题：远程通信比本地通信有更多的故障场景
解决：令os确保每个消息执行正好一次，而不是执行最多一次