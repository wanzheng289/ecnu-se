## 9.1 背景
- 程序必须（从磁盘）进入内存并置于进程中才能运行
- CPU只能<font color="#c00000">直接访问</font>主存和寄存器这两个存储资源
- 主存只能接收
	- 地址+读请求
	- 地址+数据+写请求
- 寄存器访问可在一个CPU时钟内结束
- 主存花费很多循环来访问→内存停顿
	- 在主存和CPU寄存器之间设置缓存cache
	- CPU无法直接访问cache
### 9.1.1 基本硬件[[lesson9-memory.pdf#page=5&selection=11,0,11,10|lesson9-memory, p.5]]
用于确保正常的操作
1.确保每个进程都有一个单独的内存空间→保护进程不互相影响
通过基址寄存器和界限地址寄存器确保进程只能访问合法地址
- 基址寄存器：最小合法物理内存地址$base$
- 界限地址寄存器：范围大小$limit$
2.硬件地址保护：$base \leq address \lt base+limit$才能访问内存，反之则陷入os非法寻址错误（只有os可以加载基址寄存器和界限地址寄存器）
### 9.1.2 地址绑定
绑定：从一个地址空间映射到另一个地址空间
符号地址
→（编译器）可重定位地址
→（链接程序或加载程序）绝对地址
进行时期[[lesson9-memory.pdf#page=9&selection=11,0,11,38|lesson9-memory, p.9]]
①编译时：若已知进程将在内存中的驻留地址→生成绝对代码
②加载时：若不知进程将在内存中的驻留地址→生成可重定位代码
③执行时：若进程在执行时可以从一个内存段移到另一个内存段→需要特定硬件支持
### 9.1.3 逻辑地址空间与物理地址空间
1.逻辑地址/虚拟地址：CPU生成的地址
2.物理地址：内存单元看到的地址/加载到内存地址寄存器的地址
编译时和加载时-两者相同
执行时-不同
3.逻辑地址空间：由程序所生成的所有逻辑地址的集合
4.物理地址空间：这些逻辑地址对应的所有物理地址的集合
5.内存管理单元MMU的硬件设备完成从虚拟地址到物理地址的运行时映射
### 9.1.4 动态加载
采用动态加载时，一个程序只有在调用时才会加载
### 9.1.5 动态链接与共享库
1.静态链接
2.动态链接
3.动态链接库/共享库DLL
## 9.2 连续内存分配
### 9.2.1 内存保护
对重定位寄存器和界限地址寄存器的硬件支持：使用base和limit[[lesson9-memory.pdf#page=19&selection=11,0,11,52|lesson9-memory, p.19]]
### 9.2.2 内存分配
1.孔：一块可用内存
2.孔太大→分成两块；相邻孔合并
3.从一组可用孔中选择一个可用孔的方法
①首次适应：分配首个足够大的孔
②最优适应：分配最小的足够大的孔
③最差适应：分配最大的孔
### 9.2.3 碎片
1.碎片：无法使用的孔
①外部碎片：总的可用内存之和可以满足请求但并不连续
②内部碎片：进程所分配的内存与所需的内存之差
2.外碎片的解决方式
①压缩
②允许进程的逻辑地址空间是不连续的
## 9.3 分页
允许进程的物理地址空间不连续的内存管理方案
### 9.3.1 基本方法
1.帧/页帧：将物理内存分为固定大小的块，大小$2^n$
2.页/页面：将逻辑内存分为同样大小的块
3.分配：当需要执行一个进程时，其页从文件系统或备份存储等源处加载到内存的可用帧。备份存储划分为固定大小的块，它与单个内存帧或多个内存帧（簇）的大小一样
4.由CPU生成的每个地址分为页码p+页偏移d
①页码：每个进程页表的索引
②页表：包含物理内存的每个帧的基址，偏移量是被引用帧中的位置
③物理内存地址：帧的基址+页偏移量

逻辑地址一共m位→逻辑地址空间=$2^m$
页内偏移n位→页面大小=$2^n$
$\therefore页码p=m-n,页偏移d=n$

5.CPU生成的逻辑地址→物理地址
①提取页码p作为页表的索引
②从页表中提取对应帧码f
③将逻辑地址中的页码p替换为帧码f
e.g.
逻辑地址空间=$2^{16}$
页面大小=$2^{10}$
$\therefore 页码=m-n=6位,页偏移d=10位$
`[ pppppp | dddddddddd ]`
- CPU给出逻辑地址
- 拆出页号p=`pppppp`
- 用p去查页表→得到物理页框基地址
- 物理地址=物理页框基地址+d

6.内存分页模型[[lesson9-memory.pdf#page=27&selection=11,0,11,43|lesson9-memory, p.27]]
e.g.32字节物理内存和4字节页面[[lesson9-memory.pdf#page=28&selection=11,0,11,14|lesson9-memory, p.28]]
$m=4,n=2$
$p-2位,d-2位$
$a:0000,p=0,d=0$
p=0-查页表在第5帧，第5帧的基址=20
20+0=20
$d:0011,p=0,d=3$
p=0-查页表在第5帧，第5帧的基址=20
20+3=23
$e:0100,p=1,d=0$
p=1-查页表在第6帧，第6帧的基址=24
24+0=24
$n:1101,p=3,d=1$
p=3-查页表在第2帧，第2帧的基址=8
8+1=9
【编号从0开始】
7.计算内部碎片
页大→碎片大
页小→管理资源多
8.分配前&分配后的空闲帧
### 9.3.2 硬件支持
1.PTBR页表基址寄存器：指向页表的起始地址
2.PTLR页表长度寄存器：表示页表大小
#### 转换后援缓冲器TLB
1.原因：将页表存储在内存中→更快的上下文切换&&更慢的内存访问时间
2.解决：转换后援缓冲器TLB-高速硬件缓冲
①结构：键+值，用值对比键，找到-获取值字段
②与页表一起使用的方法：
TLB包含少量页表条目
CPU产生一个逻辑地址
→MMU检查页码是否存在于TLB中
找到-命中-获取帧码
没找到-未命中-访问内存页表获得帧码-访问内存-将页码和帧码添加到TLB中
若TLB条目已满-替换（部分TLB表项永不替换）
③地址空间标识符ASID：唯一标识每个进程
TLB解析虚拟页码时，确保当前运行进程的ASID与虚拟页相关的ASID相匹配
不匹配-miss
④采用TLB分页硬件lesson9-memory, p.35
4.命中率：地址翻译时，页号在 TLB 中找到的概率
5.有效内存访问时间EAT：
假设一次物理内存访问=10ns，命中率=0.8
①TLB hit：只访问1次内存（查数据），时间=10ns
②TLB miss：访问2次内存（查页表+查数据），时间=20ns
③$EAT=0.8*10+0.2*20=12ns$
### 9.3.3 保护
1.保护位：定义一个页可读可写or只读，保存在页表中
2.有效-无效位
①位有效：该值表示相关的页在进程的逻辑地址空间内-合法页
②位无效：该值表示相关的页不在进程的逻辑地址空间内
### 9.3.4 共享页
1.共享代码
2.私有代码和数据
e.g.在分页环境下共享标准C库[[lesson9-memory.pdf#page=40&selection=11,0,11,20|lesson9-memory, p.40]]
## 9.4 页表结构
1.页表结构
2.将页表分成更小的单元
①两层页表
②哈希页表
③倒置页表（物理→逻辑）
### 9.4.1 分层分页
将页表再分页
1.两层页表方案/向前映射页表[[lesson9-memory.pdf#page=42&selection=11,0,11,24|lesson9-memory, p.42]]
地址转换方案[[lesson9-memory.pdf#page=44&selection=11,0,13,18|lesson9-memory, p.44]]
2.三/四层页表方案[[lesson9-memory.pdf#page=46&selection=11,0,13,19|lesson9-memory, p.46]]
对外页表再分页
### 9.4.2 哈希页表[[lesson9-memory.pdf#page=48&selection=11,0,11,18|lesson9-memory, p.48]]
处理大于32位地址空间
方案：[[lesson9-memory.pdf#page=47&selection=11,0,11,18|lesson9-memory, p.47]]
①链表的元素的字段：虚拟页码+映射的帧码+指向链表内下一个元素的指针
②原理：
用逻辑地址的p哈希到哈希表，用虚拟页码与链表内第一个元素的第一个字段相比较
匹配-第二个字段帧码替换p
不匹配-后续节点
变体：聚簇页表
### 9.4.3 倒置页表[[lesson9-memory.pdf#page=50&selection=11,0,11,32|lesson9-memory, p.50]]
只有对于每个真正的内存页或帧，倒置页表才有一个条目
条目结构：保存在真正内存位置上的页的虚拟地址+拥有该页进程的信息
## 9.5 交换
→增加了系统的多道程序程度
### 9.5.1 标准交换
使用磁盘作为后备存储的两个进程的标准交换[[lesson9-memory.pdf#page=53&selection=11,0,11,26|lesson9-memory, p.53]]
### 9.5.2 采用分页的交换[[lesson9-memory.pdf#page=57&selection=11,0,11,20|lesson9-memory, p.57]]
页面调出：将页面从内存移动到后备存储
页面调人：将页面从后备存储移动到内存
### 9.5.3 移动系统的交换
## 9.6 示例：Intel 32位与64位体系结构
### 9.6.1 IA-32架构
逻辑地址→物理地址：[[lesson9-memory.pdf#page=61&selection=11,0,13,2|lesson9-memory, p.61]]
#### 一、IA-32分段[[lesson9-memory.pdf#page=60&selection=11,0,13,23|lesson9-memory, p.60]]
[[lesson9-memory.pdf#page=62&selection=11,0,13,15|lesson9-memory, p.62]]
#### 二、IA-32分页[[lesson9-memory.pdf#page=63&selection=11,0,13,23|lesson9-memory, p.63]]
页地址扩展PAE[[lesson9-memory.pdf#page=64&selection=11,0,13,26|lesson9-memory, p.64]]
### 9.6.2 x86-64
线性地址[[lesson9-memory.pdf#page=65&selection=11,0,13,2|lesson9-memory, p.65]]
## 9.7 示例：ARMv8架构
1️⃣逻辑地址空间$2^m$→地址位数m 
2️⃣页面大小$2^n$→页内偏移n
3️⃣地址位数−偏移=页号p/页帧号f 
4️⃣页表项数=逻辑页数=$\frac{逻辑地址空间}{页面大小}$
5️⃣页表项位数=页帧号位f+控制位

![[_cgi-bin_mmwebwx-bin_webwxgetmsgimg__&MsgID=6295139436657316895&skey=@crypt_443811c9_4e36fde0fdc408b1b3642a999e225b8f&mmweb_appid=wx_webfilehelper.jpg]]
$物理地址31位$
$页偏移量n-10位$
$逻辑地址m-26位$
$\therefore 页码p-16位,页偏移量d-10位$
（1）26位
（2）$2^{10}$字节【页帧大小=页面大小】
（3）$页帧数=\frac{2^{31}}{2^{10}}=2^{21}$
$物理地址31位$
$页偏移量n-10位$
页帧号=31-10=21位
（4）$页表项数=逻辑项数=\frac{2^{26}}{2^{10}}=2^{16}$项
页码16位-共$2^{16}$种页码号
每一个不同的页号，都必须有一个页表项
（5）21+1=22位
页表项存储物理页框号f（31-10=21）和有效位
![[_cgi-bin_mmwebwx-bin_webwxgetmsgimg__&MsgID=1341837411370234616&skey=@crypt_443811c9_4e36fde0fdc408b1b3642a999e225b8f&mmweb_appid=wx_webfilehelper.jpg]]

$容量=2^{20}B$
划分成$2^8$个页框，每个页框$4*2^{10}=2^{12}B$
页面大小$2^{12}$，页偏移量n=12
【十进制逻辑地址】
$p=\frac{十进制逻辑地址}{页面大小}=\frac{9016}{4096}$向下取整=2
d=9016 mod 4096=824
查表-页帧号=11，状态=0
$\therefore 物理地址=页帧号*页大小+页偏移=11*4096+824=45880$

<span style="background:rgba(240, 200, 0, 0.2)">【十进制逻辑地址】</span>
$p=\frac{十进制逻辑地址}{页面大小}$
$d=十进制逻辑地址 \quad mod \quad 页面大小$
$物理地址=页帧号*页大小+页偏移$
<span style="background:rgba(240, 200, 0, 0.2)">【二进制逻辑地址】</span>
逻辑地址空间$2^m$→逻辑地址m位
页面大小$2^n$→页偏移量n位
p：m-n位
d：n位
将逻辑地址拆成前p位+后d位，通过p找f再找对应基址
$物理地址=f*基址+d$


每个页框大小=$\frac{1MB}{256}=\frac{2^{20}}{2^8}=2^{12}B=4096B=4KB$
页内偏移=12位
每页地址范围[0,4095]
$页号=\frac{9016}{4096}-向下取整-=2$
对应页帧号11，状态0，该页已在内存，无缺页中断
$页内偏移=9016\quad mod\quad4096=824$
$物理地址=页帧号*页大小+页内偏移=11*4096+824=45880$


