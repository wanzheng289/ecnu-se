确保共享同一逻辑地址的空间的协作进程的有序执行→维护数据的一致性
## 6.1 背景
1.背景
多个进程可以并发执行。操作系统可以随时中断一个进程，这意味着一个进程可能只执行了一部分操作就被暂停了。当多个进程同时访问并修改同一个共享数据时，可能会导致数据不一致，因此必须使用同步工具来保证数据一致性。
e.g.有界缓冲区问题
生产者进程代码：
``` c
while(true)
{
	/*produce an item in next_produced*/
	
	while(count==BUFFER_SIZE)
	;//什么都不做
	butter[in]=next_produced;
	in=(in+1)%BUFFER_SIZE;
	count++;
}
```
消费者进程代码：
``` c
while(true)
{
	while(count==0)
	;//什么都不做
	next_consumed=buffer[out];
	out=(out+1)&BUFFER_SIZE;
	count--;
	/**consume the item in next_consumed/
}
```
假设生产者进程和消费者进程并发执行语句`count++`和`count--`，导致count的值可能不正确。
2.竞争条件：多个进程并发访问和操作同一数据并且执行结果与特定访问顺序有关
e.g.[[ch6.pdf#page=5&selection=9,0,9,14|ch6, p.5]]两个进程`P₀`和`P₁`同时在调用`fork()`系统调用来创建子进程，系统中维护了一个变量`next_available_pid`，表示下一个可用的PID。如果`P₀`和`P₁`同时访问这个变量，并试图用它来分配新进程的PID，就可能出现竞态条件。如果没有同步机制来保护`next_available_pid`这个共享变量，那么两个进程就有可能在并发访问时读到相同的值并错误地重复使用它
## 6.2 临界区问题
1.临界区：假设有一个包含`n`个进程的系统，它们可能会同时访问共享资源。每个进程都有一段代码叫做临界区，这段代码会访问或修改共享资源。
2.临界区问题：多个进程的临界区不能同时执行，需要设计一个协议，保证多个进程在访问共享资源时不会同时进入临界区，从而避免竞态条件
3.典型进程的一般结构
``` c
while(true)
{
	/*进入区-请求进入临界区*/
	/*临界区-访问或修改共享资源的代码*/
	/*退出区-离开临界区，释放资源*/
	/*剩余区-不涉及共享资源的普通操作*/
}
```
4.临界区问题的解决方案的要求
①互斥：如果进程$P_i$在其临界区内执行，那么其他进程都不能再其临界区内执行。
②进步：如果没有进程在其临界区内执行，并且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可以参加选择，以便确定下次谁能进入临界区，而且这种选择不能无限推迟。
③有限等待：从一个进程做出进入临界区的请求指导这个请求允许为止，其他进程允许进入临界区的次数具有上限。
5.基于中断的解决方法：在进程进入临界区之前关闭中断，在进程退出临界区后重新打开中断。（只满足了互斥要求）
6.纯软件实现的临界区互斥方案
①只支持2个进程
②原理：假设所有读取和写入操作是原子操作（完全执行or完全不执行，不能被中断），使用一个共享变量`int turn`来控制哪个进程有资格进入临界区-如果`turn == 0`，表示进程`P0`可以进入临界区；如果`turn == 1`，表示进程`P1`可以进入临界区
③算法
``` c
while(true)
{
	while(turn==j);
	
	/*临界区*/
	
	turn=j;
	
	/*剩余区*/
}
```
④正确性分析
（1）互斥✔️-`Pi`只有在`turn == i`的时候才能进入临界区，而turn是共享变量，只能同时等于一个值（0 或 1）
（2）进步❌-如果`turn == j`，而此时进程`Pj`并不想进临界区，那么`Pi`仍然必须等它轮到自己才能进入，但此时临界区是空的，却没有任何进程能进去
（3）有限等待✔️-等到`turn == i`就能进临界区，不会出现无限插队现象
## 6.3 Peterson解决方案（基于软件的解决方案）
1.适用于2个进程交替执行临界区与剩余区
2.假设基本的赋值语句和读取语句是原子操作，不会被中断
3.数据结构-两个共享变量
①`int turn`：`turn==i`表示进程$P_i$可以在临界区内执行
②`boolean flag[2]`：`flag[i]==0`表示进程$P_i$正在申请进入临界区
4.算法
``` c
while(true)
{
	flag[i]=true;
	turn=j;
	while(flag[j]&&turn==j)
	;
	
	/*临界区*/
	
	flag[i]=false;
	
	/*剩余区*/
}
```
5.正确性
①互斥成立
证明：只有当`flag[j]=false`或者`turn=i`时，$P_i$才进入临界区。如果两个进程`P₀`和`P₁`同时想进入临界区，即`flag[0] == flag[1] == true`，那么它们都将执行`turn = j`，但是`turn` 最终只能是`0`或`1`，不可能同时为两个值。所以最多只有一个进程能成功跳过`while`循环进入临界区，另一个进程会被阻塞。
②进步要求被满足
证明：如果只有$P_i$程想进入临界区，那它设置`flag[i] = true`，并设置`turn = j`，即使$P_j$恰好在执行`while (flag[i] && turn == i)`，也不会阻止$P_i$，因为`flag[j] == false`。如果两个进程都在等待，那由`turn`决定哪个进程进入临界区，不会无限等待没有正在进入的进程让路的情况。
③有限等待要求被满足
证明：一旦$P_i$设置了`flag[i] = true`，它最多只能被对方$P_j$插队一次,因为$P_j$一旦执行完临界区，会把`flag[j]=false`，这就让$P_i$能顺利进入。 如果$P_j$又想进，它会重新设置`flag[j] = true`并设置`turn = i`，这反而把优先权交给了$P_i$，所以每个进程最多等一次对方就能进去。
6.Peterson解决方案不能保证适用于现代计算机体系结构
①原因：为了提高系统性能，处理器&编译器可能会重新排序没有相互依赖的读写操作。对于具有共享数据的多线程应用程序，指令的重新排序可能会导致不一致或意外的结果。
②改进：内存屏障
## 6.4 硬件同步支持（基于硬件的解决方案）

### 6.4.1 内存屏障
1.内存模型：计算机体系结构对应用程序的内存保证，定义了程序中对内存的写入操作，在什么时候、对谁是可见的
①强排序：一个处理器的内存修改对所有其他处理器立即可见
②弱排序：一个处理器的内存修改可能不会立即被其他处理器所见
2.内存屏障/内存栅栏：强制将内存中的任何更改传播给所有其他处理器的指令，从而确保内存修改对其他处理器上的运行线程可见
①原理：当执行一条内存屏障指令时，系统会确保在内存屏障之前的所有读取/写入操作都已经执行完毕，在内存屏障之后的读取/写入操作必须等屏障前的操作完成之后再开始
②作用：即使CPU或编译器把程序中的语句顺序做了重排序，只要插入了memory_barrier，就能确保写入操作真正落地并对其他CPU可见，且后续的读取/写入操作不会越过屏障执行【不是阻止重排序，而是阻止了某些重排序带来的可见乱序现象】
e.g.
2个线程共享：
``` c
boolean flag =false;
int x=0;
```
线程1执行：
``` c
while(!flag)
{
	memory_barrier();
}
print x;
/*确保在读取到flag==true后再读到的x是更新后的值*/
```
线程2执行：
``` c
x=100;
memory_barrier();
flag=true;
/*保证x=100的写入操作在flag=true之前完成并对其他线程可见*/
```
### 6.4.2  硬件指令（是原子操作）
1.特殊硬件指令：检测和修改字的内容/原子地交换两个字
①`test_and_set()`-执行是原子的
（1）定义
``` c
boolean test_and_set(boolean *target)
{
	boolean rv=*target;
	*target=true;
	return rv;
}
```
（2）性质
- 原子操作
- 返回的是`target`设置成`true`之前的值，用于判断之前有没有人抢占过资源
- 把传入的`target`设置为`true`，表示已经占用了这个锁/资源
（3）互斥实现-不满足有限等待要求
``` c
do{
	while(test_and_set(&lock))
		;/*什么都不做*/
		
	/*临界区*/
		
	lock=false;
		
	/*剩余区*/
		
}while(true)
```
②`compare_and_swap()`
（1）定义
``` c
int compare_and_swap(int *value,int expected,int new_value)
{
	int temp=*value;
	if(*value==expected)
	{
		*value=new_value;
	}
	return temp;
}
```
（2）性质
- 原子操作
- 函数返回的是`value`在执行前的原始值
- 只有当`*value == expected`时，才会赋值为`new_value`，否则什么都不做
（3）互斥实现-不满足有限等待要求
`lock`初始化为0
``` c
while(true)
{
	while(compare_and_swap(&lock,0,1)!=0)//如果锁已被占用（lock != 0），就一直空转等待
	;/*什么都不做*/
	
	/*临界区*/ //成功获取锁后执行临界区
	
	lock=0;//退出临界区，释放锁
	
	/*剩余区*/
}
```
（4）有界等待互斥实现
``` c
while(true)
{
	waiting[i]=true;//进程i申请进入临界区
	key=1;
	while(waiting[i]&&key==1)
	{
		key=compare_and_swap(&lock,0,1);
		/*如果lock==0，则设为1，代表成功获得锁key变为0，否则key==1，表示锁已被其他进行占用，继续等待*/
	}
	waiting[i]=false;//成功获取锁，不再等待
	
	/*临界区*/ //进入临界区
	
	
	//临界区结束时，当前进程需要释放锁
	j=(i+1)&n;//从当前进程i的下一个进程j开始向后找下一个正在等待的进程
	while((j!=i)&&!waiting[j])//如果当前j进程没有在等待（waiting[j] == false），就跳过，继续往后找下一个
	{
		j=(j+1)%n;
	}
	if(j==i)//如果当前没有进程在等待，就彻底释放锁lock=0，任何进程都可以竞争
	{
		lock=0;
	}
	else
	{
		waiting[j]=false;//使正在等待的进程j跳出等待循环
	}
	
	/*剩余区*/
}
```
### 6.4.3 原子变量
1.原子变量：提供对基本数据类型的原子操作，确保再更新单个变量时可能存在数据竞争情况下的互斥
2.实现：使用`compare_and_swap()`
e.g.`increment(&sequence)`
``` c
void increment(atomic_int *v)//将*v原子性地加1
{
	int temp;
	do{
		temp=*v;
	}while(temp!=compare_and_swap(v,temp,temp+1));//判断之前读到的temp值是否是当前的*v
}
```
## 6.5 互斥锁/自旋锁（高层软件工具）
1.互斥锁：一个进程在进入临界区时应得到锁，在退出临界区时释放锁。用于保护临界区，从而防止竞争条件
2.操作：调用必须原子地执行
`boolean avaliable`表示锁是否可用，`false`表示锁已被占用，`true`表示可以获取
①`acquire()`-获取锁
定义：
``` c
accquire()
{
	while(!avaliable)
	;/*忙等待*/
	
	avaliable=false;//表示占用了锁
}
```
锁可用→调用accquire()成功，并且锁不再可用
②`release()`-释放锁
定义：
``` c
release()
{
	avaliable=true;
}
```
③实现
``` c
while(true)
{
	/*获取锁*/
	
	/*临界区*/
	
	/*释放锁*/
	
	/*剩余区*/
}
```

4.缺点：忙等待-当一个线程试图获取被占用的锁时，会不断轮询该布尔变量，看锁是否释放
## 6.6 信号量（更坚固的同步工具）
### 0
1.信号量S：int，用来控制对共享资源的访问
2.通过2个原子操作实现控制：信号量整数值的修改必须原子执行，即当一个进程修改信号量值时，其他进程不能同时修改同一信号量的值
①`wait()`
``` c
wait(S)
{
	while(S<=0)//资源已被占满
	{
		;//忙等待
	}
	S--;//一旦S>0，即有可用资源，就执行S--，表示占用了一个资源单位
}
```
②`signal()`
``` c
signal(S)
{
	 S++;//某个进程释放资源，还回一个资源单位
}
```
### 6.6.1 信号量的使用
1.计数信号量：值不受限制，用于控制访问具有多个实例的某种资源
①初值=可用的资源数量
②进程需要使用资源时，对该信号量执行`wait()`来减少信号量的计数
③进程释放资源时，对该信号量执行`signal()`来增加信号量的计数
④信号量计数=0时，所有资源都在使用中，需要使用资源的进程将会阻塞，直到计数>0
2.二进制信号量：值=0/1，用于提供互斥
解决临界区问题
`semaphore mutex=1`：表示临界区当前可用

``` c
wait(mutex);
/*临界区*/
signal(mutex);
```
3.使用信号量解决同步问题
e.g.执行$P_1$的$S_1$语句后再执行$P_2$的$S_2$语句：共享公共信号量`synch`(初始化=0)
``` c
S1;
signal(synch);
```

``` c
waits(synch);
S2;
```
可以用来解决各种同步问题
- 生产者-消费者问题（bounded-buffer）
- 哲学家就餐问题（deadlock）
- 读者-写者问题（读写同步）
- 等待-通知机制（如线程间等待事件）

### 6.6.2 信号量的实现
1.问题：忙等待，没有资源时，进程会反复空转检查，浪费CPU时间
2.改进-没有忙等待的信号量
①信号量
当一个进程必须等待信号量时→被添加到进程链表
``` c
typedef struct
{
	int value;//信号量的值
	struct process *list;//指向一个等待队列的头节点，这个队列存放的是被阻塞的进程。当信号量不可用时，这些进程就会进入这个队列等待资源
}semaphore;
```
②`wait(semaphore *S)`
``` c
wait(semaphore *S)
{
	S->value--;
	if(S->value<0)
	{
		add this process to S->list;
		sleep();//或者是block();挂起调用它的进程
		/*当前进程被从 CPU 执行队列中移除，添加到该信号量的等待队列中，进入阻塞态*/
	}
}
```
③`signal(semaphore *S)`
``` c
signal(semaphore *S)
{
	S->value++;
	if(S->value<=0)
	{
		remove a process from S->list;
		wakeup(P);//重新启动阻塞进程P的执行
		/*wakeup：从等待队列中移除一个等待进程，将它移动到就绪队列，等待调度器安排其继续执行*/
	}
}
```
任意时刻，最多只有一个进程可以对`S`执行`wait(S)`或`signal(S)`操作
3.信号量缺点：错误使用→时序错误/操作遗落
①提前释放锁，再尝试获取锁→多个进程误以为资源可用，导致竞态条件或数据冲突
``` c
signal(mutex);
...
wait(mutex);
```
②重复加锁两次，自己阻塞自己
``` c
wait(mutex);//成功进入临界区
...
wait(mutex);//会因为锁已经被自己持有而阻塞自己，形成死锁
```
③忘记`wait(mutex)`→多个进程可以同时访问临界区→数据竞争
忘记`signal(mutex)`→进程永远持有锁，其他进程永远无法进入临界区→资源饥饿或死锁
## 6.7 管程（高级的同步构造）
### 6.7.1 管程的使用
1.抽象数据类型ADT：封装数据+对其操作的一组函数
2.管程类型：属于ADT类型，提供在管程内互斥的操作，把共享数据与对其操作的代码封装起来
①语法：
``` c
monitor monitor name
{
	/*共享变量声明*/
	function P1(...)
	{
		...
	}
	function P2(...)
	{
		...
	}
	...
	function Pn(...)
	{
		...
	}
	/*初始化代码*/
	initialization code(...)
	{
		...
	}
	condition x,y;//条件变量，用于线程之间的同步等待与唤醒
}
```
②monitor
（1）monitor封装了内部变量和过程，共享变量只能在monitor的过程内被访问，外部无法直接访问这些变量
（2）互斥执行：一次只能有一个进程在monitor内部执行
变量：
``` c
semaphore mutex;
mutex=1;
```
对monitor内部的函数的处理：只有一个进程能进来执行monitor的某个操作，其他进程被阻塞在`wait(mutex)`,避免数据竞争和并发冲突
``` c
wait(mutex);//获取互斥访问权
...
body of P;
...
signal(mutex);//释放互斥访问权
...
```
③条件变量`condition`支持的操作
（1）`x.wait();`调用这一操作的进程会被挂起，直到另一进程调用
当线程P执行`x.signal()`唤醒另一个线程Q，有两个实现选择：
- 唤醒并等待：P执行完`x.signal()`后，让出执行权给Q，Q执行完后再返回P。
- 唤醒并继续（更常用）：P 执行完`x.signal()`后，自己继续执行，Q仍然等待进入管程
（2）`x.signal();`重新恢复一个挂起进程。如果没有挂起进程，那么该操作没有作用
e.g.假设$P_1$需要执行语句$S_1$，$P_2$需要执行语句$S_2$，$S_1$必须先于$S_2$发生
创建一个包含函数$F_1$和$F_2$的monitor，$P_1$调用$F_1$，$P_2$调用$F_2$
`int x=0;`-条件变量，控制$S_2$的执行时机
`boolean done=false;`-记录$S_1$是否完成
$F_1$：
``` c
S1;
done=true;//标记S1已完成
x.signal();//唤醒等待S1的进程
```
$F_2$：
``` c
if(done=false)//如果S1未执行
{
	x.wait();//挂起当前进程
}
S2;//S1已完成，执行S2
```
④示意图
（1）没有条件变量的管程[[ch6.pdf#page=43&selection=9,0,9,28|ch6, p.43]]
- 共享数据：表示多个进程要访问和操作的共享变量或资源，只允许通过monitor内部定义的操作函数访问，外部无法直接操作这些数据。
- 操作：访问和操作共享数据的函数，由monitor自动保护，无需程序员显式加锁或解锁。每次只有一个进程可以执行这些操作，其它进程必须等待。
- 初始化代码：在monitor被创建时执行一次
- 入口队列：等待进入 Monitor 的进程队列。monitor每次只允许一个进程执行其内部操作，其他尝试进入的进程就会被挂起并排队等待。
（2）采用条件变量的管程[[ch6.pdf#page=46&selection=9,0,9,33|ch6, p.46]]
条件变量等待队列：每个`condition x`和`condition y`对应一个等待队列,当某个进程在执行操作中发现条件不满足，会调用`x.wait()`，然后该进程放弃互斥锁并进入`x`的等待队列
### 6.7.2 采用信号量的管程实现
1.变量：
①对于每个管程，都有一个二进制信号量`semaphore mutex=1`，控制对monitor的互斥访问
进程在进入管程前执行`wait(mutex);`，离开管程后执行`signal(mutex);`
②使用唤醒并等待方案，引入二进制信号量`semaphore next=0`，用于唤醒被signal的进程，唤醒进程使用`next`挂起自己
③`int next_count=0`用于对在`next`上挂起的进程进行计数（等待`next`的进程数）
2.每一个函数P被替换为：
``` c
wait(mutex);//进入monitor，获得互斥权
...
body of P;//执行函数体
...
if(next_count>0)//如果有进程等着拿回mutex，就唤醒它
{
	signal(next);
}
else//否则释放mutex，允许其他进程进入monitor
{
	signal(mutex);
}
```
保证monitor内最多只有一个进程执行
3.条件变量
①对于每个条件变量`x`，有一个信号量`semaphore x_sem=0`（等待队列对应的信号量）和一个整型变量`int x_count=0`（等待在这个条件变量上的线程数量）
②`x.wait()`：意味着线程主动放弃对mutex的控制权并等待某个条件满足。如果此时有另一个线程曾被signal但没拿到mutex，就通过`next`信号量唤醒它。
``` c
x_count++;//当前进程将等待条件变量x
if(next_count>0)//如果有别的进程在等mutex，就唤醒它
{
	signal(next);
}
else//否则直接释放mutex
{
	signal(mutex);
}
wait(x_sem);//阻塞等待，直到被signal唤醒
x_count--;//从等待队列移除
```
③`x.signal()`
``` c
if(x_count>0)//只有在有进程等这个条件变量时才做事
{
	next_count++;//表示当前进程将等待被唤醒
	signal(x_sem);//唤醒一个在x.wait()上阻塞的进程
	wait(next);//自己进入next队列，等其他进程把mutex让回来
	next_count--;
}
```

| 名称           | 类型   | 含义简述                      |
| ------------ | ---- | ------------------------- |
| `mutex`      | 信号量  | 控制 monitor 互斥进入           |
| `next`       | 信号量  | 控制 signal 后等待进程重新拿回 mutex |
| `next_count` | 整型   | 当前等在 next 上的进程数           |
| `x_sem`      | 信号量  | 等待在条件变量 x 上的进程队列          |
| `x_count`    | 整型   | 正在等待条件变量 x 的进程数           |
| `x.wait()`   | 函数实现 | 放弃 mutex 等条件成立            |
| `x.signal()` | 函数实现 | 唤醒等在 x 上的进程，并等待对方归还 mutex |
### 6.7.3 管程内的进程重启
1.FCFS服务（太简单，不够）
2.条件等待结构
`x.wait(c);`
`int c`：优先值，与挂起进程的名称一起存储
执行`x.signal()`时，具有最小优先值的进程会被重新启动
①假设用于分配单个资源的管程：
``` c
monitor ResourceAllocator
{
	boolean busy;//表示资源是否正在被使用
	condition x;//条件变量，供等待使用资源的进程阻塞
	
	void accquire(int time)
	{
		if(busy)//若资源被占用
		{
			x.wait(time);//阻塞，按优先级等待
		}
		busy=true;//被唤醒时，设置busy=true表示自己已经获得资源
	}
	
	void release()
	{
		busy=false;//释放资源
		x.signal();//唤醒下一个等待该资源的进程
	}
	
	initialization_code()
	{
		busy=false;//表示资源一开始是空闲状态
	}
}
```
②多个进程争用一个共享资源，需要合理分配，根据每个进程传入的整数t作为优先级数值
``` c
R.acquire(t);//申请资源，传入参数t
...
access the resource;
...
R.release();//释放资源
```
R：ResourceAllocator的一个实例
t：进程计划占用资源的最长时间，越小优先级越高
## 6.8 活性
活性：系统必须满足的一组属性，以确保进程在执行生命周期中取得进展。
活性失败e.g.无限循环
### 6.8.1 死锁
两个或多个进程无限等待一个事件，而该事件只能由这些等待进程之一来产生
### 6.8.2 优先级反转
1.一个进程无限期地被阻塞，永远无法获得它需要的资源
2.优先级反转：当一个低优先级的进程持有一个资源，而一个高优先级的进程需要这个资源时，由于低优先级进程没机会释放锁，高优先级进程反而被“倒置”成等待者。
3.解决方案：优先级继承协议-当一个高优先级进程因锁而等待一个低优先级进程时，系统临时提升低优先级进程的优先级到和高优先级进程一样，使其能尽快执行完释放锁，从而避免优先级反转。

## 例题
#### Bounded-Buffer Problem 生产者-消费者问题
n个buffer
mutex=1
full=0
empty=n
``` c
//生产者
while(true)
{
    ...
    /*生产一个产品，放入 next_produced*/
    ...
    
    wait(empty); //判断是否有空槽位，没有就阻塞（等待消费者释放）
    /*
    如果empty == 0，说明缓冲区已经满了，
    调用wait(empty)会让该生产者阻塞，直到消费者消费了产品，释放出空位
    */
    wait(mutex); //获取缓冲区访问权限（进入临界区）
    
    ...
    /*将产品放入缓冲区*/
    ...
    
    signal(mutex); //释放缓冲区访问权限（退出临界区）
    signal(full); //增加已用槽位数量（通知消费者可以消费）
}

//消费者
while(true)
{
    ...
    /*从buffer取出一个产品到next_produced*/
    ...
    
    wait(full); 
    wait(mutex); 
    
    ...
    /*消费产品*/
    ...
    
    signal(mutex); 
    signal(empty);
}
```
#### Readers and Writers Problem 读者-写者问题


#### Dining-Philosophers Problem 哲学家就餐问题