## 8.1 系统模型
1.在正常操作模式下，线程可以仅按以下顺序使用资源：
Step1-申请：线程请求资源。如果申请不能立即被允许，那么申请线程必须等待，直到它能获得该资源为止。
Step2-使用：线程对资源进行操作。
Step3-释放：线程释放资源
2.死锁：当集合中的每个线程都在等待只能由集合中的另一个线程引起的某个事件时，这组线程处于死锁状态
## 8.2 多线程应用程序的死锁
e.g.
资源：
``` c
semaphore S1=1;
semaphore S2=1;
```
线程$T_1$的操作：先请求信号量$S_1$（获得资源1），然后请求$S_2$获得资源2）
``` c
wait(S1);
wait(S2);
```
线程$T_2$的操作：先请求信号量$S_2$（获得资源2），然后请求$S_1$（获得资源1）
``` c
wait(S2);
wait(S1);
```
$T_1$执行`wait(S1)`，获得资源1
$T_2$执行`wait(S2)`，获得资源2
$T_1$尝试执行`wait(S2)`，由于$S_2$被$T_2$占用，$T_1$被阻塞
$T_2$尝试执行`wait(S1)`，由于$S_1$被$T_1$占用，$T_2$被阻塞
## 8.3 死锁特点
### 8.3.1 必要条件
如果在一个系统中以下4个条件同时成立→引起死锁
1.互斥：至少有一个资源必须处于非共享模式，即一次只有一个线程可使用；如果另一线程申请该资源，那么申请线程应等待该资源释放为止。
2.占有并等待：一个线程应占有至少一个资源，并等待另一个资源，而该资源为其他线程所占有。
3.非抢占：资源不能被抢占，即资源只能被线程在完成任务后自愿释放。
4.循环等待：有一组等待线程$\{T_0,T_1,...,T_n\}$，$T_0$等待的资源为$T_1$占有，$T_1$等待的资源为$T_2$占有，...，$T_{n-1}$等待的资源为$T_n$占有，$T_n$等待的资源为$T_0$占有。
### 8.3.2 资源分配图
组成：节点集合V+边集合E
节点集合的类型：
①系统所有活动线程的集合$T=\{T_1,T_2,...,T_n\}$
②系统所有资源类型的集合$R=\{R_1,R_2,...,R_n\}$（有几个点表示有几个实例）
边：
①申请边：从线程$T_i$到资源类型$R_j$的有向边$T_{i}→R_{j}$-线程$T_i$已经申请了资源类型$R_j$的一个实例，并且正在等待这个资源
②分配边：从资源类型$R_j$到线程$T_i$的有向边$R_{j}→T_{i}$-资源类型$R_j$的一个实例已经分配给了线程$T_i$
申请得到满足，则申请边→分配边
释放资源：分配边删除
结论：无环→系统不处于死锁状态；有环不一定死锁
每个资源类型一个实例+有环→一定死锁
e.g.[[lesson8-deadlocks.pdf#page=9&selection=11,0,11,33|lesson8-deadlocks, p.9]]
T1：占有R2的一个实例，申请R1的一个实例
T2：占有R1的一个实例和R2的一个实例，申请R3的一个实例
T3：占有R3的一个实例
死锁：资源都被环占用[[lesson8-deadlocks.pdf#page=10&selection=11,0,11,41|lesson8-deadlocks, p.10]]
非死锁：有不再等待的线程[[lesson8-deadlocks.pdf#page=11&selection=11,0,11,34|lesson8-deadlocks, p.11]]
## 8.4 死锁处理方法
1.忽视这个问题，认为死锁不可能在系统内发生（大多数os）
2.通过协议来预防或避免死锁，确保系统不会进入死锁状态
①死锁预防：确保至少有一个必要条件不成立
②死锁避免：要求os事先得到有关线程申请资源和使用资源的额外信息
3.允许系统进入死锁状态，然后检测它，并加以恢复
## 8.5 死锁预防
### 8.5.1 互斥
如果一个资源是可共享的（只读文件、只读缓冲、常量表等），那么互斥不是必须的，没有互斥自然不会死锁。但多数资源（锁、写文件、设备）必须互斥，因此我们通常不能通过禁止互斥来防止死锁。
### 8.5.2 占有并等待
必须保证线程在请求一个资源时，不能再占有任何其他资源
①线程启动前一次性申请所有资源
②线程只有在手里没有任何资源时才可以申请新资源
缺点：资源利用率低；可能饥饿
### 8.5.3 非抢占
如果一个线程持有资源并申请另一个不能立即分配的资源，那么它现在分配的资源都可被抢占
### 8.5.4 循环等待
对所有资源类型进行完全排序，而且要求每个线程按递增顺序来申请资源
e.g.
``` c
/*资源编号*/
first_mutex=1;
second_mutex=5;

/*正确-线程1的code*/
void *do_work_one(void *param)
{
	pthread_mutex_lock(&first_mutex);
	pthread_mutex_lock(&second_mutex);
	
	/*do some work*/
	
	pthread_mutex_unlock(&second_mutex);
	pthread_mutex_unlock(&first_mutex);
	
	pthread.exit(0);
}

/*错误-线程2的code*/
void *do_work_two(void *param)
{
	pthread_mutex_lock(&second_mutex);
	pthread_mutex_lock(&first_mutex);
	
	/*do some work*/
	
	pthread_mutex_unlock(&first_mutex);
	pthread_mutex_unlock(&second_mutex);
	
	pthread.exit(0);
}
```
## 8.6 死锁避免
### 8.6.1 安全状态
1.安全状态：系统能按一定顺序为每个线程分配资源（不超过其最大需求），仍能避免死锁
存在一个安全序列$<T_1,T_2,...,T_n>$→系统处于安全状态
2.安全序列：
对于每个$T_i$，
$T_i可以申请的资源数\lt当前可用资源+T_1至T_{i-1}所占有的资源$
3.安全状态→无死锁；非安全状态→可能死锁
4.算法：确保系统始终处于安全状态
### 8.6.2 资源分配图算法
每种资源类型只有一个实例
1.边
①申请边$T_i→R_j$
②分配边$R_j→T_i$
③需求边$T_i→R_j$：线程$T_i$可能在将来某个时候申请资源$R_j$，用虚线表示
2.操作
①线程$T_i$申请资源$R_j$：需求边→申请边
②线程$T_i$释放资源$R_j$：分配边→需求边
3.资源分配图
①避免死锁[[lesson8-deadlocks.pdf#page=23&selection=11,0,13,17|lesson8-deadlocks, p.23]]
②非安全状态[[lesson8-deadlocks.pdf#page=24&selection=11,0,13,16|lesson8-deadlocks, p.24]]
避免：系统不把$R_2$分配给$T_2$
只有在将请求边转换为分配边不会导致资源分配图中形成环的情况下，才能授予请求
### <span style="background:rgba(240, 200, 0, 0.2)">8.6.3 银行家算法</span>
每种资源类型有多个实例
1.当一个新的线程进入系统时，它应声明可能需要的每种类型资源实例的最大数量（≤系统资源的总和）
用户申请一组资源，若分配使系统出于安全状态→分配；反之则线程需等到某个其他线程释放足够多的资源为止
2.数据结构
n：线程数
m：资源类型种类
①`Available[j]=k`，长度m-每种资源的可用实例数量
资源类型$R_j$有k个可用实例
②`Max[i][j]=k`，n×m，每个线程的最大需求
线程$T_i$最多可以申请资源类型$R_j$的k个实例
③`Allocation[i][j]=k`，n×m，每个线程现在分配的每种资源类型的实例数量
线程$T_i$已经分配了资源类型$R_j$的k个实例
④`Need[i][j]=k`，n×m，每个线程还需要的剩余资源
线程$T_i$还可能申请资源类型$R_j$的k个实例
$Need[i][j]=Max[i][j]-Allocation[i][j]$
#### 一、安全算法
判断系统是否处于安全状态
Step1-对每个i
`Work=Avaliable`
`Finish[i]=false`
Step2-找到i，满足：
`Finish[i]==false && Need[i]≤Work`
没有-跳到Step4
Step3
`Work=Work+Allocation_i`
`Finish[i]=true`
Step4-如果对所有i，`Finish[i]==true`，则系统处于安全状态
#### 二、资源请求算法
判断是否安全允许请求
`Request[i][j]==k`-线程$T_i$需要资源类型$R_j$的k个实例
$T_i$做出请求：
如果`Request_i＞Need_i`-出错
如果`Available＜Request_i≤Need_i`-线程$T_i$需要等待
如果`Request_i≤Available`-假定系统可以分配给线程$T_i$请求的资源，并按如下方式修改状态：
`Available=Available-Request_i`
`Allocation_i=Allocation_i+Request_i`
`Need_i=Need_i-Request_i`
如果新状态安全-分配；反之等待
#### 三、说明示例
A：10
B：5
C：7
Need=Max-Allocation

|       | Max   | Allocation | Need  | Available |
| ----- | ----- | ---------- | ----- | --------- |
| $T_0$ | 7 5 3 | ~~0 1 0~~  | 7 4 3 | 3 3 2     |
| $T_1$ | 3 2 2 | ~~2 0 0~~  | 1 2 2 |           |
| $T_2$ | 9 0 2 | ~~3 0 2~~  | 6 0 0 |           |
| $T_3$ | 2 2 2 | ~~2 1 1~~  | 0 1 1 |           |
| $T_4$ | 4 3 3 | ~~0 0 2~~  | 4 3 1 |           |
1.安全算法
work=Available=[3,3,2]
finish=[F,F,F,F,F]
第一轮：
$T_0$：无法满足
$T_1$,work=work+Allocation_1=[5,3,2],finish=[F,T,F,F,F]
第二轮：
$T_0$：无法满足
$T_2$：无法满足
$T_3$,work+Allocation_3=[7,4,3],finish=[F,T,F,T,F]
第三轮：
$T_0$,work+Allocation_0=[7,5,3],finish=[T,T,F,T,F]
第四轮：
$T_2$,work=[10,5,5],finish=[T,T,T,T,F]
第五轮：
$T_4$,work=[10,5,7],finish=[T,T,T,T,T]
$<T_1,T_3,T_0,T_2,T_4>$
2.判断是否应该允许申请
①$T_4$(3,3,0)
Request=[3,3,0]
Need=[4,3,1]
Available=[3,3,2]
Request≤Need&&Request≤Available
假设分配：
Available=Available-Request=[0,0,2]
对于所有Need都不够
Need=Need-Request=[1,0,1]
Allocation=Allocation+Request=[3,3,2]
②$T_0$(0,2,0)
Request=[0,2,0]
Need=[7,4,3]
Available=[3,3,2]
Request≤Need&&Request≤Available
假设分配：
Available=Available-Request=[3,1,2]
<span style="background:rgba(240, 200, 0, 0.2)">Need=Need-Request=[7,2,3]</span>【更新再算】
Allocation=Allocation+Request=[0,3,0]
Work=Available=[3,1,2]
finish=[F,F,F,F,F]
第一轮：
$T_0$：无法满足
$T_1$：无法满足
$T_2$：无法满足
$T_3$：
Work=Work+Allocation_3=[5,2,3]
finish=[F,F,F,T,F]
第二轮：
$T_0$：无法满足
$T_1$：
Work=Work+Allocation_1=[7,2,3]
finish=[F,T,F,T,F]
第三轮：
$T_0$：无法满足
$T_1$：已满足
$T_2$：无法满足
$T_3$：已满足
$T_4$：
Work=Work+Allocation_4=[7,2,5]
finish=[F,T,F,T,T]
第四轮：
$T_0$：
Work=Work+Allocation_0=[7,3,5]
finish=[T,T,F,T,T]
第五轮：
$T_0$：已满足
$T_1$：已满足
$T_2$：
Work=Work+Allocation_2=[10,3,7]
finish=[T,T,T,T,T]
安全序列<$T_3$,$T_1$,$T_4$,$T_0$,$T_2$>
## 8.7 死锁检测
### 8.7.1 每种资源类型只有单个实例
1.等待图：$T_i→T_j$表示线程$T_i$等待线程$T_j$释放一个$T_i$所需的资源
等价于$T_i→R_q,R_q→T_j$
2.资源分配图&对应等待图[[lesson8-deadlocks.pdf#page=36&selection=11,0,15,9|lesson8-deadlocks, p.36]]
### <span style="background:rgba(240, 200, 0, 0.2)">8.7.2 资源分配图算法</span>
1.数据结构
①`Available`-可用实例数量
②`Allocation`-当前分配数量
③`Request[i][j]=k`：线程$T_i$正在请求资源类型$R_j$的k个实例
2.算法
Step1-初始化
`Work=Available`
若`Allocation_i!=0`-`Finish[i]=false`
若`Allocation_i==0`-`Finish[i]=true`
Step2-找到i，满足：
`Finish[i]==false && Request_i≤Work`
没有则跳转Step4
Step3
`Work=Work+Allocation_i`
`Finish[i]=true`
Step4
若某个i，`Finish[i]==false`，则系统死锁，且线程$T_i$死锁
e.g.
A：7
B：2
C：6

|       | Allocation | Request | Available |
| ----- | ---------- | ------- | --------- |
| $T_0$ | 0 1 0      | 0 0 0   | 0 0 0     |
| $T_1$ | 2 0 0      | 2 0 2   |           |
| $T_2$ | 3 0 3      | 0 0 0   |           |
| $T_3$ | 2 1 1      | 1 0 0   |           |
| $T_4$ | 0 0 2      | 0 0 2   |           |
Work=Available=[0,0,0]
Finish=[F,F,F,F,F]
第一轮：
$T_0$：
Work=Work+Allocation=[0,1,0]
Finish=[T,F,F,F,F]
第二轮：
$T_0$：已完成
$T_1$：无法满足
$T_2$：
Work=Work+Allocation=[3,1,3]
Finish=[T,F,T,F,F]
第三轮：
$T_0$：已完成
$T_1$：
Work=Work+Allocation=[5,1,3]
Finish=[T,T,T,F,F]
第四轮：
$T_0$：已完成
$T_1$：已完成
$T_2$：已完成
$T_3$：
Work=Work+Allocation=[7,2,4]
Finish=[T,T,T,T,F]
第五轮：
$T_0$：已完成
$T_1$：已完成
$T_2$：已完成
$T_3$：已完成
$T_4$：
Work=Work+Allocation=[7,2,6]
Finish=[T,T,T,T,T]
<$T_0$,$T_2$,$T_1$,$T_3$,$T_4$>
现$T_2$额外申请一个实例：

|       | Allocation | Request | Available |
| ----- | ---------- | ------- | --------- |
| $T_0$ | 0 1 0      | 0 0 0   | 0 0 0     |
| $T_1$ | 2 0 0      | 2 0 2   |           |
| $T_2$ | 3 0 3      | 0 0 1   |           |
| $T_3$ | 2 1 1      | 1 0 0   |           |
| $T_4$ | 0 0 2      | 0 0 2   |           |
Work=Available=[0,0,0]
Finish=[F,F,F,F,F]
第一轮：
$T_0$：
Work=Work+Allocation=[0,1,0]
Finish=[T,F,F,F,F]
第二轮：
$T_0$：已完成
$T_1$：无法满足
$T_2$：无法满足
$T_3$：无法满足
$T_4$：无法满足
→死锁
### 8.7.3 检测算法的使用
1.死锁可能发生的频率
2.当死锁发生时，有多少线程会受影响
## 8.8 死锁恢复
打破死锁的方法：
- 简单地中止一个/多个线程→打破循环等待
- 从一个/多个死锁线程那里抢占一个/多个资源
### 8.8.1 进程与线程的中止
方法：
- 中止所有死锁进程
- 一次中止一个进程，直到消除死锁循环为止
### 8.8.2 资源抢占
需要处理的问题：
- 选择牺牲进程
- 回滚：中止进程并重新执行
- 饥饿：如何保证资源不会总是从同一进程被抢占